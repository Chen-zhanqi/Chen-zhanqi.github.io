<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>世无常景 只争朝夕</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Chen-zhanqi.github.io/"/>
  <updated>2018-11-07T11:57:00.737Z</updated>
  <id>http://Chen-zhanqi.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django发送携带随机验证码邮件 邮箱找回密码</title>
    <link href="http://Chen-zhanqi.github.io/2018/11/06/send-email/"/>
    <id>http://Chen-zhanqi.github.io/2018/11/06/send-email/</id>
    <published>2018-11-06T13:08:09.000Z</published>
    <updated>2018-11-07T11:57:00.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：</strong></p><ul><li>通过邮件来确认用户注册</li><li>后台管理人员针对用户的反馈发送邮件</li><li>通过邮箱来重置用户密码</li></ul><h4 id="电子邮件系统"><a href="#电子邮件系统" class="headerlink" title="电子邮件系统"></a>电子邮件系统</h4><h5 id="在一个因特网电子邮件系统中，通常有三个组成部分："><a href="#在一个因特网电子邮件系统中，通常有三个组成部分：" class="headerlink" title="在一个因特网电子邮件系统中，通常有三个组成部分："></a>在一个因特网电子邮件系统中，通常有三个组成部分：</h5><ul><li>用户代理（User Agent）<br>比如一些第三方客户端，如foxmail，以及常用的浏览器</li><li>邮件服务器（Mail Server）<br>比如QQ邮箱的邮箱服务器，域名为stmp.qq.com</li><li>简单邮件传输协议（SMTP）<br>在邮件服务器中互相通讯所采取的协议</li></ul><h5 id="那么，这三个组成部分是如何运行的呢？"><a href="#那么，这三个组成部分是如何运行的呢？" class="headerlink" title="那么，这三个组成部分是如何运行的呢？"></a>那么，这三个组成部分是如何运行的呢？</h5><p>假设用户A通过用户代理（QQ邮箱）向用户B（163邮箱）发出了一封电子邮件，这个过程可以描述为：</p><ul><li>用户A的用户代理通过SMTP协议登陆QQ邮箱的邮件服务器，并将要发送的内容放在了QQ邮箱的邮件服务器的属于用户A的邮箱中。</li><li>QQ邮箱的邮件服务器通过SMTP协议向163邮箱的邮件服务器发送这封电子邮件。</li><li>163邮箱的邮件服务器在收到电子邮件之后根据邮件的头部得知接收者是用户B，将邮件放到了邮件服务器中属于用户B的邮箱中。</li><li>用户B在用户代理中登录了163的邮件服务器，并通过POP3或者IMAP等“拉”协议拉取邮件服务器中自己的邮件到用户代理中查看。（若是浏览器，可以通过HTTP协议向邮件服务器传送邮件或者拉取邮件）</li></ul><h5 id="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"><a href="#为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？" class="headerlink" title="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"></a>为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？</h5><p><strong>邮件服务器在邮件的传送与拉取中有两个重要作用：</strong></p><ol><li>尽可能的保证在任何时刻维持开机状态，接受来自其他邮件服务器的邮件传输。</li><li>当邮件发送失败后，继续尝试向对方邮件服务器发送，若邮件发送失败，通知用户代理。</li></ol><h4 id="Django配置"><a href="#Django配置" class="headerlink" title="Django配置"></a>Django配置</h4><h5 id="settings配置邮件信息"><a href="#settings配置邮件信息" class="headerlink" title="settings配置邮件信息"></a>settings配置邮件信息</h5><p><img src="/2018/11/06/send-email/01.png" alt=""></p><h5 id="models定义数据库字段信息"><a href="#models定义数据库字段信息" class="headerlink" title="models定义数据库字段信息"></a>models定义数据库字段信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class EmailRecard(models.Model):</span><br><span class="line"></span><br><span class="line">    code = models.CharField(max_length=50, null=False, verbose_name=&apos;验证码&apos;)</span><br><span class="line">    email = models.EmailField(max_length=100, null=False, verbose_name=&apos;收件人邮箱&apos;)</span><br><span class="line">    # 邮件发送的时间</span><br><span class="line">    # auto_now_add 当创建对象时，自动获取当前之间进行赋值</span><br><span class="line">    send_time = models.DateTimeField(auto_now_add=True, verbose_name=&apos;发送时间&apos;)</span><br><span class="line">    # 邮件类型 register 注册    forget 找回密码</span><br><span class="line">    # choices 选项， 规定好选项，该属性值只能是选项中的某一个</span><br><span class="line">    # default 默认值</span><br><span class="line">    email_type = models.CharField(max_length=10, choices=((&apos;register&apos;, &apos;注册账号&apos;), (&apos;forget&apos;, &apos;找回密码&apos;)), default=&apos;register&apos;, verbose_name=&apos;邮件类型&apos;)</span><br><span class="line">    # 过期时间</span><br><span class="line">    expire_time = models.DateTimeField(verbose_name=&apos;过期时间&apos;)</span><br><span class="line">    # 邮件状态，邮件是否已使用</span><br><span class="line">    email_status = models.IntegerField(choices=((1, &apos;已使用&apos;), (0, &apos;未使用&apos;)), default=0, verbose_name=&apos;邮件状态&apos;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &apos;email_recard&apos;</span><br><span class="line">        # 在后台管理界面中显示名称</span><br><span class="line">        verbose_name = &apos;邮件&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><h5 id="定义email-send发送邮件文件"><a href="#定义email-send发送邮件文件" class="headerlink" title="定义email_send发送邮件文件"></a>定义email_send发送邮件文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import datetime</span><br><span class="line"># 导入发送邮件模块</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from UserProject import settings</span><br><span class="line">from .models import EmailRecard</span><br><span class="line"></span><br><span class="line">def random_code(length=16):</span><br><span class="line">    # 随机产生验证码函数</span><br><span class="line">    string = &apos;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890&apos;</span><br><span class="line">    # 随机生成验证码</span><br><span class="line">    code = &apos;&apos;.join([string[random.randint(0, len(string)-1)] for x in range(length)])</span><br><span class="line"></span><br><span class="line">    return code</span><br><span class="line"></span><br><span class="line">def mail_send(to_email, type=&apos;register&apos;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    to_email: 接收邮件的email地址</span><br><span class="line">    type: 邮件类型 register 注册邮件</span><br><span class="line">                   forget 找回密码</span><br><span class="line">    :return: True 发送成功 </span><br><span class="line">             False 发送失败</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    email_recard = EmailRecard()</span><br><span class="line">    # 验证码</span><br><span class="line">    email_recard.code = random_code()</span><br><span class="line">    email_recard.email = to_email</span><br><span class="line">    email_recard.email_type = type</span><br><span class="line">    # 过期时间  获取7天之后的时间</span><br><span class="line">    email_recard.expire_time = datetime.datetime.now() + datetime.timedelta(days=7)</span><br><span class="line"></span><br><span class="line">    if type == &apos;register&apos;:</span><br><span class="line">        message = f&apos;注册成功，点击&lt;a href=&quot;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;激活账户！&apos;</span><br><span class="line">        subject = &apos;注册测试邮件&apos;</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        # 找回密码邮件</span><br><span class="line">        message = f&apos;找回密码邮件，点击链接&lt;a href=&quot;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;修改您的密码!&apos;</span><br><span class="line">        subject = &apos;找回密码测试邮件&apos;</span><br><span class="line">        </span><br><span class="line">    try:</span><br><span class="line">        result = send_mail(subject, message, settings.EMAIL_HOST_USER, [to_email], html_message=message)</span><br><span class="line">        if result == 1:</span><br><span class="line">            # 保存数据到数据库</span><br><span class="line">            email_recard.save()</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">            </span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># 测试部分</span><br><span class="line"># if __name__ == &apos;__main__&apos;:</span><br><span class="line">#</span><br><span class="line">#     # 获取7天之后的时间</span><br><span class="line">#     print(datetime.datetime.now())</span><br><span class="line">#     print(datetime.timedelta(days=7))</span><br><span class="line">#     print(datetime.datetime.now()+ datetime.timedelta(days=7))</span><br></pre></td></tr></table></figure><h5 id="在views中导入自定义的发送邮件文件"><a href="#在views中导入自定义的发送邮件文件" class="headerlink" title="在views中导入自定义的发送邮件文件"></a>在views中导入自定义的发送邮件文件</h5><p><strong>注意路径是否跟当前文件同级</strong><br><img src="/2018/11/06/send-email/03.png" alt=""><br><strong>等表单验证完成，信息确认后，调用邮件函数，并更改数据库密码和邮件状态,最后保存，如下：</strong><br><img src="/2018/11/06/send-email/02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过邮件来确认用户注册&lt;/li&gt;
&lt;li&gt;后台管理人员针对用户的反馈发送邮件&lt;/li&gt;
&lt;li&gt;通过邮箱来重置用户密码&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="Django发送邮件" scheme="http://Chen-zhanqi.github.io/categories/Django%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
    
      <category term="发送邮件" scheme="http://Chen-zhanqi.github.io/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
      <category term="Django" scheme="http://Chen-zhanqi.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>scrapy框架安装</title>
    <link href="http://Chen-zhanqi.github.io/2018/11/02/scrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://Chen-zhanqi.github.io/2018/11/02/scrapy框架安装/</id>
    <published>2018-11-02T11:44:11.000Z</published>
    <updated>2018-11-02T13:28:12.714Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 </strong></p><h4 id="Windows平台安装"><a href="#Windows平台安装" class="headerlink" title="Windows平台安装"></a>Windows平台安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、安装wheel</span><br><span class="line">      pip install wheel</span><br><span class="line">2、安装lxml</span><br><span class="line">是一种使用Python编写的库，可以迅速，灵活地处理XML</span><br><span class="line">      pip install lxml  备用网址：https://pypi.python.org/pypi/lxml/4.1.0</span><br><span class="line">3、安装pyopenssl</span><br><span class="line">      在视窗下，是没有预装pyOPENSSL的，而在Linux的下是已经安装好的</span><br><span class="line">      https://pypi.python.org/pypi/pyOpenSSL/17.5.0 </span><br><span class="line">4、安装Twisted</span><br><span class="line">      https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载对应版本,本地 pip install 本地文件 安装</span><br><span class="line">5、安装pywin32</span><br><span class="line">      https://github.com/mhammond/pywin32/releases 在windows下,必须安装pywin32,下载后直接双击安装</span><br><span class="line">6、安装scrapy</span><br><span class="line">      pip install scrapy</span><br></pre></td></tr></table></figure><h5 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h5><p>输入Scrapy<br>如果提示如下命令，就证明安装成功，如果失败了，请检查上述步骤有何疏漏<br><img src="/2018/11/02/scrapy框架安装/01.png" alt="图片"></p><h4 id="Linux-Ubuntu平台安装"><a href="#Linux-Ubuntu平台安装" class="headerlink" title="Linux Ubuntu平台安装"></a>Linux Ubuntu平台安装</h4><p>Linux下安装非常简单，只需要执行几条命令几个</p><h5 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python2.7 python2.7-dev</span><br></pre></td></tr></table></figure><p>下载好之后，选中该文件所在路径，执行下面的命令<br>sudo python get-pip.py</p><h5 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h5><p>由于Linux下已经预装了lxml和OPENSSL<br>如果想验证lxml，可以分别输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lxml</span><br></pre></td></tr></table></figure></p><p>出现下面的提示这证明已经安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Requirement already satisfied (use --upgrade to upgrade): lxml in /usr/lib/python2.7/dist-packages</span><br></pre></td></tr></table></figure></p><p>如果想验验openssl，则直接输入openssl即可，如果跳转到OPENSSL命令行，则安装成功<br>接下来直接安装Scrapy即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install Scrapy</span><br></pre></td></tr></table></figure></p><p>安装完毕之后，输入scrapy 验证是否安装成功<br>注意，这里的linux下不要输入Scrapy，linux下依然严格区分大小写<br>出现跟Windows结果一样则成功</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 &lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Windows平台安装&quot;&gt;&lt;a href=&quot;#Windows平台安装&quot; class=&quot;headerlink&quot; title=&quot;Windo
      
    
    </summary>
    
      <category term="爬虫框架" scheme="http://Chen-zhanqi.github.io/categories/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="框架" scheme="http://Chen-zhanqi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="安装" scheme="http://Chen-zhanqi.github.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫框架概述</title>
    <link href="http://Chen-zhanqi.github.io/2018/11/02/Scrapy%E6%A1%86%E6%9E%B6/"/>
    <id>http://Chen-zhanqi.github.io/2018/11/02/Scrapy框架/</id>
    <published>2018-11-02T09:14:31.000Z</published>
    <updated>2018-11-02T11:43:04.900Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试</strong></p><h4 id="Scrapy框架组件"><a href="#Scrapy框架组件" class="headerlink" title="Scrapy框架组件"></a>Scrapy框架组件</h4><p><img src="/2018/11/02/Scrapy框架/01.png" alt="图片"></p><ul><li><h5 id="引擎-Engine"><a href="#引擎-Engine" class="headerlink" title="引擎(Engine)"></a>引擎(Engine)</h5>用来处理整个系统的数据流, 触发事务(框架核心)</li><li><h5 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h5>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</li><li><h5 id="下载器-Downloader"><a href="#下载器-Downloader" class="headerlink" title="下载器(Downloader)"></a>下载器(Downloader)</h5>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</li><li><h5 id="爬虫-Spiders"><a href="#爬虫-Spiders" class="headerlink" title="爬虫(Spiders)"></a>爬虫(Spiders)</h5>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</li><li><h5 id="项目管道-Pipeline"><a href="#项目管道-Pipeline" class="headerlink" title="项目管道(Pipeline)"></a>项目管道(Pipeline)</h5>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li><li><h5 id="下载器中间件-Downloader-Middlewares"><a href="#下载器中间件-Downloader-Middlewares" class="headerlink" title="下载器中间件(Downloader Middlewares)"></a>下载器中间件(Downloader Middlewares)</h5>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li><li><h5 id="爬虫中间件-Spider-Middlewares"><a href="#爬虫中间件-Spider-Middlewares" class="headerlink" title="爬虫中间件(Spider Middlewares)"></a>爬虫中间件(Spider Middlewares)</h5>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</li><li><h5 id="调度中间件-Scheduler-Middewares"><a href="#调度中间件-Scheduler-Middewares" class="headerlink" title="调度中间件(Scheduler Middewares)"></a>调度中间件(Scheduler Middewares)</h5>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应<h4 id="Scrapy运行流程"><a href="#Scrapy运行流程" class="headerlink" title="Scrapy运行流程"></a>Scrapy运行流程</h4></li><li>引擎从调度器中取出一个链接(URL)用于接下来的抓取</li><li>引擎把URL封装成一个请求(Request)传给下载器</li><li>下载器把资源下载下来，并封装成应答包(Response)</li><li>爬虫解析Response</li><li>解析出实体（Item）,则交给实体管道进行进一步的处理</li><li>解析出的是链接（URL）,则把URL交给调度器等待抓取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;br&gt;其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon
      
    
    </summary>
    
      <category term="爬虫框架" scheme="http://Chen-zhanqi.github.io/categories/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="框架" scheme="http://Chen-zhanqi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>python常用函数集</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/23/common-function/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/23/common-function/</id>
    <published>2018-10-23T13:53:39.000Z</published>
    <updated>2018-11-07T12:49:50.778Z</updated>
    
    <content type="html"><![CDATA[<h5 id="参数-args和-kwargs的区别"><a href="#参数-args和-kwargs的区别" class="headerlink" title="参数*args和**kwargs的区别"></a>参数*args和**kwargs的区别</h5><p>*args不定长参数，传入函数中是一个元组<br>**kwargs 不定长关键字参数，以key=value形式传递参数，传入函数中是一个字典</p><h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5><h6 id="Strip-去除字符串两端空格-只能删除开头或是结尾的字符"><a href="#Strip-去除字符串两端空格-只能删除开头或是结尾的字符" class="headerlink" title="Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)"></a>Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;00000003210Runoob01230000000&quot;; </span><br><span class="line">print(str.strip(&apos;0&apos;))  # 去除首尾字符 0</span><br><span class="line"> </span><br><span class="line">str2 = &quot;   Runoob      &quot;;   # 去除首尾空格</span><br><span class="line">print str2.strip();</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3210Runoob0123</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure></p><h6 id="Upper-转大写"><a href="#Upper-转大写" class="headerlink" title="Upper( ) 转大写"></a>Upper( ) 转大写</h6><h6 id="Lower-转小写"><a href="#Lower-转小写" class="headerlink" title="Lower( ) 转小写"></a>Lower( ) 转小写</h6><h6 id="Find-查找子串开始位置"><a href="#Find-查找子串开始位置" class="headerlink" title="Find( )  查找子串开始位置"></a>Find( )  查找子串开始位置</h6><h6 id="Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次"><a href="#Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次" class="headerlink" title="Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次"></a>Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;this is string example....wow!!! this is really string&quot;;</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;))</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;, 3))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas is really string</span><br></pre></td></tr></table></figure><h6 id="Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串"><a href="#Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串" class="headerlink" title="Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串"></a>Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;</span><br><span class="line">print(str.split( ))</span><br><span class="line">print(str.split(&apos; &apos;, num = 1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Line1-abcdef&apos;, &apos;Line2-abc&apos;, &apos;Line4-abcd&apos;]</span><br><span class="line">[&apos;Line1-abcdef&apos;, &apos;\nLine2-abc \nLine4-abcd&apos;]</span><br></pre></td></tr></table></figure><h6 id="Join-将序列中的元素以指定的字符连接生成一个新的字符串"><a href="#Join-将序列中的元素以指定的字符连接生成一个新的字符串" class="headerlink" title="Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串"></a>Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.join(元组、列表、字典、字符串) 之后生成的只能是字符串。</span><br><span class="line">所以很多地方很多时候生成了元组、列表、字典后，可以用 join() 来转化为字符串</span><br><span class="line">list=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]</span><br><span class="line">print(&apos;&apos;.join(list))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure><h6 id="map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中"><a href="#map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中" class="headerlink" title="map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中"></a>map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><h6 id="filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中"><a href="#filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中" class="headerlink" title="filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中"></a>filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><h6 id="Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数"><a href="#Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数" class="headerlink" title="Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数"></a>Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">print(reduce(add, [1, 3, 5, 7, 9]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h6 id="math-数字函数"><a href="#math-数字函数" class="headerlink" title="math( )数字函数"></a>math( )数字函数</h6><ul><li><p>math.pow(x, y) 返回x的y次方 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.sqrt(3)</span><br><span class="line">1.7320508075688772</span><br></pre></td></tr></table></figure></li><li><p>math.ceil(x)    返回不小于x的整数     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.ceil(5.2)</span><br><span class="line">6.0</span><br></pre></td></tr></table></figure></li><li><p>math.floor(x)    返回不大于x的整数    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.floor(5.8)</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure></li><li><p>math.trunc(x)    返回x的整数部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.trunc(5.8)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>math.fmod(x, y) 返回x%y（取余）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.fmod(5,2)</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>计算1到100的和,以下两种都可以</strong></p><ul><li>sum(range(1,101)) </li><li>reduce(lambda x,y:x+y, [x for x in range(1,101)])</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;参数-args和-kwargs的区别&quot;&gt;&lt;a href=&quot;#参数-args和-kwargs的区别&quot; class=&quot;headerlink&quot; title=&quot;参数*args和**kwargs的区别&quot;&gt;&lt;/a&gt;参数*args和**kwargs的区别&lt;/h5&gt;&lt;p&gt;*arg
      
    
    </summary>
    
      <category term="随记" scheme="http://Chen-zhanqi.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CSV文件存储</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/14/csv/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/14/csv/</id>
    <published>2018-10-14T06:59:04.000Z</published>
    <updated>2018-11-06T13:48:31.240Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号或制表符。不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。它比Excel文件更加简介，XLS文本是电子表格，它包含了文本、数值、公式和格式等内容，而CSV中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰。所以，有时候用CSV来保存数据是比较方便的。本讲解Pyhon读取和写入CSV文件的过程。</strong></p><h4 id="1-写入"><a href="#1-写入" class="headerlink" title="1.写入"></a>1.写入</h4><p>首先，打开data.csv文件，然后指定打开的模式为w（即写入），获得文件句柄，随后调用csv库的writer()方法初始化写入对象，传入该句柄，然后调用writerow()方法传入每行的数据即可完成写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow([&apos;id&apos;, &apos;name&apos;, &apos;age&apos;])</span><br><span class="line">    writer.writerow([&apos;10001&apos;, &apos;Mike&apos;, 20])</span><br><span class="line">    writer.writerow([&apos;10002&apos;, &apos;Bob&apos;, 22])</span><br><span class="line">    writer.writerow([&apos;10003&apos;, &apos;Jordan&apos;, 21])</span><br></pre></td></tr></table></figure></p><p>运行结束后，会生成一个名为data.csv的文件，此时数据就成功写入了。直接以文本形式打开的话，其内容如下<br><img src="/2018/10/14/csv/02.png" alt=""><br>可以看到，写入的文本默认以逗号分隔，调用一次writerow()方法即可写入一行数据。用Excel打开的结果如下<br><img src="/2018/10/14/csv/01.png" alt=""><br>一般情况下，爬虫爬取的都是结构化数据，我们一般会用字典来表示。在csv库中也提供了字典的写入方式，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10001&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 20&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10002&apos;, &apos;name&apos;: &apos;Bob&apos;, &apos;age&apos;: 22&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10003&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 21&#125;)</span><br></pre></td></tr></table></figure></p><p>这里先定义3个字段，用fieldnames表示，然后将其传给DictWriter来初始化一个字典写入对象，接着可以调用writeheader()方法先写入头信息，然后再调用writerow()方法传入相应字典即可。最终写入的结果是完全相同的<br>另外，如果想追加写入的话，可以修改文件的打开模式，即将open()函数的第二个参数改成a，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10004&apos;, &apos;name&apos;: &apos;Durant&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>这样在上面的基础上再执行这段代码，新行会添加成功,如下：<br><img src="/2018/10/14/csv/03.png" alt=""><br>如果要写入中文内容的话，可能会遇到字符编码的问题，此时需要给open()参数指定编码格式。比如，这里再写入一行包含中文的数据，代码需要改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10005&apos;, &apos;name&apos;: &apos;王伟&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/04.png" alt=""></p><h4 id="2-读取"><a href="#2-读取" class="headerlink" title="2.读取"></a>2.读取</h4><p>我们同使用csv库来读取CSV文件。例如，将刚才写入的文件内容读取出来，相关代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;,&apos;r&apos;, encoding=&apos;utf-8&apos;) as csvfile:</span><br><span class="line">    # 调用csv模块的reader函数读文件</span><br><span class="line">    lines = csv.reader(csvfile)</span><br><span class="line">    for line in lines:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/05.png" alt=""><br>另外，如果接触过pandas的话，可以利用read_csv()方法将数据从CSV中读取出来，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas  as pd</span><br><span class="line"> </span><br><span class="line">df = pd.read_csv(&apos;data.csv&apos;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="/2018/10/14/csv/06.png" alt=""><br>在做数据分析的时候，此种方法用得比较多，也是一种比较方便地读取CSV文件的方法。<br>本文讲述了解了CSV文件的写入和读取方式。这也是一种常用的数据存储方式，需要熟练掌握</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常
      
    
    </summary>
    
      <category term="数据格式存储" scheme="http://Chen-zhanqi.github.io/categories/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据存储" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>TXT文本存储</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/14/txt/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/14/txt/</id>
    <published>2018-10-14T06:22:14.000Z</published>
    <updated>2018-11-02T09:42:22.980Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件</strong></p><h3 id="1-基本实例"><a href="#1-基本实例" class="headerlink" title="1.基本实例"></a>1.基本实例</h3><p>首先，本次保存知乎上“发现”页面的“热门话题”部分,将其问题和答案统一保存成文本形式;可以用requests将网页源代码获取下来,这里使用pyquery解析库解析，接下来将提取的标题、回答者、回答保存到文本，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">url = &apos;https://www.zhihu.com/explore&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;</span><br><span class="line">&#125;</span><br><span class="line">html = requests.get(url, headers=headers).text</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(&apos;.explore-tab .feed-item&apos;).items()</span><br><span class="line">for item in items:</span><br><span class="line">    question = item.find(&apos;h2&apos;).text()</span><br><span class="line">    author = item.find(&apos;.author-link-line&apos;).text()</span><br><span class="line">    answer = pq(item.find(&apos;.content&apos;).html()).text()</span><br><span class="line">    print(question, author, answer)</span><br><span class="line">    file = open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure></p><p>主要是为了演示文件保存的方式，因此requests异常处理部分在此省去。首先，用requests提取知乎的“发现”页面，然后将热门话题的问题、回答者、答案全文提取出来，然后利用Python提供的open()方法打开一个文本文件，获取一个文件操作对象，这里赋值为file，接着利用file对象的write()方法将提取的内容写入文件，最后调用close()方法将其关闭，这样抓取的内容即可成功写入文本中了。<br>运行程序，可以发现在本地生成了一个explore.txt文件，其内容如图下所示<br><img src="/2018/10/14/txt/01.png" alt=""><br>这里open()方法的第一个参数即要保存的目标文件名称，第二个参数为a，代表以追加方式写入到文本。另外，我们还指定了文件的编码为utf-8。最后，写入完成后，还需要调用close()方法来关闭文件对象。</p><h3 id="2-打开方式"><a href="#2-打开方式" class="headerlink" title="2.打开方式"></a>2.打开方式</h3><p>在刚才的实例中，open()方法的第二个参数设置成了a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。</p><ul><li>r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</li><li>rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头。</li><li>r+：以读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。</li><li>ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写</li></ul><h3 id="3-简化写法"><a href="#3-简化写法" class="headerlink" title="3.简化写法"></a>3.简化写法</h3><ul><li>另外，文件写入还有一种简写方法，那就是使用with as语法。在with控制块结束时，文件会自动关闭，所以就不需要再调用close()方法了。这种保存方式可以简写如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>如果想保存时将原文清空，那么可以将第二个参数改写为w，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>上面便是利用Python将结果保存为TXT文件的方法，这种方法简单易用，操作高效，是一种最基本的保存数据的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="数据格式存储" scheme="http://Chen-zhanqi.github.io/categories/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据存储" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>常见网页状态码</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/14/status/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/14/status/</id>
    <published>2018-10-14T06:12:24.000Z</published>
    <updated>2018-10-17T13:39:34.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></p><p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</p><p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></p><p>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2开头 （请求成功）表示成功处理了请求的状态代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。&lt;br&gt;201   （已创建）  请求成功并且服务器创建了新的资源。&lt;br&gt;202   
      
    
    </summary>
    
      <category term="HTTP/S状态码" scheme="http://Chen-zhanqi.github.io/categories/HTTP-S%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Selenium集成到Scrapy中动态获取数据</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/12/scrapy-selenium/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/12/scrapy-selenium/</id>
    <published>2018-10-12T07:31:40.000Z</published>
    <updated>2018-11-02T09:48:02.045Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样,是用 JavaScript 编写的;支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJS无界面浏览器;可以用多种语言(Java，Ruby，Python，Perl，PHP，C#)编写测试用例</strong></p><ul><li><p>在使用Scrapy框架爬虫过程中:<br>有可能网页需要进行滚动，才会加载出全部数据<br>有可能网页需要输入验证，才会加载出数据<br>有可能网页需要登陆后才能进行访问…..<br>此时可以考虑使用Selenium自动化检测框架爬取数据,将代码写在middlewares.py文件中,最后直接返回response</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line"># Response 基础响应类</span><br><span class="line">from scrapy.http.response import Response</span><br><span class="line"># HtmlResponse 网页响应类 HtmlResponse文本响应类</span><br><span class="line">from scrapy.http import HtmlResponse, TextResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SeleniumMiddleware(object):</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line"></span><br><span class="line">        # 1.创建浏览器对象</span><br><span class="line">        # 无头浏览器模式</span><br><span class="line">        opt = Options()</span><br><span class="line">        opt.add_argument(&apos;--headless&apos;)</span><br><span class="line">        driver = webdriver.Chrome(chrome_options=opt)</span><br><span class="line">        # 2.打开网址</span><br><span class="line">        driver.get(request.url)</span><br><span class="line">        # 3.等待网页加载完成</span><br><span class="line">        # implicitly_wait 等待网页全部加载完成</span><br><span class="line">        driver.implicitly_wait(10)</span><br><span class="line"></span><br><span class="line">        # 4.拿到源代码</span><br><span class="line">        html = driver.page_source</span><br><span class="line"></span><br><span class="line">        # 创建response对象</span><br><span class="line">        response = HtmlResponse(url=request.url, status=200, body=bytes(html, encoding=&apos;utf-8&apos;), request=request)</span><br><span class="line">        # 退出浏览器</span><br><span class="line">        driver.quit()</span><br><span class="line"></span><br><span class="line">        # 返回response</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response, spider):</span><br><span class="line"></span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">        # 获取数据代码写在爬虫文件里</span><br></pre></td></tr></table></figure></li><li><p>最后列举一下Selenium常用的查找元素方法<br>find_element_by_id    通过元素id定位<br>find_element_by_name    通过元素name定位<br>find_element_by_xpath    通过xpath表达式定位<br>find_element_by_link_text    通过完整超链接定位<br>find_element_by_partial_link_text    通过部分链接定位<br>find_element_by_tag_name    通过标签定位<br>find_element_by_class_name    通过类名进行定位<br>find_elements_by_css_selector    通过css选择器进行定位<br><strong>Selenium库使用详情<a href="https://blog.csdn.net/weixin_36279318/article/details/79475388" target="_blank" rel="noopener">点击</a>参考博客</strong></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样,是用 JavaScript 编写的;支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJ
      
    
    </summary>
    
      <category term="Scrapy框架爬虫" scheme="http://Chen-zhanqi.github.io/categories/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="爬虫" scheme="http://Chen-zhanqi.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy框架设置随机请求头</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/11/RandomUA/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/11/RandomUA/</id>
    <published>2018-10-11T12:00:21.000Z</published>
    <updated>2018-11-02T09:46:08.606Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在settings中设置通用请求头(一般不用)<br><img src="/2018/10/11/RandomUA/02.png" alt="图片丢失..."></li><li>设置随机请求头先终端命令<strong>pip install fake_useragent</strong>下载第三方包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 导入第三方随机请求头模块包</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line"># 自定义随机请求头类</span><br><span class="line">class RandomUAMiddleware(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 创建随机请求头对象</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理请求</span><br><span class="line">        :param request: 请求对象</span><br><span class="line">        :param spider: 爬虫对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        request.headers.setdefault(b&apos;User-Agent&apos;, self.ua.random)</span><br><span class="line">        print(request)</span><br><span class="line">        # 设置代理ip</span><br><span class="line">        # request.meta[&apos;proxy&apos;] = &apos;http://xxx.xxx.xx.xx:端口&apos;</span><br></pre></td></tr></table></figure></li></ul><p><strong>最后需要在settings中更改以下配置</strong><br><img src="/2018/10/11/RandomUA/01.png" alt="图片丢失..."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在settings中设置通用请求头(一般不用)&lt;br&gt;&lt;img src=&quot;/2018/10/11/RandomUA/02.png&quot; alt=&quot;图片丢失...&quot;&gt;&lt;/li&gt;
&lt;li&gt;设置随机请求头先终端命令&lt;strong&gt;pip install fake_user
      
    
    </summary>
    
      <category term="Scrapy框架爬虫" scheme="http://Chen-zhanqi.github.io/categories/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy中将数据异步写入MYSQL数据库</title>
    <link href="http://Chen-zhanqi.github.io/2018/10/11/AsyncToSql/"/>
    <id>http://Chen-zhanqi.github.io/2018/10/11/AsyncToSql/</id>
    <published>2018-10-11T07:32:28.000Z</published>
    <updated>2018-11-02T09:44:40.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…"><a href="#在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…" class="headerlink" title="在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…"></a><strong>在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…</strong></h4><p><strong>在pipelines中可以自定义图片、文件下载保存路径,保存json、excel、sqlite、异步写入mysql数据库等</strong></p><ul><li>首先在settings中配置连接MYSQL的参数,如下图<br><img src="/2018/10/11/AsyncToSql/01.png" alt="图片失踪"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># 异步写入数据库</span><br><span class="line"># adbapi 专门用于异步操作数据库的模块</span><br><span class="line">from twisted.enterprise import adbapi</span><br><span class="line"># DictCursor 游标类型</span><br><span class="line">from pymysql.cursors import DictCursor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TwistedMysqlPipeline(object):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    1.链接数据，获取游标</span><br><span class="line">    2.准备sql语句，执行sql</span><br><span class="line">    3.提交操作，关闭游标，关闭数据库</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    # 在调用TwistedMysqlPipeline时，第一个调用该函数</span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line"></span><br><span class="line">        pramars = dict(</span><br><span class="line">            host=settings[&apos;MYSQL_HOST&apos;],</span><br><span class="line">            port=settings[&apos;MYSQL_PORT&apos;],</span><br><span class="line">            user=settings[&apos;MYSQL_USER&apos;],</span><br><span class="line">            password=settings[&apos;MYSQL_PASSWORD&apos;],</span><br><span class="line">            db=settings[&apos;MYSQL_DB&apos;],</span><br><span class="line">            charset=settings[&apos;MYSQL_CHARSET&apos;],</span><br><span class="line">            use_unicode=True,</span><br><span class="line">            cursorclass=DictCursor</span><br><span class="line">        )</span><br><span class="line">        # 连接池</span><br><span class="line">        # 1.使用的第三方操作mysql的包</span><br><span class="line">        # 2.链接mysql需要的参数</span><br><span class="line">        db_pool = adbapi.ConnectionPool(&apos;pymysql&apos;, **pramars)</span><br><span class="line">        # 返回当前类的对象，并且把db_pool作为参数传递到初始化函数中</span><br><span class="line">        return cls(db_pool)</span><br><span class="line"></span><br><span class="line">    def __init__(self, db_pool):</span><br><span class="line">        # 将db_pool赋值给self.db_pool属性，在process_item函数中就可以使用db_pool</span><br><span class="line">        self.db_pool = db_pool</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line"></span><br><span class="line">        # 将写入数据库的操作放入链接池中</span><br><span class="line">        # 参数1.要异步执行的操作</span><br><span class="line">        # 参数2.异步执行操作需要的参数</span><br><span class="line">        result = self.db_pool.runInteraction(self.insert_item, item)</span><br><span class="line"></span><br><span class="line">        # 给执行结果添加错误回调函数</span><br><span class="line">        result.addErrback(self.sql_faild, item)</span><br><span class="line"></span><br><span class="line">        # 交给下一个pipeline继续进行处理</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def sql_faild(self, fail, item):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param fail: 错误原因</span><br><span class="line">        :param item: 执行sql错误的数据</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(fail)</span><br><span class="line">        print(&apos;出现问题的数据&#123;&#125;&apos;.format(item))</span><br><span class="line"></span><br><span class="line">    def insert_item(self, cursor, item):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        操作数据写入的函数</span><br><span class="line">        :param cursor: 游标,自动传入</span><br><span class="line">        :param item: 要写入的数据</span><br><span class="line">        :return:</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        sql = &apos;INSERT INTO ivsky(alt,src)VALUES(%s,%s)&apos;</span><br><span class="line">        cursor.execute(sql,(item[&apos;alt&apos;], item[&apos;src&apos;]))</span><br></pre></td></tr></table></figure></li></ul><p><strong>大概步骤如下</strong></p><ol><li>在settings中配置Mysql链接需要的参数</li><li>自定义Pipeline，实现from_settings函数</li><li>from twisted.enterprise import adbapi 引入连接池模块</li><li>from pymysql import cursors 引入游标模块</li><li>在from_settings中，准备链接数据库参数，创建db_pool连接池，创建返回当前类的对象，传入db_pool</li><li>实现初始化函数,在初始化函数中,将db_pool赋值self的属性</li><li>实现process_item函数<br> 7.1 query = self.db_pool.runInteraction(执行插入数据操作的函数对象，函数需要参数)，并接受执行返回结果<br> 7.2 query.addErrback(错误回调函数，函数需要参数)，添加执行sql失败回调的函数，在回调函数中对错误数据进一步处理 </li><li>实现插入数据操作的函数，准备sql，执行sql</li><li>实现错误回调函数，在回调函数中对错误数据进一步处理 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些
      
    
    </summary>
    
      <category term="Scrapy框架爬虫" scheme="http://Chen-zhanqi.github.io/categories/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="数据库" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="爬虫" scheme="http://Chen-zhanqi.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之(Terminal)创建数据库,通过代码对数据表、数据的基本操作</title>
    <link href="http://Chen-zhanqi.github.io/2018/09/30/PyMysql/"/>
    <id>http://Chen-zhanqi.github.io/2018/09/30/PyMysql/</id>
    <published>2018-09-30T07:28:34.000Z</published>
    <updated>2018-11-02T09:44:50.955Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"><a href="#MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本" class="headerlink" title="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"></a><em>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL<a href="https://dev.mysql.com/downloads/shell/" target="_blank" rel="noopener">官方文档</a>下载对应版本</em></h4><h2 id="一-使用终端命令创建数据库"><a href="#一-使用终端命令创建数据库" class="headerlink" title="一.使用终端命令创建数据库"></a>一.使用终端命令创建数据库</h2><ul><li>在python代码连接数据库前，先要确认是否已经创建了数据库<br>Terminal输入命令<strong>mysql -u用户 -p密码</strong>进入mysql<br><img src="/2018/09/30/PyMysql/01.png" alt="图片旅游中..."></li><li>使用<strong>create database dbname</strong>命令(create)创建数据库<br><img src="/2018/09/30/PyMysql/02.png" alt="图片旅游中..."></li><li>使用<strong>show databases</strong>命令(show)查看所有数据库<br><img src="/2018/09/30/PyMysql/03.png" alt="图片旅游中..."><br>数据库创建完成,接着通过python代码操作</li></ul><h2 id="二-数据库CRUD-增删改查-操作"><a href="#二-数据库CRUD-增删改查-操作" class="headerlink" title="二.数据库CRUD(增删改查)操作"></a>二.数据库CRUD(增删改查)操作</h2><ul><li><p>先cmd输入<strong>pip install pymysql</strong>安装pymysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pymysql  #导入pymysql</span><br><span class="line"> </span><br><span class="line">#打开数据库连接</span><br><span class="line">connect= pymysql.connect(</span><br><span class="line">host=&quot;127.0.0.1&quot;, #主机IP</span><br><span class="line">user=&quot;root&quot;, #用户</span><br><span class="line"> password=&quot;123456&quot;,#密码</span><br><span class="line"> db=&quot;test&quot;,#数据库</span><br><span class="line"> port=3307#数据库默认端口</span><br><span class="line"> )</span><br><span class="line"> #这些只是连接数据库少不了的一些参数,参数还有很多</span><br><span class="line">#使用cursor()方法获取操作游标,接下来的操作操作需要游标执行 </span><br><span class="line">cursor = connect.cursor()</span><br></pre></td></tr></table></figure></li><li><p>创建一个不存在的表/结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = &apos;CREATE TABLE if not exists dbname(id integer primary key unique, name CHAR(20) NOT NULL,age INT)&apos;</span><br><span class="line">#游标执行sql</span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert_sql = &apos;INSERT INTO dbname(name,age)VALUES (&apos;李易峰&apos;, 20)&apos;</span><br><span class="line">#游标执行insert_sql</span><br><span class="line">cursor.execute(insert_sql)</span><br></pre></td></tr></table></figure></li><li><p>查询匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有</span><br><span class="line">select_table = &quot;SELECT * from dbname&quot;</span><br><span class="line">cursor.execute(select_table)</span><br><span class="line"></span><br><span class="line"># 设置匹配条件</span><br><span class="line"># where: 指定条件</span><br><span class="line"># like：主要用于匹配数据库中的多条记录</span><br><span class="line"># a_：以a开头的记录，并且仅匹配a后一个字符的数据</span><br><span class="line"># %a%：数据中包含a的数据</span><br><span class="line"># %a：以a结尾的数据</span><br><span class="line"># a%：匹配以a开头的数据</span><br><span class="line"># 比如查询学生数据库所有以李开头的学生信息</span><br><span class="line">select_sql = &apos;SELECT * from dbname where like &quot;李%&quot;&apos;</span><br><span class="line">cursor.execute(select_sql)</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update_sql = &quot;UPDATE dbname SET age=&apos;%s&apos;&quot;%(&apos;18&apos;)</span><br><span class="line">cursor.execute(update_sql)</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete_sql = &quot;DELETE from dbname where name=&apos;李四&apos;&quot;</span><br><span class="line">cursor.execute(delete_sql)</span><br></pre></td></tr></table></figure></li><li><p>关闭数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交操作</span><br><span class="line">connect.commit()</span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"># 关闭数据库</span><br><span class="line">connect.close()</span><br></pre></td></tr></table></figure></li></ul><blockquote><blockquote><p><strong>每次操作数据库后需要提交/关闭数据库;对于我们来说对数据库最多的操作是添加与查询</strong></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMyS
      
    
    </summary>
    
      <category term="数据库" scheme="http://Chen-zhanqi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>xpath语法与LXML库的基本使用</title>
    <link href="http://Chen-zhanqi.github.io/2018/09/29/xpath/"/>
    <id>http://Chen-zhanqi.github.io/2018/09/29/xpath/</id>
    <published>2018-09-29T12:03:43.000Z</published>
    <updated>2018-11-03T02:17:49.412Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XPath 是一门在 XML 文档中查找信息的语言,但其实它也可以用来查找HTML信息.它可以借助XPth强大的语法很方便的定位元素,而且现在很多浏览器都有插件让你很容易的就得到元素的XPath路径,如firefox的firebug插件…</strong></p><h3 id="一-常见数据类型"><a href="#一-常见数据类型" class="headerlink" title="一.常见数据类型"></a>一.常见数据类型</h3><ul><li>用Python发送 http/https 请求获取网上数据,从web上采集回来的数据的数据类型有很多种,主要有:</li></ul><ol><li>放在HTML里.</li><li>直接放在javascript里.</li><li>放在JSON里.</li><li>放在XML里.</li></ol><ul><li>常用来解析这些数据的方式有re/正则表达式,XPath定位,BeautifulSoup定位,json等,本文记录xpath语法的基本使用</li></ul><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二.安装"></a>二.安装</h3><ul><li><strong>使用xpath语法前需要安装第三方库LXML</strong><br>lxml第三方的HTML解析库,Xpath全称是XML Path Language，也就是XML路径语言,它是一门在XML文档中查找信息的语言,它最初是用来搜寻XML文档的。但是它同样也适用于HTML文档的搜索,xpath是通过路径表达式在HTML中选择节点</li><li>使用命令行工具<strong>pip3 install lxml</strong>安装lxml第三方库<br><img src="/2018/09/29/xpath/01.png" alt="图片吃饭去了"><br><img src="/2018/09/29/xpath/02.png" alt="图片吃饭去了"></li></ul><h3 id="三-语法使用"><a href="#三-语法使用" class="headerlink" title="三.语法使用"></a>三.语法使用</h3><ul><li>解析html源码字符串。使用“lxml.etree.HTML( )”进行解析<br><img src="/2018/09/29/xpath/03.png" alt="图片吃饭去了"></li><li><strong>选取节点,下面是最常用的路径表达式</strong><br><img src="/2018/09/29/xpath/06.png" alt="图片吃饭去了"><br><img src="/2018/09/29/xpath/07.png" alt="图片吃饭去了"></li><li>tostring()函数是将一个element tree对象转化为html字符串</li><li>fromstring()函数是将一个字符串转化为一个element tree对象</li><li>text()只能获取当前标签的文本内容，无法获取子标签的文本内容</li><li>//text()可以将标签及子标签的文本内容全部输出，包含标签之间的换行符</li><li>contains(@class, “hao123”)：查找class属性值中包含hao123的标签，一般用于class有多个值的情况</li><li><p><strong>以下面xml文档为例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">html_code=</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://www.baidu.com&quot; class=&quot;first_a&quot;&gt;百度一下&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://mail.qq.com&quot; id=&quot;second_a&quot;&gt;QQ邮箱&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://www.taobao.com&quot;&gt;淘宝网&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;a href=&quot;https://pypi.python.org&quot; class=&quot;first_a&quot;&gt;Python官网&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;https://pypi.python.org&quot; class=&quot;second_a&quot;&gt;Python&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;p class=&quot;one&quot;&gt;first_p_tag&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;second&quot;&gt;second_p_tag&lt;/p&gt;</span><br><span class="line">        &lt;div class=&quot;one&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;first second third&quot;&gt;11111111&lt;/p&gt;</span><br><span class="line">            &lt;p class=&quot;hao123&quot;&gt;hao123.com&lt;/p&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;我是神&lt;span&gt;zhiyou&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>查找</strong></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> html_obj = etree.HTML(html_code)</span><br><span class="line">print(type(html_obj))</span><br><span class="line">print(html_obj)</span><br><span class="line">#查找div中的a标签</span><br><span class="line">div_a = html_obj.xpath(&apos;//div/a/text()&apos;)[0]</span><br><span class="line">print(div_a)</span><br><span class="line">second_a = html_obj.xpath(&apos;//ul/li[last()]/a[@class=&quot;second_a&quot;]/text()&apos;)[0]</span><br><span class="line">print(second_a)</span><br><span class="line">img = html_obj.xpath(&apos;//body/ul/li/a/@href&apos;)</span><br><span class="line">print(img)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;lxml.etree._Element&apos;&gt;</span><br><span class="line">&lt;Element html at 0x23f4dfeef08&gt;</span><br><span class="line">我是神</span><br><span class="line">Python</span><br><span class="line">[&apos;https://www.baidu.com&apos;, &apos;https://mail.qq.com&apos;, &apos;https://www.taobao.com&apos;, &apos;https://pypi.python.org&apos;, &apos;https://pypi.python.org&apos;]</span><br></pre></td></tr></table></figure></li><li><p>xpath拿到得都是一个个的ElementTree对象，所以如果需要查找内容的话，还需要遍历拿到数据的列表<br><strong>更多详情可以参考<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">W3school</a></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;XPath 是一门在 XML 文档中查找信息的语言,但其实它也可以用来查找HTML信息.它可以借助XPth强大的语法很方便的定位元素,而且现在很多浏览器都有插件让你很容易的就得到元素的XPath路径,如firefox的firebug插件…&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="数据解析" scheme="http://Chen-zhanqi.github.io/categories/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="数据解析" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy基于scrapy_redis部署分布式爬虫</title>
    <link href="http://Chen-zhanqi.github.io/2018/09/28/scrapy-redis/"/>
    <id>http://Chen-zhanqi.github.io/2018/09/28/scrapy-redis/</id>
    <published>2018-09-28T12:51:03.000Z</published>
    <updated>2018-11-08T09:55:14.485Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-scrapy-redis简介"><a href="#一-scrapy-redis简介" class="headerlink" title="一. scrapy-redis简介"></a>一. scrapy-redis简介</h4><p><strong>scrapy-redis是scrapy框架基于redis数据库的组件，用于scrapy项目的分布式开发和部署</strong></p><ul><li>分布式爬取<br>可以启动多个spider工程，相互之间共享单个redis的requests队列。最适合广泛的多个域名网站的内容爬取</li><li>分布式数据处理<br>爬取到的scrapy的item数据可以推入到redis队列中，这意味着你可以根据需求启动尽可能多的处理程序来共享item的队列，进行item数据持久化处理</li><li>Scrapy即插即用组件<br>Scheduler调度器 + Duplication复制 过滤器，Item Pipeline，基本spider</li></ul><h4 id="二-安装配置"><a href="#二-安装配置" class="headerlink" title="二. 安装配置"></a>二. 安装配置</h4><ol><li><strong>使用命令行工具输入pip3 install scrapy_redis下载工具包 scrapy_redis</strong><br><img src="/2018/09/28/scrapy-redis/01.png" alt=""></li><li><strong>打开爬虫项目,找到settings全局配置文件,配置scrapy项目使用的调度器及过滤器信息</strong><br><img src="/2018/09/28/scrapy-redis/02.png" alt=""></li><li><strong>上面是将配置信息配写在settings全局配置文件中，如果一个项目中有多个爬虫，想要将每个爬取数据存入不同的数据库或者其他不需要全局配置的信息，可以将配置信息写入当前爬虫文件中，如下：</strong><br><img src="/2018/09/28/scrapy-redis/09.png" alt=""></li><li><strong>修改spider爬虫文件,首先要引入一个scrapy_redis.spider文件中的一个RedisSpider类,然后把spider爬虫文件原来继承的scrapy.Spider类改为引入的RedisSpider这个类</strong><br><img src="/2018/09/28/scrapy-redis/03.png" alt=""></li><li><strong>在redis安装目录下修改redis配置文件，后缀为conf的文件，将bing 127.0.0.1 改为 bing 0.0.0.0，允许其他电脑ip连接，如下：</strong><br><img src="/2018/09/28/scrapy-redis/10.png" alt=""></li><li><strong>如果连接的有远程服务,例如MySQL,Redis等,需要将远程服务连接开启,保证在其他主机上能够成功连接,才能将数据写入主机数据库</strong><br><img src="/2018/09/28/scrapy-redis/04.png" alt=""><br><img src="/2018/09/28/scrapy-redis/06.png" alt=""></li><li><strong>启动redis服务</strong><br><img src="/2018/09/28/scrapy-redis/11.png" alt=""></li><li><strong>将主机爬虫启动起来,然后启动其他服务器爬虫，所有爬虫会处于等待状态</strong><br>输入以下命令<br><img src="/2018/09/28/scrapy-redis/08.png" alt=""></li></ol><h4 id="三-分布式逻辑分析"><a href="#三-分布式逻辑分析" class="headerlink" title="三. 分布式逻辑分析"></a>三. 分布式逻辑分析</h4><p><strong>分布式用到的代码基本就是同一套代码</strong></p><ol><li>先把项目配置为分布式</li><li>把项目拷贝到多台服务器中</li><li>把所有爬虫项目都跑起来</li><li>在主redis-cli中lpush你的网址即可</li><li>效果：所有爬虫都开始运行，并且数据不重复</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-scrapy-redis简介&quot;&gt;&lt;a href=&quot;#一-scrapy-redis简介&quot; class=&quot;headerlink&quot; title=&quot;一. scrapy-redis简介&quot;&gt;&lt;/a&gt;一. scrapy-redis简介&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;scra
      
    
    </summary>
    
      <category term="Scrapy框架爬虫" scheme="http://Chen-zhanqi.github.io/categories/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="爬虫" scheme="http://Chen-zhanqi.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="部署" scheme="http://Chen-zhanqi.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>scrapyd部署爬虫项目</title>
    <link href="http://Chen-zhanqi.github.io/2018/09/27/scrapyd-bushu/"/>
    <id>http://Chen-zhanqi.github.io/2018/09/27/scrapyd-bushu/</id>
    <published>2018-09-27T13:19:07.000Z</published>
    <updated>2018-11-02T09:48:25.548Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…"><a href="#scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…" class="headerlink" title="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…"></a><em>scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…</em></h4><hr><h2 id="一-安装-配置scrapyd"><a href="#一-安装-配置scrapyd" class="headerlink" title="一. 安装/配置scrapyd"></a>一. 安装/配置scrapyd</h2><ul><li>打开命令行工具执行<strong>pip install scrapyd</strong><br><img src="/2018/09/27/scrapyd-bushu/01.png" alt=""></li><li>输入scrapyd启动scrapyd服务<br><img src="/2018/09/27/scrapyd-bushu/02.png" alt=""></li><li>浏览器输入127.0.0.1:6800,如下图启动成功<br><img src="/2018/09/27/scrapyd-bushu/03.png" alt=""></li><li>在非C盘下创建一个scrapydTest(自定义)文件夹,此文件夹是用来部署爬虫项目;命令行工具cd进入scrapydTest文件夹;输入scrapyd执行，执行完成后会自动新建一个dbs空文件夹，用来存放爬虫项目的数据文件;这个命令行工具一直处于运行状态,以下操作打开新命令行工具<br><img src="/2018/09/27/scrapyd-bushu/04.png" alt=""></li><li>安装scrapyd-client模块。scrapyd-client模块是专门打包scrapy爬虫项目到scrapyd服务中的，进入py环境，执行命令 <strong>pip install scrapy-client</strong>，安装完成后，在python安装目录的scripts文件夹中会出现scrapyd-deploy无后缀文件，这个scrapyd-deploy无后缀文件是启动文件，在Linux系统下可以远行，在windows下是不能运行的，所以我们需要编辑一下使其在windows可以运行<br><img src="/2018/09/27/scrapyd-bushu/06.png" alt=""></li><li>新建一个scrapyd-deploy.bat文件,如上图;右键选择编辑，输入以下配置<br>@echo off<br>“C:\Users\qianzhen\Envs\scrapySpider\Scripts\python.exe” “C:\Users\qianzhen\Envs\scrapySpider\Scripts\scrapyd-deploy” %1 %2 %3 %4 %5 %6 %7 %8 %9<br><img src="/2018/09/27/scrapyd-bushu/05.png" alt=""><br><strong>注意：两个路径之间是空格，一定要使用双引号。单引号的话会错误。两个路经是自己的python路经</strong></li></ul><h2 id="二-部署-启动项目"><a href="#二-部署-启动项目" class="headerlink" title="二.部署/启动项目"></a>二.部署/启动项目</h2><ul><li>编辑器打开爬虫项目中的scrapy.cfg文件，这个文件就是给scrapyd-deploy使用的<br>将url这行代码解掉注释，并且给设置你的部署名称<br><img src="/2018/09/27/scrapyd-bushu/08.png" alt=""></li><li>再次执行scrapyd-deploy -l 启动服务，可以看到设置的名称,接下来可以开始打包了<br><img src="/2018/09/27/scrapyd-bushu/09.png" alt=""></li><li>开始打包前，执行一个命令：scrapy list ,这个命令执行成功说明可以打包了,如果没执行成功,说明还有工作没完成;以上步骤没有出错,一般不会出现问题<br><img src="/2018/09/27/scrapyd-bushu/10.png" alt=""></li><li>如果错误提示，什么远程计算机拒绝，说明你的scrapy项目有链接远程计算机，如链接数据库或者elasticsearch(搜索引擎)之类的，需要先将链接服务器启动<br>执行 scrapy list  命令返回了爬虫名称说明一切ok了，如上图,继续go…</li><li>执行打包命令： scrapyd-deploy 部署名称 -p 项目名称<br>如：scrapyd-deploy tt -p mytest<br>如下显示表示scrapy项目打包成功,scrapydTest下egg文件夹中有项目即可<br><img src="/2018/09/27/scrapyd-bushu/11.png" alt=""></li><li>网页中127.0.0.1:6800查看是否部署到服务器<br><img src="/2018/09/27/scrapyd-bushu/12.png" alt=""></li><li>最后就是通过scrapyd命令(API)接口发送请求,比如通过请求启动刚部署服务器上的爬虫项目<br>命令输入:<strong>curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=项目名称 -d spider=爬虫名称</strong><br>如: curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=mytest -d spider=tt<br><img src="/2018/09/27/scrapyd-bushu/15.png" alt=""></li><li>jobs中查看爬虫状态<br><img src="/2018/09/27/scrapyd-bushu/14.png" alt=""></li></ul><ul><li><strong>其他请求接口可通过<a href="https://scrapyd.readthedocs.io/en/stable/api.html#" target="_blank" rel="noopener">官方文档</a>查看,如下图,全英文看不懂,没关系,有谷歌..;</strong><br><img src="/2018/09/27/scrapyd-bushu/13.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…&quot;&gt;&lt;a href=&quot;#scra
      
    
    </summary>
    
      <category term="Scrapy框架爬虫" scheme="http://Chen-zhanqi.github.io/categories/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://Chen-zhanqi.github.io/tags/scrapy/"/>
    
      <category term="部署" scheme="http://Chen-zhanqi.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://Chen-zhanqi.github.io/2018/09/18/python/"/>
    <id>http://Chen-zhanqi.github.io/2018/09/18/python/</id>
    <published>2018-09-18T13:21:36.000Z</published>
    <updated>2018-11-19T14:34:49.683Z</updated>
    
    <content type="html"><![CDATA[<p><strong>正则表达式：是对字符串的内容进行匹配查询的一种操作方式，通过预先定义的一些特殊字符的组合，形成一种字符串的匹配规则。再根据这些规则来对字符串中的某一些内容进行提取或者查找</strong></p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的</p><ol><li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”)</li><li>可以通过正则表达式，从字符串中获取我们想要的特定部分</li></ol><h4 id="速记理解技巧"><a href="#速记理解技巧" class="headerlink" title="速记理解技巧"></a>速记理解技巧</h4><p><strong>. [ ] ^ $</strong><br>四个字符是所有语言都支持的正则表达式，所以这四个是基础的正则表达式。正则难理解因为里面有一个等价的概念，这个概念大大增加了理解难度，让很多初学者看起来会懵，如果把等价都恢复成原始写法，自己书写正则就超级简单了，就像说话一样去写你的正则了：</p><h5 id="等价："><a href="#等价：" class="headerlink" title="等价："></a>等价：</h5><p>等价是等同于的意思，表示同样的功能，用不同符号来书写</p><p><strong>?, *, +, \d, \w</strong> 都是等价字符</p><p>?  等价于匹配长度{0,1}<br>\d 等价于[0-9]<br>\D 等价于[^0-9]<br>\w 等价于[A-Za-z_0-9]<br>\W 等价于[^A-Za-z_0-9]</p><h5 id="匹配url地址示例"><a href="#匹配url地址示例" class="headerlink" title="匹配url地址示例"></a>匹配url地址示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-z]+://[^\s]*</span><br></pre></td></tr></table></figure><p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似URL的文本，那就会被提取出来。<br>正则表达式里面都是有特定的语法规则;比如以上示例：a-z代表匹配任意的小写字母，\s表示匹配任意的空白字符,*就代表匹配前面的字符任意多个。<br>对于网页来说，如果想找出网页源代码里有多少URL，用匹配URL的正则表达式去匹配即可</p><h5 id="常用运算符与表达式："><a href="#常用运算符与表达式：" class="headerlink" title="常用运算符与表达式："></a>常用运算符与表达式：</h5><p><strong> 模式 - - - - 描述 </strong></p><p>| - - - - - 或</p><p>a|b - - - - - 匹配a或b</p><p>\ - - - - - 转义(. 字符点)</p><p>[A-Z] - - - - - 26个大写字母</p><p>[a-z] - - - - - 26个小写字母</p><p>[0-9] - - - - - 0至9数字</p><p>[A-Za-z0-9] - - - - - 26个大写字母、26个小写字母和0至9数字</p><p>\w - - - - - 匹配字母、数字及下划线</p><p>\W - - - - - 匹配不是字母、数字及下划线的字符</p><p>\s - - - - - 匹配任意空白字符，等价于[\t\n\r\f]</p><p>\S - - - - - 匹配任意非空字符</p><p>\d - - - - - 匹配任意数字，等价于[0-9]</p><p>\D - - - - - 匹配任意非数字的字符</p><p>\A - - - - - 匹配字符串开头</p><p>\Z - - - - - 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</p><p>\z - - - - - 匹配字符串结尾，如果存在换行，同时还会匹配换行符</p><p>\G - - - - - 匹配最后匹配完成的位置</p><p>\n - - - - - 匹配一个换行符</p><p>\t - - - - - 匹配一个制表符</p><p>^ - - - - - 匹配一行字符串的开头</p><p>$ - - - - - 匹配一行字符串的结尾</p><p>. - - - - - 匹配任意字符,除了换行符,当re.DOTALL标记被指定时,则可以匹配包括换行符的任意字符</p><p>[…] - - - - - 用来表示一组字符，单独列出，比如[amk]匹配a、m或k，</p><p>[^…] - - - - - 不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符,不包含,默认是一个字符长度</p><p>*- - - - - 匹配0个或多个表达式</p><p>+- - - - - 匹配1个或多个表达式</p><p>? - - - - - 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</p><p>{n} - - - - - 精确匹配n个前面的表达式</p><p>{n, m} - - - - - 匹配n到m次由前面正则表达式定义的片段，匹配长度，贪婪方式</p><p>( ) - - - - - 匹配括号内的表达式，也表示一个组</p><h5 id="分割语法："><a href="#分割语法：" class="headerlink" title="分割语法："></a>分割语法：</h5><blockquote><p>[A,H,T,W] 包含A或H或T或W字母<br>[a,h,t,w] 包含a或h或t或w字母<br>[0,3,6,8] 包含0或3或6或8数字</p></blockquote><h5 id="语法与释义："><a href="#语法与释义：" class="headerlink" title="语法与释义："></a>语法与释义：</h5><blockquote><p>基础语法 “^([]{})([]{})([]{})$”</p></blockquote><p>正则字符串 = “开始([包含内容]{长度})([包含内容]{长度})([包含内容]{长度})结束”;</p><p><strong>?, *, +, \d, \w</strong> 这些都是简写的,完全可以用[]和{}代替,在(?:)(?=)(?!)(?&lt;=)(?&lt;!)(?i)(*?)(+?)这种特殊组合情况下除外</p><p>初学者可以忽略<strong>?, *, +, \d, \w</strong>一些简写标示符，学会了基础使用再按表自己去等价替换</p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><blockquote><p>字符串;tel:086-0666-88810009999<br>原始正则：”^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$”<br>速记理解：开始 “tel:普通文本”[0-9数字]{1至3位}”-普通文本”[0数字][0-9数字]{2至3位}”-普通文本”[0-9数字]{8至11位} 结束”<br>等价简写后正则写法：”^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$” ，简写语法不是所有语言都支持。</p></blockquote><h4 id="正则表达式应用——实例应用"><a href="#正则表达式应用——实例应用" class="headerlink" title="正则表达式应用——实例应用"></a>正则表达式应用——实例应用</h4><ol><li><p>验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_ [0-9]”组成,并且第一个字必须为字母6~16位；</p></li><li><p>验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；</p></li><li><p>验证手机号码：”^1[3|4|5|7|8][0-9]{9}$”；</p></li><li><p>验证身份证号（15位）：”\d{14}[[0-9],0-9xX]”，（18位）：”\d{17}(\d|X|x)”；</p></li><li><p>验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$”)；</p></li><li><p>只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”)；</p></li><li><p>整数或者小数：^[0-9]+([.][0-9]+){0,1}$</p></li><li><p>只能输入数字：”^[0-9]*$”。</p></li><li><p>只能输入n位的数字：”^\d{n}$”。</p></li><li><p>只能输入至少n位的数字：”^\d{n,}$”。</p></li><li><p>只能输入m~n位的数字：”^\d{m,n}$”。</p></li><li><p>只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</p></li><li><p>只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</p></li><li><p>只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</p></li><li><p>只能输入非零的正整数：”^+?[1-9][0-9]*$”。</p></li><li><p>只能输入非零的负整数：”^-[1-9][0-9]*$”。</p></li><li><p>只能输入长度为3的字符：”^.{3}$”。</p></li><li><p>只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</p></li><li><p>只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</p></li><li><p>只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</p></li><li><p>验证是否含有^%&amp;’,;=?$\”等字符：”[%&amp;’,;=?$\^]+”。</p></li><li><p>只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。</p></li><li><p>验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</p></li><li><p>验证一年的12个月:”^(0?[1-9]|1[0-2])$”正确格式为:”01”~”09”和”10”~”12”。</p></li><li><p>验证一个月的31天:”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”~”09”、”10”~”29”和“30”~“31”。</p></li><li><p>获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?<br>评注：可用来匹配大多数年月日信息。</p></li><li><p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p></li><li><p>匹配空白行的正则表达式：\n\s*\r<br>评注：可以用来删除空白行</p></li><li><p>匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/&gt;|&lt;.</em>? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p></li><li><p>匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p></li><li><p>匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p></li><li><p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用</p></li><li><p>匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10 000 开始</p></li><li><p>匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国邮政编码为6位数字</p></li><li><p>匹配ip地址：([1-9]{1,3}.){3}[1-9]。<br>评注：提取ip地址时有用</p></li></ol><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h5 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h5><p>第一个常用的匹配方法——match()，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。<br>match()方法是从目标字符串的开头位置开始匹配，仅限于开头位置，匹配成功则返回match对象，否则返回None。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">content = &apos;Hello 123 4567 World_This is a Regex Demo&apos;</span><br><span class="line">print(len(content))</span><br><span class="line">result = re.match(&apos;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">41</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 25), match=&apos;Hello 123 4567 World_This&apos;&gt;</span><br><span class="line">Hello 123 4567 World_This</span><br><span class="line">(0, 25)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;</span><br></pre></td></tr></table></figure><p>开头的^是匹配字符串的开头，也就是以Hello开头；然后\s匹配空白字符，用来匹配目标字符串的空格；\d匹配数字，3个\d匹配123；然后再写1个\s匹配空格；后面还有4567，我们其实可以依然用4个\d来匹配，但是这么写比较烦琐，所以后面可以跟{4}以代表匹配前面的规则4次，也就是匹配4个数字；然后后面再紧接1个空白字符，最后\w{10}匹配10个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。</p><p>而在match()方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。</p><p>打印输出结果，可以看到结果是SRE_Match对象，这证明成功匹配。该对象有两个方法：group()方法可以输出匹配到的内容，结果是Hello 123 4567 World_This，这恰好是正则表达式规则所匹配的内容；span()方法可以输出匹配的范围，结果是(0, 25)，这就是匹配到的结果字符串在原字符串中的位置范围</p><h6 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h6><p>刚才我们用match()方法可以得到匹配到的字符串内容，如果想从字符串中提取一部分内容，像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。</p><p>这里可以使用()括号将想提取的子字符串括起来。()实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用group()方法传入分组的索引即可获取提取的结果。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^Hello\s(\d+)\sWorld&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(1))</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 19), match=&apos;Hello 1234567 World&apos;&gt;</span><br><span class="line">Hello 1234567 World</span><br><span class="line">1234567</span><br><span class="line">(0, 19)</span><br></pre></td></tr></table></figure></p><p>成功得到了1234567。这里用的是group(1)，它与group()有所不同，后者会输出完整的匹配结果，而前者会输出第一个被()包围的匹配结果。假如正则表达式后面还有()包括的内容，那么可以依次用group(2)、group(3)等来获取</p><h6 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h6><p>刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写\s匹配，出现数字我们就用\d匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是<strong>.*</strong>（点星）。其中<strong>.</strong>（点）可以匹配任意字符（除换行符），<strong>*</strong>（星）代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符地匹配了。</p><p>接着上面的例子，改写一下正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 123 4567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^Hello.*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>将中间部分直接省略，全部用<strong>.*</strong>来代替，最后加一个结尾字符串。运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 41), match=&apos;Hello 123 4567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">Hello 123 4567 World_This is a Regex Demo</span><br><span class="line">(0, 41)</span><br></pre></td></tr></table></figure></p><p>因此，可以使用<strong>.*</strong>简化正则表达式的书写。</p><h6 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h6><p>使用上面的通用匹配<strong>.*</strong>时，可能有时候匹配到的并不是我们想要的结果。看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^He.*(\d+).*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>这里依然获取中间的数字，所以中间依然写的是(\d+)。而数字两侧由于内容比较杂乱，所以想省略来写，都写成 <strong>.*</strong>。最后，组成^He.<em>(\d+).</em>Demo$。看下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>结果是 7<br>这里就涉及一个贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，.<em>会匹配尽可能多的字符。正则表达式中.</em>后面是\d+，也就是至少一个数字，并没有指定具体多少个数字，因此，.*就尽可能匹配多的字符，这里就把123456匹配了，给\d+留下一个可满足条件的数字7，最后得到的内容就只有数字7了。</p><p>但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是<strong>.*?</strong>，多了一个?，那么它可以达到怎样的效果？实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^He.*?(\d+).*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>将第一个<strong>.*</strong>改成了<strong>.*?</strong>，转变为非贪婪匹配。运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></p><p>贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当<strong>.*?</strong>匹配到Hello后面的空白字符时，再往后的字符就是数字了，而\d+恰好可以匹配，那么这里<strong>.*?</strong>就不再进行匹配，交给\d+去匹配后面的数字。所以这样<strong>.*?</strong>匹配了尽可能少的字符，\d+的结果就是1234567了。<br>所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用<strong>.*?</strong>来代替<strong>.*</strong>，以免出现匹配结果缺失的情况。<br>但这里需要注意，如果匹配的结果在字符串结尾,<strong>.*?</strong>就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;http://weibo.com/comment/kEraCN&apos;</span><br><span class="line">result1 = re.match(&apos;http.*?comment/(.*?)&apos;, content)</span><br><span class="line">result2 = re.match(&apos;http.*?comment/(.*)&apos;, content)</span><br><span class="line">print(&apos;result1&apos;, result1.group(1))</span><br><span class="line">print(&apos;result2&apos;, result2.group(1))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 </span><br><span class="line">result2 kEraCN</span><br></pre></td></tr></table></figure></p><p><strong>.*?</strong>没有匹配到任何结果，而<strong>.*</strong>则尽量匹配多的内容，成功得到了匹配结果。</p><h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。我们用实例来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;&apos;&apos;Hello 1234567 World_This</span><br><span class="line">is a Regex Demo</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">result = re.match(&apos;^He.*?(\d+).*?Demo$&apos;, content)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2018/09/18/python/03.png" alt="图片"><br>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为None，而我们又调用了group()方法导致AttributeError。<br>是因为.匹配的是除换行符之外的任意字符，当遇到换行符时，<strong>.*?</strong>就不能匹配了，所以导致匹配失败<br>这里只需加一个修饰符re.S，即可修正这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(&apos;^He.*?(\d+).*?Demo$&apos;, content, re.S)</span><br></pre></td></tr></table></figure></p><p>这个修饰符的作用是使<strong>.</strong>匹配包括换行符在内的所有字符,运行结果：<br><img src="/2018/09/18/python/04.png" alt="图片"><br><strong>re.S</strong>在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。<br>还有一些修饰符，在必要的情况下也可以使用:如下：<br><strong>修饰符 - - - - - 描述</strong><br>re.I - - - - - - 使匹配对大小写不敏感</p><p>re.L - - - - - - 做本地化识别（locale-aware）匹配</p><p>re.M - - - - - - 多行匹配，影响^和$</p><p>re.S - - - - - - 使.匹配包括换行在内的所有字符</p><p>re.U - - - - - - 根据Unicode字符集解析字符。这个标志影响\w、\W、 \b和\B</p><p>re.X - - - - - - 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解<br>在网页匹配中，较为常用的有re.S和re.I</p><h6 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h6><p>我们知道正则表达式定义了许多匹配模式，如<strong>.</strong>匹配除换行符以外的任意字符，但是如果目标字符串里面就包含<strong>.</strong><br>这里就需要用到转义匹配了，示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;(百度)www.baidu.com&apos;</span><br><span class="line">result = re.match(&apos;\(百度\)www\.baidu\.com&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(0))</span><br></pre></td></tr></table></figure></p><p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如<strong>.</strong>就可以用<strong>.</strong>来匹配,运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 17), match=&apos;(百度)www.baidu.com&apos;&gt;</span><br><span class="line">(百度)www.baidu.com</span><br></pre></td></tr></table></figure></p><p>可以看到，这里成功匹配到了原字符串</p><h5 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h5><p>使用一个新的字符来替换目标字符串中符合匹配要求的字符<br>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的replace()方法，那就太烦琐了，这时可以借助sub()方法。示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;54aK54yr5oiR54ix5L2g&apos;</span><br><span class="line">content = re.sub(&apos;\d+&apos;, &apos;&apos;, content)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aKyroiRixLg</span><br></pre></td></tr></table></figure></p><p>只需要给第一个参数传入\d+来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串</p><h5 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h5><p>个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content1 = &apos;2016-12-15 12:00&apos;</span><br><span class="line">content2 = &apos;2016-12-17 12:55&apos;</span><br><span class="line">content3 = &apos;2016-12-22 13:21&apos;</span><br><span class="line">pattern = re.compile(&apos;\d&#123;2&#125;:\d&#123;2&#125;&apos;)</span><br><span class="line">result1 = re.sub(pattern, &apos;&apos;, content1)</span><br><span class="line">result2 = re.sub(pattern, &apos;&apos;, content2)</span><br><span class="line">result3 = re.sub(pattern, &apos;&apos;, content3)</span><br><span class="line">print(result1, result2, result3)</span><br></pre></td></tr></table></figure></p><p>例如，这里有3个日期，我们想分别将3个日期中的时间去掉，这时可以借助sub()方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助compile()方法将正则表达式编译成一个正则表达式对象，以便复用,运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-12-15  2016-12-17  2016-12-22</span><br></pre></td></tr></table></figure></p><h5 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h5><p>从目标字符串的任意位置开始匹配数据，仅匹配成功一次，如果目标字符串有多个符合要求的结果，也只能找到一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.search(pattern_obj,&apos;hahamyheiheimy&apos;)</span><br><span class="line">print(res.group(0))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my</span><br></pre></td></tr></table></figure></p><h5 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h5><p>如果想要获取匹配正则表达式的所有内容，就要借助findall()方法。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.findall(pattern_obj,&apos;hahamyheiheimy&apos;)</span><br><span class="line">print(&apos;===&apos;,res[0])</span><br><span class="line">print(&apos;===&apos;,res[1])</span><br><span class="line">for x in res:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=== my</span><br><span class="line">=== my</span><br><span class="line">my</span><br><span class="line">my</span><br></pre></td></tr></table></figure></p><h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><p>以匹配到的符合要求的字符串为分隔符，将目标字符串分隔成一个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.split(pattern_obj,&apos;hahamyheiheimyhehe&apos;)</span><br><span class="line">print(&apos;++++&apos;,res)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++ [&apos;haha&apos;, &apos;heihei&apos;, &apos;hehe&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="菜鸟教程传送-。本文参照-https-cuiqingcai-com-5530-html-。点击进入在线正则测试工具"><a href="#菜鸟教程传送-。本文参照-https-cuiqingcai-com-5530-html-。点击进入在线正则测试工具" class="headerlink" title="菜鸟教程传送 。本文参照(https://cuiqingcai.com/5530.html) 。点击进入在线正则测试工具"></a><strong><a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程传送</a> 。本文参照(<a href="https://cuiqingcai.com/5530.html" target="_blank" rel="noopener">https://cuiqingcai.com/5530.html</a>) 。<a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">点击</a>进入在线正则测试工具</strong></h4><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;正则表达式：是对字符串的内容进行匹配查询的一种操作方式，通过预先定义的一些特殊字符的组合，形成一种字符串的匹配规则。再根据这些规则来对字符串中的某一些内容进行提取或者查找&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; clas
      
    
    </summary>
    
      <category term="数据解析" scheme="http://Chen-zhanqi.github.io/categories/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="数据解析" scheme="http://Chen-zhanqi.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
