<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>展展的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chen-zq.top/"/>
  <updated>2018-12-09T10:58:16.627Z</updated>
  <id>http://chen-zq.top/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux&amp;ensp;常用命令</title>
    <link href="http://chen-zq.top/2018/12/09/linuxcmd/"/>
    <id>http://chen-zq.top/2018/12/09/linuxcmd/</id>
    <published>2018-12-09T04:59:39.000Z</published>
    <updated>2018-12-09T10:58:16.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-ensp-磁盘管理"><a href="#一-ensp-磁盘管理" class="headerlink" title="一&ensp;磁盘管理"></a><p style="color: #f8412c">一&ensp;磁盘管理</p></h4><h5 id="list命令"><a href="#list命令" class="headerlink" title="list命令"></a><p style="color: green">list命令</p></h5><p>&emsp;&emsp;就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等<br> <strong>常用参数搭配</strong><br> ls -a 列出目录所有文件，包含以.开始的隐藏文件<br> ls -A 列出除.及..的其它文件<br> ls -r 反序排列<br> ls -t 以文件修改时间排序<br> ls -S 以文件大小排序<br> ls -h 以易读大小显示<br> ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来<br><strong>实例</strong></p><ul><li>按易读方式按时间反序排序，并显示文件详细信息<br>ls -lhrt</li><li>按大小反序显示文件详细信息<br>ls -lrS<br><em>列出当前目录中所有以“t”开头的目录的详细内容<br>ls -l t</em>  </li><li>列出文件绝对路径（不包含隐藏文件）<br>ls | sed “s:^:`pwd`/:”</li><li>列出文件绝对路径（包含隐藏文件）<br>find $pwd -maxdepth 1 | xargs ls -ld</li></ul><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><p style="color: green">cd命令</p></h5><p>&emsp;&emsp;Linux cd命令用于切换当前工作目录至 dirName(目录参数)<br>&emsp;&emsp;其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)<br>&emsp;&emsp;另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。<br><strong>实例</strong></p><ul><li>跳到 /usr/bin/<br>cd /usr/bin</li><li>跳到自己的 home 目录<br>cd ~</li><li>进入上一次工作路径<br>cd -</li><li>跳到目前目录的上上两层<br>cd ../..</li></ul><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a><p style="color: green">pwd命令</p></h5><p>&emsp;&emsp;pwd命令用于显示工作目录。<br>&emsp;&emsp;执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><hr><ul><li>查看当前路径<br>pwd</li><li>查看软链接的实际路径<br>pwd -P</li></ul><h5 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a><p style="color: green">df命令</p></h5><p>&emsp;&emsp;df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。<br> <strong>常用参数搭配</strong><br> -a, –all&emsp;包含所有的具有 0 Blocks 的文件系统<br>–block-size={SIZE}&emsp;使用 {SIZE} 大小的 Blocks<br>-h, –human-readable&emsp;使用人类可读的格式(预设值是不加这个选项的…)<br>-i, –inodes&emsp;列出 inode 资讯，不列出已使用 block<br>-l, –local&emsp;限制列出的文件结构<br>-m, –megabytes&emsp;就像 –block-size=1048576<br>–no-sync &emsp;取得资讯前不 sync (预设值)<br>-P, –portability &emsp;使用 POSIX 输出格式<br>-t, –type=TYPE &emsp;限制列出文件系统的 TYPE<br>-T, –print-type &emsp;显示文件系统的形式<br>-x, –exclude-type=TYPE &emsp;限制列出文件系统不要显示 TYPE<br>-v (忽略)<br>–help 显示这个帮手并且离开<br>–version 输出版本资讯并且离开</p><h5 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a><p style="color: green">du命令</p></h5><p>&emsp;&emsp;du命令用于显示目录或文件的大小。<br>&emsp;&emsp;du会显示指定的目录或文件所占用的磁盘空间。<br><strong>常用参数搭配</strong><br>-a或-all &emsp;显示目录中个别文件的大小。<br>-b或-bytes &emsp;显示目录或文件大小时，以byte为单位。<br>-c或–total &emsp;除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args &emsp;显示指定符号连接的源文件大小。<br>-h或–human-readable &emsp;以K，M，G为单位，提高信息的可读性。<br>-H或–si &emsp;与-h参数相同，但是K，M，G是以1000为换算单位。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; &emsp;显示选项中所指定符号连接的源文件大小。<br>-s或–summarize &emsp;仅显示总计。<br>-S或–separate-dirs &emsp;显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem &emsp;以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; &emsp;在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; &emsp;略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; &emsp;超过指定层数的目录后，予以忽略。<br>–help &emsp;显示帮助。<br>–version &emsp;显示版本信息。<br><strong>实例</strong></p><ul><li>显示目录或者文件所占空间<br>du</li><li>显示指定文件所占空间<br>du filename</li><li>方便阅读的格式显示test目录所占空间情况<br>du -h test<br><img src="/2018/12/09/linuxcmd/01.png" alt=""></li></ul><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a><p style="color: green">mkdir命令</p></h5><p>&emsp;&emsp;mkdir命令用于建立名称为 dirName 之子目录<br><strong>参数说明</strong><br>-p &emsp;确保目录名称存在，不存在的就建一个。<br><strong>实例</strong></p><ul><li>在工作目录下，建立一个名为 AAA 的子目录 :<br>mkdir AAA</li><li>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）<br>mkdir &ensp;-p &ensp;BBB/Test</li></ul><h5 id="rmkdir命令"><a href="#rmkdir命令" class="headerlink" title="rmkdir命令"></a><p style="color: green">rmkdir命令</p></h5><p>&emsp;&emsp;rmdir命令删除空的目录。<br><strong>参数说明</strong><br>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。<br><strong>实例</strong></p><ul><li>将工作目录下，名为 AAA 的子目录删除 :<br>rmdir AAA</li><li>在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除。<br>rmdir &ensp;-p &ensp;BBB/Test</li></ul><h5 id="quotar命令"><a href="#quotar命令" class="headerlink" title="quotar命令"></a><p style="color: green">quotar命令</p></h5><p>&emsp;&emsp;quota命令用于显示磁盘已使用的空间与限制<br><strong>参数说明</strong><br>-g &emsp;列出群组的磁盘空间限制。<br>-q &emsp;简明列表，只列出超过限制的部分。<br>-u &emsp;列出用户的磁盘空间限制。<br>-v &emsp;显示该用户或群组，在所有挂入系统的存储设备的空间限制。<br>-V &emsp;显示版本信息。</p><h5 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a><p style="color: green">mount命令</p></h5><p>mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件<br><strong>实例</strong></p><ul><li>将 /dev/hda1 挂在 /mnt 之下<br>#&ensp;mount &ensp;/dev/hda1 &ensp;/mnt</li></ul><h5 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a><p style="color: green">tree命令</p></h5><p>&emsp;&emsp;tree命令用于以树状图列出目录的内容。<br>&emsp;&emsp;执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件</p><h4 id="二-ensp-文件管理"><a href="#二-ensp-文件管理" class="headerlink" title="二&ensp;文件管理"></a><p style="color: #f8412c">二&ensp;文件管理</p></h4><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a><p style="color: green">rm命令</p></h5><p>&emsp;&emsp;rm命令用于删除一个文件或者目录。<br><strong>参数说明</strong><br>-i &emsp;删除前逐一询问确认。<br>-f &emsp;即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r &emsp;将目录及以下之档案亦逐一删除。<br><strong>实例</strong></p><ul><li>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如<br><img src="/2018/12/09/linuxcmd/02.png" alt=""></li><li>删除当前目录下的所有文件及目录，命令行为<br>rm  -r  *</li></ul><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a><p style="color: green">mv命令</p></h5><p>&emsp;&emsp;移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。<br>&emsp;&emsp;当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中<br><strong>实例</strong></p><ul><li>将文件test.log重命名为test1.txt<br>mv &ensp;test.log &ensp;test1.txt</li><li>将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中<br>mv &ensp;llog1.txt &ensp;log2.txt &ensp;log3.txt &ensp;/test3</li><li>将文件file1改名为file2，如果file2已经存在，则询问是否覆盖<br>mv &ensp;-i &ensp;log1.txt &ensp;log2.txt</li><li>移动当前文件夹下的所有文件到上一级目录<br>mv &ensp;* &ensp;../</li></ul><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a><p style="color: green">cp命令</p></h5><p>&emsp;&emsp;cp命令主要用于复制文件或目录(或将多个源文件复制至目标目录)<br><span style="color: red">注意</span>：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！<br><strong>参数说明</strong><br>-i &ensp;在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖<br>-f &ensp;与-i相反,覆盖已经存在的目标文件而不给出提示。<br>-r &ensp;复制目录及目录内所有项目<br>-a &ensp;复制的文件与原文件时间一样<br><strong>实例</strong></p><ul><li>复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖<br>cp &ensp;-ai &ensp;a.txt &ensp;test</li><li>将当前目录”test/“下的所有文件复制到新目录”newtest”下<br>cp &ensp;–r &ensp;test/ &ensp;newtest </li><li>为a.txt建议一个链接（快捷方式）<br>cp &ensp;-s &ensp;a.txt &ensp;link_a.txt</li></ul><h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a><p style="color: green">head命令</p></h5><p>&emsp;&emsp;head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行<br><strong>常用参数</strong><br>-n &ensp;&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）<br><strong>实例</strong></p><ul><li>显示1.log文件中前20行<br>head &ensp;1.log &ensp;-n &ensp;20</li><li>显示t.log最后10行<br>head &ensp;-n &ensp;-10 &ensp;t.log</li></ul><h5 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a><p style="color: green">查找命令</p></h5><p>&emsp;&emsp;在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><ul><li>which &ensp;查看可执行文件的位置。</li><li>whereis &ensp;查看文件的位置。</li><li>locate  &ensp;配合数据库查看文件位置。</li><li>find   &ensp;实际搜寻硬盘查询文件名称。<br>which是在PATH就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li></ul><p><strong>常用参数</strong><br>-n &ensp;指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br><strong>实例</strong></p><ul><li><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令<br>which &emsp;bash<br>上面的指令执行后，输出信息如下所示:<br><img src="/2018/12/09/linuxcmd/03.png" alt=""></p></li><li><p>查看ls命令是否存在，执行哪个<br>which ls</p></li><li>查看which<br>which which</li><li>查看cd<br>which cd &ensp;（显示不存在，因为cd是内建命令，而which查找显示是PATH中的命令）</li><li>查看当前PATH配置<br>echo $PATH;&ensp;或使用env查看所有环境变量及对应值</li></ul><h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a><p style="color: green">chmod命令</p></h5><p>&emsp;&emsp;Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用<br><strong>参数说明</strong></p><ul><li>u &ensp;表示该文件的拥有者，&ensp;g &ensp;表示与该文件的拥有者属于同一个群体(group)者，&ensp;o &ensp;表示其他以外的人，&ensp;a &ensp;表示这三者皆是。</li><li>+ &ensp;表示增加权限、&ensp;- &ensp;表示取消权限、&ensp;= &ensp;表示唯一设定权限。</li><li>r &ensp;表示可读取，w &ensp;表示可写入，x &ensp;表示可执行，X &ensp;表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>-c &ensp;若该文件权限确实已经更改，才显示其更改动作<br>-f &ensp;若该文件权限无法被更改也不要显示错误讯息<br>-v &ensp;显示权限变更的详细资料<br>-R &ensp;对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help &ensp;显示辅助说明<br>–version &ensp;显示版本</li></ul><p><strong>实例</strong></p><ul><li>将文件 file1.txt 设为所有人皆可读取<br>chmod a+r file1.txt</li><li>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入<br>chmod ug+w,o-w file1.txt file2.txt</li><li>将 ex1.py 设定为只有该文件拥有者可以执行<br>chmod u+x ex1.py</li><li>将目前目录下的所有文件与子目录皆设为任何人可读取<br>chmod -R a+r *</li></ul><p><strong>此外chmod也可以用数字来表示权限如 :</strong><br>语法为：<br>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。<br>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br>chmod a=rwx file &ensp;等于 &ensp;chmod 777 file<br>chmod ug=rwx,o=x file&ensp;等于&ensp;chmod 771 file</p><h4 id="二-ensp-系统管理"><a href="#二-ensp-系统管理" class="headerlink" title="二&ensp;系统管理"></a><p style="color: #f8412c">二&ensp;系统管理</p></h4><h5 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a><p style="color: green">reboot命令</p></h5><p>&ensp;&emsp;reboot命令用于用来重新启动计算机</p><h5 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a><p style="color: green">shutdown命令</p></h5><p>&ensp;&emsp;shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机<br><strong>参数说明</strong><br>-r &ensp;关机后重新开机<br>-h &ensp;关机后停机<br>-n &ensp;不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机<br>-c &ensp;取消目前已经进行中的关机动作<br>-f &ensp;关机时，不做 fcsk 动作(检查 Linux 档系统)<br>-F &ensp;关机时，强迫进行 fsck 动作<br>time &ensp;设定关机的时间<br>message &ensp;传送给所有使用者的警告讯息<br><strong>实例</strong></p><ul><li>立即关机<br>shutdown -h now</li><li>指定5分钟后关机<br>shutdown +5 “System will shutdown after 5 minutes” //5分钟够关机并显示警告信息</li></ul><h5 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a><p style="color: green">ps命令</p></h5><p>&ensp;&emsp;ps命令用于查看系统中的进程状态，格式为“ps [参数]”<br><strong>参数说明</strong><br>-a &ensp;显示所有进程<br>-u &ensp; 用户以及其他详细信息<br>-x &ensp; 显示没有控制终端的进程<br>在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。<br>R（运行）&ensp;进程正在运行或在运行队列中等待。<br>S（中断）&ensp;进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该   状态。<br>D（不可中断）&ensp;进程不响应系统异步信号，即便用kill命令也不能将其中断。<br>Z（僵死）&ensp;进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。<br>T（停止）&ensp;进程收到停止信号后停止运行。</p><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a><p style="color: green">kill命令</p></h5><p>kill命令用于删除执行中的程序或工作。<br>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。<br><strong>实例</strong></p><ul><li>杀死进程<br>kill 12345</li><li>强制杀死进程<br>kill -KILL 123456</li><li>彻底杀死进程<br>kill -9 123456</li></ul><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a><p style="color: green">ifconfig命令</p></h5><p>&ensp;&emsp;ifconfig命令用于获取网卡配置与网络状态等信息，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-ensp-磁盘管理&quot;&gt;&lt;a href=&quot;#一-ensp-磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;一&amp;ensp;磁盘管理&quot;&gt;&lt;/a&gt;&lt;p style=&quot;color: #f8412c&quot;&gt;一&amp;ensp;磁盘管理&lt;/p&gt;&lt;/h4&gt;&lt;h5 id=
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chen-zq.top/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="http://chen-zq.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="linux" scheme="http://chen-zq.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分析&amp;ensp;爬取必胜客全球餐厅信息</title>
    <link href="http://chen-zq.top/2018/12/05/Pizzahut/"/>
    <id>http://chen-zq.top/2018/12/05/Pizzahut/</id>
    <published>2018-12-05T12:36:43.000Z</published>
    <updated>2018-12-09T05:07:08.923Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; <strong>爬过很多网站,最让猿头疼的是通过js动态加载网页数据,如果不熟悉前端js代码,对新手来说是道难题,当然,有些网站也可以通过抓包来实现。今天,浅谈分析通过js代码找到数据请求接口</strong></p><h4 id="一-ensp-爬取目标"><a href="#一-ensp-爬取目标" class="headerlink" title="一&ensp;爬取目标"></a>一&ensp;爬取目标</h4><p>&emsp;&emsp;要爬取的目标是<a href="http://www.pizzahut.com.cn/StoreList" target="_blank" rel="noopener">必胜客中国</a>。打开必胜客中国首页，进入“餐厅查询”页面。<br><br><br><img src="/2018/12/05/Pizzahut/01.png" alt="img"><br>&emsp;&emsp;要爬取的数据内容有城市、餐厅名字、餐厅地址以及餐厅联系电话。因为我看到页面中有地图，所以页面一定有餐厅地址的经纬度。因此，餐厅的经纬度也是需要爬取的数据。<br>&emsp;&emsp;至于全国有必胜客餐厅的城市列表，可以通过页面的“切换城市”获取。</p><h4 id="二-ensp-分析页面"><a href="#二-ensp-分析页面" class="headerlink" title="二&ensp;分析页面"></a>二&ensp;分析页面</h4><p>&emsp;&emsp;在编写爬虫程序之前，建议都是先对页面进行简单分析，然后指定爬取思路。而且对页面结构进行分析往往会有一些意想不到的收获。<br>&emsp;&emsp;首先，使用浏览器的开发者工具对页面结构进行简单分析。这里强烈推荐使用Chrome浏览器。亲测。<br><br><br><img src="/2018/12/05/Pizzahut/02.png" alt=""><br>&emsp;&emsp;我们在 StoreList 页面中能找到我们所需的数据。这个能确定数据提取的 Xpath 语法。<br>&emsp;&emsp;StoreList 页面的 Response 内容比较长。先不着急关闭页面，往下看看，找找看是否有其他可利用的内容。最后，找到调用获取餐厅列表信息的 JavaScript 函数代码。<br><br><br><img src="/2018/12/05/Pizzahut/03.png" alt=""><br>&emsp;&emsp;接着搜索下GetStoreList函数，看看浏览器如何获取餐厅列表信息的。<br><br><br><img src="/2018/12/05/Pizzahut/04.png" alt=""><br>&emsp;&emsp;从代码中，我们可以了解到页面使用 Ajax 方式来获取数据。页面以 POST 方式请求地址&ensp;<a href="http://www.pizzahut.com.cn/StoreList/Index。同时，请求还携带参数" target="_blank" rel="noopener">http://www.pizzahut.com.cn/StoreList/Index。同时，请求还携带参数</a> pageIndex 和 pageSize。</p><h4 id="三-ensp-爬取思路"><a href="#三-ensp-爬取思路" class="headerlink" title="三&ensp;爬取思路"></a>三&ensp;爬取思路</h4><p>&emsp;&emsp;经过一番页面结构分析之后，来指定爬取思路。首先，先获取城市信息。然后将其作为参数，构建 HTTP 请求访问必胜客服务器来获取当前城市中所有餐厅数据。<br>&emsp;&emsp;为了方便数据爬取，我将所有城市全部写入到 cities.txt 中。等要爬取数据时，我们再从文件中读取城市信息。<br>&emsp;&emsp;爬取思路看起来没有错，但是还是有个难题没有搞定。每次打开必胜客的官网，页面每次都会自动定位到当前所在的城市。如果无法破解城市定位问题，那么只能抓取一个城市数据。<br>&emsp;&emsp;于是，再次浏览首页，看看能不能找到一些可用的信息。最终，发现页面的 cookies 中有个 iplocation 字段。我将其进行 Url 解码，得到 深圳|0|0 这样的信息。<br><br><br><img src="/2018/12/05/Pizzahut/05.png" alt=""><br><img src="/2018/12/05/Pizzahut/06.png" alt=""><br>&emsp;&emsp;看到这信息，一定会有点思路。原来必胜客网站根据我们的 IP 地址来设置初始城市信息。如果能伪造出 iplocation 字段信息，那就可以随便修改城市了</p><h4 id="四-ensp-代码实现"><a href="#四-ensp-代码实现" class="headerlink" title="四&ensp;代码实现"></a>四&ensp;代码实现</h4><p>&emsp;&emsp;第一步是从文件中读取城市信息,放进一个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 全国有必胜客餐厅的城市, 我将城市放到文件中, 一共 380 个城市</span><br><span class="line">cities = []</span><br><span class="line"></span><br><span class="line">def get_cities():</span><br><span class="line">    &quot;&quot;&quot; 从文件中获取城市 &quot;&quot;&quot;</span><br><span class="line">    file_name = &apos;cities.txt&apos;</span><br><span class="line">    with open(file_name, &apos;r&apos;, encoding=&apos;UTF-8-sig&apos;) as file:</span><br><span class="line">        for line in file:</span><br><span class="line">            city = line.replace(&apos;\n&apos;, &apos;&apos;)</span><br><span class="line">            cities.append(city)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;第二步是依次遍历 cities 列表，将每个城市作为参数，构造 Cookies 的 iplocation 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count = 1</span><br><span class="line">results = &#123;&#125;</span><br><span class="line"># 依次遍历所有城市的餐厅,调用爬虫函数,并传递城市参数</span><br><span class="line">for city in cities:</span><br><span class="line">    restaurants = get_stores(city, count)</span><br><span class="line">    results[city] = restaurants</span><br><span class="line">    count += 1</span><br><span class="line">    time.sleep(2)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后，对参数进行处理，以 POST 方式携带 Cookie 去请求必胜客服务器。最后再对返回页面数据进行提取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">def get_stores(city, count):</span><br><span class="line">    &quot;&quot;&quot; 根据城市获取餐厅信息 &quot;&quot;&quot;</span><br><span class="line">    session = requests.Session()</span><br><span class="line">    # 对【城市|0|0】进行 Url 编码</span><br><span class="line">    city_urlencode = quote(city + &apos;|0|0&apos;)</span><br><span class="line">    # 用来存储首页的 cookies</span><br><span class="line">    cookies = requests.cookies.RequestsCookieJar()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;User-agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.3964.2 Safari/537.36&apos;,</span><br><span class="line">        &apos;accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</span><br><span class="line">        &apos;Host&apos;: &apos;www.pizzahut.com.cn&apos;,</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;max-age=0&apos;,</span><br><span class="line">        &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(&apos;============第&apos;, count, &apos;个城市:&apos;, city, &apos;============&apos;)</span><br><span class="line">    resp_from_index = session.get(&apos;http://www.pizzahut.com.cn/&apos;, headers=headers)</span><br><span class="line">    # print(resp_from_index.cookies)</span><br><span class="line">    # 然后将原来 cookies 的 iplocation 字段，设置自己想要抓取城市。</span><br><span class="line">    cookies.set(&apos;AlteonP&apos;, resp_from_index.cookies[&apos;AlteonP&apos;], domain=&apos;www.pizzahut.com.cn&apos;)</span><br><span class="line">    cookies.set(&apos;iplocation&apos;, city_urlencode, domain=&apos;www.pizzahut.com.cn&apos;)</span><br><span class="line">    # print(cookies)</span><br><span class="line"></span><br><span class="line">    page = 1</span><br><span class="line">    restaurants = []</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data = &#123;</span><br><span class="line">            &apos;pageIndex&apos;: page,</span><br><span class="line">            &apos;pageSize&apos;: &quot;50&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response = session.post(&apos;http://www.pizzahut.com.cn/StoreList/Index&apos;, headers=headers, data=data, cookies=cookies)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        # 获取餐厅列表所在的 div 标签</span><br><span class="line">        divs = html.xpath(&quot;//div[@class=&apos;re_RNew&apos;]&quot;)</span><br><span class="line">        temp_items = []</span><br><span class="line">        for div in divs:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            content = div.xpath(&apos;./@onclick&apos;)[0]</span><br><span class="line">            # ClickStore(&apos;22.538912,114.09803|城市广场|深南中路中信城市广场二楼|0755-25942012&apos;,&apos;GZH519&apos;)</span><br><span class="line">            # 过滤掉括号和后面的内容</span><br><span class="line">            content = content.split(&apos;(\&apos;&apos;)[1].split(&apos;)&apos;)[0].split(&apos;\&apos;,\&apos;&apos;)[0]</span><br><span class="line"></span><br><span class="line">            if len(content.split(&apos;|&apos;)) == 4:</span><br><span class="line">                item[&apos;coordinate&apos;] = content.split(&apos;|&apos;)[0]</span><br><span class="line">                item[&apos;restaurant_name&apos;] = content.split(&apos;|&apos;)[1] + &apos;餐厅&apos;</span><br><span class="line">                item[&apos;address&apos;] = content.split(&apos;|&apos;)[2]</span><br><span class="line">                item[&apos;phone&apos;] = content.split(&apos;|&apos;)[3]</span><br><span class="line">            else:</span><br><span class="line">                item[&apos;restaurant_name&apos;] = content.split(&apos;|&apos;)[0] + &apos;餐厅&apos;</span><br><span class="line">                item[&apos;address&apos;] = content.split(&apos;|&apos;)[1]</span><br><span class="line">                item[&apos;phone&apos;] = content.split(&apos;|&apos;)[2]</span><br><span class="line">            print(item)</span><br><span class="line">            temp_items.append(item)</span><br><span class="line"></span><br><span class="line">        if not temp_items:</span><br><span class="line">            break</span><br><span class="line">        restaurants += temp_items</span><br><span class="line">        page += 1</span><br><span class="line">        time.sleep(5)</span><br><span class="line">    return restaurants</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    get_cities()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;第三步是将城市以及城市所有餐厅信息等数据写到 Json 文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;results.json&apos;, &apos;w&apos;, encoding=&apos;UTF-8&apos;) as file:</span><br><span class="line">        file.write(json.dumps(results, indent=4, ensure_ascii=False))</span><br></pre></td></tr></table></figure></p><h4 id="五-ensp-爬虫结果"><a href="#五-ensp-爬虫结果" class="headerlink" title="五&ensp;爬虫结果"></a>五&ensp;爬虫结果</h4><p>&emsp;&emsp;程序运行完之后, 就会在当前目录下生成一个名为「results.json」文件<br><br><br><img src="/2018/12/05/Pizzahut/07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp; &lt;strong&gt;爬过很多网站,最让猿头疼的是通过js动态加载网页数据,如果不熟悉前端js代码,对新手来说是道难题,当然,有些网站也可以通过抓包来实现。今天,浅谈分析通过js代码找到数据请求接口&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-ensp
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chen-zq.top/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="爬虫" scheme="http://chen-zq.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据分析" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Docker简介与命令</title>
    <link href="http://chen-zq.top/2018/11/23/docker/"/>
    <id>http://chen-zq.top/2018/11/23/docker/</id>
    <published>2018-11-23T08:28:12.000Z</published>
    <updated>2018-12-05T12:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-docker简介"><a href="#一-docker简介" class="headerlink" title="一 docker简介"></a>一 docker简介</h3><p>&emsp;&emsp;<strong>Docker 属于 Linux 容器的一种封装，采用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。它是目前最流行的 Linux 容器解决方案。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行</strong></p><ul><li>更快速的交付和部署</li><li>更高效的虚拟化</li><li>更轻松的迁移和扩展</li><li>更简单的管理</li></ul><ol><li><h4 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h4></li></ol><ul><li><strong>简化程序</strong><br>&emsp;&emsp;Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成</li><li><strong>避免选择恐惧症</strong><br>&emsp;&emsp;如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署</li><li><strong>节省开支</strong><br>&emsp;&emsp;一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li></ul><ol start="2"><li><h4 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h4></li></ol><ul><li>Web 应用的自动化打包和发布，实现合作团队开发环境一致</li><li>自动化测试和持续集成、发布</li><li>在服务型环境中部署和调整数据库或其他的后台应用</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境</li></ul><ol start="3"><li><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4></li></ol><ul><li><p><strong>Docker是CS架构，主要有两个概念</strong><br>&emsp;&emsp;<strong>Docker daemon</strong>: 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互<br>&emsp;&emsp;<strong>Docker client</strong>: Docker 命令行工具，是用户使用Docker的主要方式，Docker client与Docker daemon通信并将结果返回给用户，Docker client也可以通过socket或者RESTful api访问远程的Docker daemon</p></li><li><p><strong>Docker的三个主要概念</strong><br>&emsp;&emsp;<strong>Docker image</strong>：镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载<br>&emsp;&emsp;<strong>Docker container</strong>：容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中<br>&emsp;&emsp;<strong>Docker hub/registry</strong>: 共享和管理Docker镜像，用户可以上传或者下载上面的镜像，官方地址为<a href="https://registry.hub.docker.com/，也可以搭建自己私有的Docker" target="_blank" rel="noopener">https://registry.hub.docker.com/，也可以搭建自己私有的Docker</a> registry<br>镜像就相当于打包好的版本，镜像启动之后运行在容器中，仓库就是装存储镜像的地方</p></li></ul><h3 id="二-常用命令"><a href="#二-常用命令" class="headerlink" title="二 常用命令"></a>二 常用命令</h3><ol><li><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4></li></ol><ul><li><p><strong>login / logout</strong><br>登陆到Docker Hub<br>docker login -u 用户名 -p 密码<br>登出Docker Hub<br>docker logout</p></li><li><p><strong>pull / push</strong><br><strong>从Docker Hub下载java最新版镜像</strong><br>docker pull java<br><strong>从Docker Hub下载REPOSITORY为java的所有镜像</strong><br>docker pull -a java<br><strong>上传本地镜像myapache:v1到镜像仓库中</strong><br>docker push myapache:v1</p></li></ul><ul><li><strong>search</strong><br>从Docker Hub查找镜像</li></ul><ol start="2"><li><h4 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h4></li></ol><ul><li><p><strong>run</strong><br><strong>创建一个新的容器并运行一个命令</strong><br>docker run [参数] Image [命令]</p><pre><code>-i: 以交互模式运行容器，通常与 -t 同时使用-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用-p: 端口映射，格式为：主机(宿主)端口:容器端口--name=&quot;nginx-lb&quot;: 为容器指定一个名称；-d: 后台运行容器，不加会进入容器，一般不加-m :设置容器使用内存最大值；</code></pre><p><strong>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</strong><br>docker run -it nginx:latest /bin/bash<br><strong>目录挂载到主机（宿主机）www中</strong><br>docker run -i -t -d (不加自动进入容器) –name=’lisi’ -p 80:80 -p 81:81 -v /www:/www ubuntu /bin/bash</p></li><li><p><strong>start/stop/restart</strong> 命令<br><strong>启动一个或多个已经被停止的容器</strong><br>docker start<br><strong>停止一个运行中的容器</strong><br>docker stop<br><strong>重启容器</strong><br>docker restart</p></li><li><p>kill命令<br><strong>杀掉一个运行中的容器</strong><br>docker kill</p></li><li><p><strong>pause/unpause</strong> 命令<br><strong>暂停容器中所有的进程</strong><br>docker pause<br><strong>恢复容器中所有的进程</strong><br>docker unpause</p></li><li><p><strong>create</strong> 命令<br><strong>创建一个新的容器但不启动它</strong><br>docker create</p></li><li><p><strong>exec</strong> 命令<br><strong>在运行的容器中执行命令</strong><br>docker exec<br>docker exec -i -t 容器 /bin/bash<br><strong>在一个容器内开多个终端的意思</strong></p></li></ul><ol start="3"><li><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4></li></ol><ul><li><p><strong>ps</strong><br><strong>列出容器</strong><br>docker ps [参数] 容器</p><pre><code>-a :显示所有的容器，包括未运行的-l :显示最近创建的容器-n :列出最近创建的n个容器-q :静默模式，只显示容器编号-s :显示总的文件大小</code></pre></li><li><p><strong>top</strong><br>查看容器中运行的进程信息，支持 ps 命令参数</p></li><li><p><strong>attach</strong><br>连接到正在运行中的容器</p></li><li><p><strong>events</strong><br>从服务器获取实时事件</p></li><li><p><strong>logs</strong><br>获取容器的日志</p><pre><code>-f :跟踪日志输出--since :显示某个开始时间的所有日志-t :显示时间戳--tail :仅列出最新N条容器日志</code></pre></li><li><p><strong>port</strong><br>列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p></li><li><p><strong>commit</strong><br>从容器创建一个新的镜像<br>docker commit -a ‘zhangsan’ -m ‘installed nginx and python3.6’  容器名 docker账号/镜像名</p><pre><code>-a :提交的镜像作者；-m :提交时的说明文字-p :在commit时，将容器暂停。</code></pre></li></ul><ol start="4"><li><h4 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h4></li></ol><ul><li><p><strong>images</strong><br>列出本地镜像</p><pre><code>-a：列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）--digests：显示镜像的摘要信息--no-trunc：显示完整的镜像信息-q：只显示镜像ID</code></pre></li><li><p><strong>info</strong><br>显示 Docker 系统信息，包括镜像和容器数</p></li><li><strong>version</strong><br>显示 Docker 版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-docker简介&quot;&gt;&lt;a href=&quot;#一-docker简介&quot; class=&quot;headerlink&quot; title=&quot;一 docker简介&quot;&gt;&lt;/a&gt;一 docker简介&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Docker 属于 Linux 容器
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chen-zq.top/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="docker" scheme="http://chen-zq.top/tags/docker/"/>
    
      <category term="命令" scheme="http://chen-zq.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>使用Nginx+Gunicorn+virtualenv+supervisor部署django项目</title>
    <link href="http://chen-zq.top/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/"/>
    <id>http://chen-zq.top/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/</id>
    <published>2018-11-22T11:54:18.000Z</published>
    <updated>2018-12-05T12:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前景简介"><a href="#一-前景简介" class="headerlink" title="一 前景简介"></a>一 前景简介</h3><ul><li><strong>Nginx</strong><br>&emsp;&emsp;Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现</li><li><strong>Gunicorn</strong><br>&emsp;&emsp;Gunicorn“绿色独角兽”是一个被广泛使用的高性能的Python WSGI UNIX HTTP服务器，移植自Ruby的独角兽（Unicorn ）项目,使用pre-fork worker模式，具有使用非常简单，轻量级的资源消耗，以及高性能等特点<br>&emsp;&emsp;Gunicorn 服务器作为wsgi app的容器，能够与各种Web框架兼容（flask，django等）,得益于gevent等技术，使用Gunicorn能够在基本不改变wsgi app代码的前提下，大幅度提高wsgi app的性能</li><li><strong>supervisor</strong><br>&emsp;&emsp;supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具。可以很方便的监听、启动、停止、重启一个或多个进程。用supervisor管理的进程，当一个进程意外被杀死，supervisor监听到进程死后，会自动将它重启，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。</li></ul><h3 id="二-安装gunicorn和其它模块"><a href="#二-安装gunicorn和其它模块" class="headerlink" title="二 安装gunicorn和其它模块"></a>二 安装gunicorn和其它模块</h3><ol><li><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><strong>完成宿主机与容器挂载，映射配置后，在项目容器内执行相关部署操作</strong><br>#python的高性能的WSGI HTTP服务器<br>$ <strong>pip3 install gunicorn</strong><br>#Required for both<br>$ <strong>pip3 install greenlet</strong><br>#For eventlet workers<br>$ <strong>pip3 install eventlet</strong><br>#For gevent workers<br>$ <strong>pip3 install gevent</strong><br>#安装nginx服务器<br>$ <strong>apt-get install -y nginx</strong><br>#安装apache测试命令 不需要的话不用下载<br>$ <strong>apt-get install -y apache2-utils</strong></p></li><li><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p><strong>在项目settings.py同级目录下创建gunicorn.conf.py文件</strong><br><strong>加入以下配置代码,注意项目名称与路径的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">from multiprocessing import cpu_count</span><br><span class="line"></span><br><span class="line">bind = &quot;0.0.0.0:8000&quot;</span><br><span class="line">#设置守护进程,将进程交给supervisor管理</span><br><span class="line">daemon = True </span><br><span class="line"></span><br><span class="line"># 并行工作进程数,workers是工作线程数，一般设置成：2*服务器CPU个数 + 1，这样的话，在任何时候都有一半的worker在做IO</span><br><span class="line">workers = 2*cpu_count() + 1</span><br><span class="line"></span><br><span class="line"># 指定每个工作者的线程数</span><br><span class="line">threads = 2</span><br><span class="line"></span><br><span class="line">worker_class = &quot;gevent&quot;</span><br><span class="line"></span><br><span class="line">forworded_allow_ips = &apos;*&apos;</span><br><span class="line"></span><br><span class="line">keepalive = 6</span><br><span class="line"></span><br><span class="line">timeout = 65</span><br><span class="line"></span><br><span class="line">graceful_timeout = 10</span><br><span class="line"></span><br><span class="line"># 设置最大并发量</span><br><span class="line">worker_connections = 65535</span><br><span class="line"></span><br><span class="line"># 设置进程文件目录</span><br><span class="line">pidfile = &apos;/www/DjangoPro/gunicorn.pid&apos;</span><br><span class="line"></span><br><span class="line"># 设置访问日志和错误信息日志路径</span><br><span class="line">errorlog = &apos;/www/DjangoPro/gunicorn.error.log&apos;</span><br><span class="line">accesslog = &apos;/www/DjangoPro/gunicorn.access.log&apos;</span><br><span class="line"></span><br><span class="line"># 设置日志等级 info errer</span><br><span class="line">loglevel = &apos;info&apos;</span><br><span class="line"></span><br><span class="line"># debug : 打印全部的日志(notset等同于debug)</span><br><span class="line"># info : 打印info,warning,error,critical级别的日志</span><br><span class="line"># warning : 打印warning,error,critical级别的日志</span><br><span class="line"># error : 打印error,critical级别的日志</span><br><span class="line"># critical : 打印critical级别</span><br><span class="line"></span><br><span class="line">proc_name = &apos;DjangoPro&apos;</span><br></pre></td></tr></table></figure></li><li><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><strong>输入命令根据配置文件启动项目，注意项目名</strong><br>gunicorn -c DjangoPro/gunicorn.conf.py DjangoPro.wsgi:application</p></li><li><h4 id="查看gunicorn状态"><a href="#查看gunicorn状态" class="headerlink" title="查看gunicorn状态"></a>查看gunicorn状态</h4><p>ps aux | grep gunicorn</p></li><li><h4 id="查看后台所有进程"><a href="#查看后台所有进程" class="headerlink" title="查看后台所有进程"></a>查看后台所有进程</h4><p>ps -ax</p></li><li><h4 id="强制杀死某个进程"><a href="#强制杀死某个进程" class="headerlink" title="强制杀死某个进程"></a>强制杀死某个进程</h4><p>kill -9 id号</p></li><li><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>ab -n 1000 -c 10 <a href="http://127.0.0.1:8000/json/" target="_blank" rel="noopener">http://127.0.0.1:8000/json/</a><br>#1000表示访问量，10表示并发量，http:…表示进行测试的地址</p></li></ol><h3 id="三-配置nginx"><a href="#三-配置nginx" class="headerlink" title="三 配置nginx"></a>三 配置nginx</h3><p><strong>nginx上面已经下载过，直接通过vi编辑器配置文件</strong></p><ol><li><h4 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h4># <strong>vi /etc/nginx/nginx.conf</strong>  修改为65535<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/01.png" alt=""></li><li><h4 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h4><p># <strong>vi /etc/nginx/conf.d/djangopro.conf</strong><br><strong>添加以下配置信息,注意项目路径；中文注释在终端中正好去掉</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream app_server &#123;</span><br><span class="line">        server 127.0.0.1:8002;  #与gunicorn配置中bind的地址一致</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;listen       8000;  # 该端口要开放</span><br><span class="line">        server_name  0.0.0.0;  #域名或主机地址</span><br><span class="line">        access_log  /www/MyServer/logs/host.access.log;</span><br><span class="line">        location = /favicon.ico  &#123;</span><br><span class="line">            empty_gif;</span><br><span class="line">            access_log off;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">            root   /www/MyServer/;</span><br><span class="line">            expires 30d;</span><br><span class="line">            access_log off;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_pass http://app_server;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="测试配置文件"><a href="#测试配置文件" class="headerlink" title="测试配置文件"></a>测试配置文件</h4><p>通过命令 <strong>nginx -t</strong> 检测nginx配置文件是否存在语法错误，以下说明ok<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/02.png" alt=""></p></li><li><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><p># <strong>service nginx start</strong> 右侧有ok说明启动成功，下图没截到<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/03.png" alt=""><br><strong>如果nginx启动失败，可能是独角兽在后台运行，先关闭，上面有关闭命令</strong><br><em>注意：如果想通过nginx访问django项目，需要将gunicorn端口改为8002然后重新启动独角兽</em></p></li><li><h4 id="修改nginx默认端口"><a href="#修改nginx默认端口" class="headerlink" title="修改nginx默认端口"></a>修改nginx默认端口</h4><p>#<strong>vi /etc/nginx/sites-enabled/default</strong><br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/04.png" alt="图片04"></p></li><li><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><p><strong>service nginx restart</strong><br>访问<a href="http://192.168.99.100:81/" target="_blank" rel="noopener">http://192.168.99.100:81/</a><br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/05.png" alt="图片05"></p></li></ol><h3 id="四-安装supervisor"><a href="#四-安装supervisor" class="headerlink" title="四 安装supervisor"></a>四 安装supervisor</h3><p># <strong>apt-get install -y supervisor</strong></p><ol><li><h4 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h4><p># <strong>rm /etc/supervisor/supervisord.conf</strong><br># <strong>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</strong></p></li><li><h4 id="修改默认配置文件"><a href="#修改默认配置文件" class="headerlink" title="修改默认配置文件"></a>修改默认配置文件</h4><p><strong>/tmp/supervisor.sock -&gt; /var/run/supervisor.sock</strong>  #12行<br><strong>/tmp/supervisord.log -&gt; /var/log/supervisord.log</strong>   #24行<br><strong>/tmp/supervisord.pid -&gt; /var/run/supervisord.pid</strong>   #28行<br><strong>unix:///tmp/supervisor.sock -&gt; unix:///var/run/supervisor.sock</strong>  #48行<br><strong>[include]</strong> 去掉前面的分号  #140行<br><strong>files = relative/directory/*.ini 去掉前面的分号并修改为files = /etc/supervisor/conf.d/*.conf</strong>   #141行0</p></li><li><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><p># <strong>chmod -R 777 /var/run<br># chmod -R 777 /var/log</strong></p></li><li><h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><p>&emsp;&emsp;Superviosr通过配置文件来设置被监管的程序，一般配置文件都放置在/etc/supervisor/conf.d路径下面，此处我们创建一个名为djangopro.conf的配置文件<br># <strong>vi /etc/supervisor/conf.d/djangopro.conf</strong>进入添加以下信息,注意项目路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:MyServer]</span><br><span class="line">command = gunicorn -c /www/MyServer/MyServer/gunicorn.conf.py MyServer.wsgi:application</span><br><span class="line">user = root</span><br><span class="line">autostart=true ;</span><br><span class="line">autorestart=true ;</span><br><span class="line">startretries=10 ;</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /www/MyServer/logs/robot.log</span><br><span class="line">stderr_logfile=/www/MyServer/logs/err.log</span><br></pre></td></tr></table></figure></li><li><h4 id="启动Supervisor"><a href="#启动Supervisor" class="headerlink" title="启动Supervisor"></a>启动Supervisor</h4><p>&emsp;&emsp;<strong>关闭supervisor服务，没有启动不用执行</strong><br># <strong>supervisorctl shutdown</strong><br><strong>下面命令需要在项目根目录下执行</strong><br><strong>cd /www/DjangoPro</strong> 进入django项目<br><strong>supervisord -c /etc/supervisor/supervisord.conf</strong> #启动</p></li><li><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>ps aux | grep gunicorn</strong> 查看独角兽运行信息<br><strong>ps aux | grep supervisor</strong> 查看supervisor运行信息<br><strong>kill -9 某一个gunicorn进程id</strong> 杀死某个进程<br><strong>ps -ax</strong> 查看所有进程<br><strong>结果；即便强制杀死gunicorn，supervisor依然会自动重启</strong></p></li><li><h4 id="Supervisor其它命令"><a href="#Supervisor其它命令" class="headerlink" title="Supervisor其它命令"></a>Supervisor其它命令</h4><p><strong>supervisorctl start programxxx</strong> 启动某个进程<br><strong>supervisorctl restart programxxx</strong> 重启某个进程<br><strong>supervisorctl stop groupworker</strong>: 重启所有属于名为groupworker这个分组的进程(start,restart同理)<br><strong>supervisorctl stop all</strong> 停止全部进程，注：start、restart、stop都不会载入最新的配置文件。<br><strong>supervisorctl reload</strong> 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。<br><strong>supervisorctl update</strong> 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-前景简介&quot;&gt;&lt;a href=&quot;#一-前景简介&quot; class=&quot;headerlink&quot; title=&quot;一 前景简介&quot;&gt;&lt;/a&gt;一 前景简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Nginx是一款自由
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chen-zq.top/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="docker" scheme="http://chen-zq.top/tags/docker/"/>
    
      <category term="项目" scheme="http://chen-zq.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Django发送携带随机验证码邮件 邮箱找回密码</title>
    <link href="http://chen-zq.top/2018/11/06/send-email/"/>
    <id>http://chen-zq.top/2018/11/06/send-email/</id>
    <published>2018-11-06T13:08:09.000Z</published>
    <updated>2018-12-02T01:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：</strong></p><ul><li>通过邮件来确认用户注册</li><li>后台管理人员针对用户的反馈发送邮件</li><li>通过邮箱来重置用户密码</li></ul><h3 id="电子邮件系统"><a href="#电子邮件系统" class="headerlink" title="电子邮件系统"></a>电子邮件系统</h3><h5 id="在一个因特网电子邮件系统中，通常有三个组成部分："><a href="#在一个因特网电子邮件系统中，通常有三个组成部分：" class="headerlink" title="在一个因特网电子邮件系统中，通常有三个组成部分："></a>在一个因特网电子邮件系统中，通常有三个组成部分：</h5><ul><li>用户代理（User Agent）<br>比如一些第三方客户端，如foxmail，以及常用的浏览器</li><li>邮件服务器（Mail Server）<br>比如QQ邮箱的邮箱服务器，域名为stmp.qq.com</li><li>简单邮件传输协议（SMTP）<br>在邮件服务器中互相通讯所采取的协议</li></ul><h5 id="那么，这三个组成部分是如何运行的呢？"><a href="#那么，这三个组成部分是如何运行的呢？" class="headerlink" title="那么，这三个组成部分是如何运行的呢？"></a>那么，这三个组成部分是如何运行的呢？</h5><p>假设用户A通过用户代理（QQ邮箱）向用户B（163邮箱）发出了一封电子邮件，这个过程可以描述为：</p><ul><li>用户A的用户代理通过SMTP协议登陆QQ邮箱的邮件服务器，并将要发送的内容放在了QQ邮箱的邮件服务器的属于用户A的邮箱中。</li><li>QQ邮箱的邮件服务器通过SMTP协议向163邮箱的邮件服务器发送这封电子邮件。</li><li>163邮箱的邮件服务器在收到电子邮件之后根据邮件的头部得知接收者是用户B，将邮件放到了邮件服务器中属于用户B的邮箱中。</li><li>用户B在用户代理中登录了163的邮件服务器，并通过POP3或者IMAP等“拉”协议拉取邮件服务器中自己的邮件到用户代理中查看。（若是浏览器，可以通过HTTP协议向邮件服务器传送邮件或者拉取邮件）</li></ul><h5 id="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"><a href="#为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？" class="headerlink" title="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"></a>为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？</h5><p><strong>邮件服务器在邮件的传送与拉取中有两个重要作用：</strong></p><ol><li>尽可能的保证在任何时刻维持开机状态，接受来自其他邮件服务器的邮件传输。</li><li>当邮件发送失败后，继续尝试向对方邮件服务器发送，若邮件发送失败，通知用户代理。</li></ol><h3 id="Django配置"><a href="#Django配置" class="headerlink" title="Django配置"></a>Django配置</h3><h5 id="settings配置邮件信息"><a href="#settings配置邮件信息" class="headerlink" title="settings配置邮件信息"></a>settings配置邮件信息</h5><p><img src="/2018/11/06/send-email/01.png" alt=""></p><h5 id="models定义数据库字段信息"><a href="#models定义数据库字段信息" class="headerlink" title="models定义数据库字段信息"></a>models定义数据库字段信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class EmailRecard(models.Model):</span><br><span class="line"></span><br><span class="line">    code = models.CharField(max_length=50, null=False, verbose_name=&apos;验证码&apos;)</span><br><span class="line">    email = models.EmailField(max_length=100, null=False, verbose_name=&apos;收件人邮箱&apos;)</span><br><span class="line">    # 邮件发送的时间</span><br><span class="line">    # auto_now_add 当创建对象时，自动获取当前之间进行赋值</span><br><span class="line">    send_time = models.DateTimeField(auto_now_add=True, verbose_name=&apos;发送时间&apos;)</span><br><span class="line">    # 邮件类型 register 注册    forget 找回密码</span><br><span class="line">    # choices 选项， 规定好选项，该属性值只能是选项中的某一个</span><br><span class="line">    # default 默认值</span><br><span class="line">    email_type = models.CharField(max_length=10, choices=((&apos;register&apos;, &apos;注册账号&apos;), (&apos;forget&apos;, &apos;找回密码&apos;)), default=&apos;register&apos;, verbose_name=&apos;邮件类型&apos;)</span><br><span class="line">    # 过期时间</span><br><span class="line">    expire_time = models.DateTimeField(verbose_name=&apos;过期时间&apos;)</span><br><span class="line">    # 邮件状态，邮件是否已使用</span><br><span class="line">    email_status = models.IntegerField(choices=((1, &apos;已使用&apos;), (0, &apos;未使用&apos;)), default=0, verbose_name=&apos;邮件状态&apos;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &apos;email_recard&apos;</span><br><span class="line">        # 在后台管理界面中显示名称</span><br><span class="line">        verbose_name = &apos;邮件&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><h5 id="定义email-send发送邮件文件"><a href="#定义email-send发送邮件文件" class="headerlink" title="定义email_send发送邮件文件"></a>定义email_send发送邮件文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import datetime</span><br><span class="line"># 导入发送邮件模块</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from UserProject import settings</span><br><span class="line">from .models import EmailRecard</span><br><span class="line"></span><br><span class="line">def random_code(length=16):</span><br><span class="line">    # 随机产生验证码函数</span><br><span class="line">    string = &apos;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890&apos;</span><br><span class="line">    # 随机生成验证码</span><br><span class="line">    code = &apos;&apos;.join([string[random.randint(0, len(string)-1)] for x in range(length)])</span><br><span class="line"></span><br><span class="line">    return code</span><br><span class="line"></span><br><span class="line">def mail_send(to_email, type=&apos;register&apos;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    to_email: 接收邮件的email地址</span><br><span class="line">    type: 邮件类型 register 注册邮件</span><br><span class="line">                   forget 找回密码</span><br><span class="line">    :return: True 发送成功 </span><br><span class="line">             False 发送失败</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    email_recard = EmailRecard()</span><br><span class="line">    # 验证码</span><br><span class="line">    email_recard.code = random_code()</span><br><span class="line">    email_recard.email = to_email</span><br><span class="line">    email_recard.email_type = type</span><br><span class="line">    # 过期时间  获取7天之后的时间</span><br><span class="line">    email_recard.expire_time = datetime.datetime.now() + datetime.timedelta(days=7)</span><br><span class="line"></span><br><span class="line">    if type == &apos;register&apos;:</span><br><span class="line">        message = f&apos;注册成功，点击&lt;a href=&quot;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;激活账户！&apos;</span><br><span class="line">        subject = &apos;注册测试邮件&apos;</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        # 找回密码邮件</span><br><span class="line">        message = f&apos;找回密码邮件，点击链接&lt;a href=&quot;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;修改您的密码!&apos;</span><br><span class="line">        subject = &apos;找回密码测试邮件&apos;</span><br><span class="line">        </span><br><span class="line">    try:</span><br><span class="line">        result = send_mail(subject, message, settings.EMAIL_HOST_USER, [to_email], html_message=message)</span><br><span class="line">        if result == 1:</span><br><span class="line">            # 保存数据到数据库</span><br><span class="line">            email_recard.save()</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">            </span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># 测试部分</span><br><span class="line"># if __name__ == &apos;__main__&apos;:</span><br><span class="line">#</span><br><span class="line">#     # 获取7天之后的时间</span><br><span class="line">#     print(datetime.datetime.now())</span><br><span class="line">#     print(datetime.timedelta(days=7))</span><br><span class="line">#     print(datetime.datetime.now()+ datetime.timedelta(days=7))</span><br></pre></td></tr></table></figure><h5 id="在views中导入自定义的发送邮件文件"><a href="#在views中导入自定义的发送邮件文件" class="headerlink" title="在views中导入自定义的发送邮件文件"></a>在views中导入自定义的发送邮件文件</h5><p><strong>注意路径是否跟当前文件同级</strong><br><img src="/2018/11/06/send-email/03.png" alt=""><br><strong>等表单验证完成，信息确认后，调用邮件函数，并更改数据库密码和邮件状态,最后保存，如下：</strong><br><img src="/2018/11/06/send-email/02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过邮件来确认用户注册&lt;/li&gt;
&lt;li&gt;后台管理人员针对用户的反馈发送邮件&lt;/li&gt;
&lt;li&gt;通过邮箱来重置用户密码&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="邮件&amp;Django" scheme="http://chen-zq.top/categories/%E9%82%AE%E4%BB%B6-Django/"/>
    
    
      <category term="发送邮件" scheme="http://chen-zq.top/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
      <category term="Django" scheme="http://chen-zq.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>python常用函数集</title>
    <link href="http://chen-zq.top/2018/10/23/common-function/"/>
    <id>http://chen-zq.top/2018/10/23/common-function/</id>
    <published>2018-10-23T13:53:39.000Z</published>
    <updated>2018-11-23T22:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="参数-args和-kwargs的区别"><a href="#参数-args和-kwargs的区别" class="headerlink" title="参数*args和**kwargs的区别"></a>参数*args和**kwargs的区别</h5><p>*args 不定长参数，传入函数中是一个元组<br>**kwargs 不定长关键字参数，以key=value形式传递参数，传入函数中是一个字典</p><h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5><h6 id="Strip-去除字符串两端空格-只能删除开头或是结尾的字符"><a href="#Strip-去除字符串两端空格-只能删除开头或是结尾的字符" class="headerlink" title="Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)"></a>Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;00000003210Runoob01230000000&quot;; </span><br><span class="line">print(str.strip(&apos;0&apos;))  # 去除首尾字符 0</span><br><span class="line"> </span><br><span class="line">str2 = &quot;   Runoob      &quot;;   # 去除首尾空格</span><br><span class="line">print str2.strip();</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3210Runoob0123</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure></p><h6 id="Upper-转大写"><a href="#Upper-转大写" class="headerlink" title="Upper( ) 转大写"></a>Upper( ) 转大写</h6><h6 id="Lower-转小写"><a href="#Lower-转小写" class="headerlink" title="Lower( ) 转小写"></a>Lower( ) 转小写</h6><h6 id="Find-查找子串开始位置"><a href="#Find-查找子串开始位置" class="headerlink" title="Find( )  查找子串开始位置"></a>Find( )  查找子串开始位置</h6><h6 id="Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次"><a href="#Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次" class="headerlink" title="Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次"></a>Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;this is string example....wow!!! this is really string&quot;;</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;))</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;, 3))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas is really string</span><br></pre></td></tr></table></figure><h6 id="Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串"><a href="#Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串" class="headerlink" title="Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串"></a>Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;</span><br><span class="line">print(str.split( ))</span><br><span class="line">print(str.split(&apos; &apos;, num = 1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Line1-abcdef&apos;, &apos;Line2-abc&apos;, &apos;Line4-abcd&apos;]</span><br><span class="line">[&apos;Line1-abcdef&apos;, &apos;\nLine2-abc \nLine4-abcd&apos;]</span><br></pre></td></tr></table></figure><h6 id="Join-将序列中的元素以指定的字符连接生成一个新的字符串"><a href="#Join-将序列中的元素以指定的字符连接生成一个新的字符串" class="headerlink" title="Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串"></a>Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.join(元组、列表、字典、字符串) 之后生成的只能是字符串。</span><br><span class="line">所以很多地方很多时候生成了元组、列表、字典后，可以用 join() 来转化为字符串</span><br><span class="line">list=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]</span><br><span class="line">print(&apos;&apos;.join(list))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure><h6 id="map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中"><a href="#map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中" class="headerlink" title="map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中"></a>map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><h6 id="filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中"><a href="#filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中" class="headerlink" title="filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中"></a>filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><h6 id="Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数"><a href="#Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数" class="headerlink" title="Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数"></a>Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">print(reduce(add, [1, 3, 5, 7, 9]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h6 id="math-数字函数"><a href="#math-数字函数" class="headerlink" title="math( )数字函数"></a>math( )数字函数</h6><ul><li><p>math.pow(x, y) 返回x的y次方 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.sqrt(3)</span><br><span class="line">1.7320508075688772</span><br></pre></td></tr></table></figure></li><li><p>math.ceil(x)    返回不小于x的整数     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.ceil(5.2)</span><br><span class="line">6.0</span><br></pre></td></tr></table></figure></li><li><p>math.floor(x)    返回不大于x的整数    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.floor(5.8)</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure></li><li><p>math.trunc(x)    返回x的整数部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.trunc(5.8)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>math.fmod(x, y) 返回x%y（取余）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.fmod(5,2)</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure></li></ul><h5 id="assert-断言方法"><a href="#assert-断言方法" class="headerlink" title="assert()断言方法"></a>assert()断言方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">assert(a&gt;1)</span><br><span class="line">print(&quot;断言成功，向下执行&quot;)</span><br><span class="line"></span><br><span class="line">b = 4</span><br><span class="line">assert(b&gt;7)</span><br><span class="line">print(&quot;断言失败，程序报错&quot;)</span><br></pre></td></tr></table></figure><hr><p><strong>计算1到100的和,以下两种都可以</strong></p><ul><li>sum(range(1,101)) </li><li>reduce(lambda x,y:x+y, [x for x in range(1,101)])</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;参数-args和-kwargs的区别&quot;&gt;&lt;a href=&quot;#参数-args和-kwargs的区别&quot; class=&quot;headerlink&quot; title=&quot;参数*args和**kwargs的区别&quot;&gt;&lt;/a&gt;参数*args和**kwargs的区别&lt;/h5&gt;&lt;p&gt;*arg
      
    
    </summary>
    
      <category term="随记" scheme="http://chen-zq.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CSV文件存储</title>
    <link href="http://chen-zq.top/2018/10/14/csv/"/>
    <id>http://chen-zq.top/2018/10/14/csv/</id>
    <published>2018-10-14T06:59:04.000Z</published>
    <updated>2018-12-02T02:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号或制表符。不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。它比Excel文件更加简介，XLS文本是电子表格，它包含了文本、数值、公式和格式等内容，而CSV中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰。所以，有时候用CSV来保存数据是比较方便的。本讲解Pyhon读取和写入CSV文件的过程。</strong></p><h4 id="1-写入"><a href="#1-写入" class="headerlink" title="1.写入"></a>1.写入</h4><p>首先，打开data.csv文件，然后指定打开的模式为w（即写入），获得文件句柄，随后调用csv库的writer()方法初始化写入对象，传入该句柄，然后调用writerow()方法传入每行的数据即可完成写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow([&apos;id&apos;, &apos;name&apos;, &apos;age&apos;])</span><br><span class="line">    writer.writerow([&apos;10001&apos;, &apos;Mike&apos;, 20])</span><br><span class="line">    writer.writerow([&apos;10002&apos;, &apos;Bob&apos;, 22])</span><br><span class="line">    writer.writerow([&apos;10003&apos;, &apos;Jordan&apos;, 21])</span><br></pre></td></tr></table></figure></p><p>运行结束后，会生成一个名为data.csv的文件，此时数据就成功写入了。直接以文本形式打开的话，其内容如下<br><img src="/2018/10/14/csv/02.png" alt=""><br>可以看到，写入的文本默认以逗号分隔，调用一次writerow()方法即可写入一行数据。用Excel打开的结果如下<br><img src="/2018/10/14/csv/01.png" alt=""><br>一般情况下，爬虫爬取的都是结构化数据，我们一般会用字典来表示。在csv库中也提供了字典的写入方式，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10001&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 20&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10002&apos;, &apos;name&apos;: &apos;Bob&apos;, &apos;age&apos;: 22&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10003&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 21&#125;)</span><br></pre></td></tr></table></figure></p><p>这里先定义3个字段，用fieldnames表示，然后将其传给DictWriter来初始化一个字典写入对象，接着可以调用writeheader()方法先写入头信息，然后再调用writerow()方法传入相应字典即可。最终写入的结果是完全相同的<br>另外，如果想追加写入的话，可以修改文件的打开模式，即将open()函数的第二个参数改成a，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10004&apos;, &apos;name&apos;: &apos;Durant&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>这样在上面的基础上再执行这段代码，新行会添加成功,如下：<br><img src="/2018/10/14/csv/03.png" alt=""><br>如果要写入中文内容的话，可能会遇到字符编码的问题，此时需要给open()参数指定编码格式。比如，这里再写入一行包含中文的数据，代码需要改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10005&apos;, &apos;name&apos;: &apos;王伟&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/04.png" alt=""></p><h4 id="2-读取"><a href="#2-读取" class="headerlink" title="2.读取"></a>2.读取</h4><p>我们同使用csv库来读取CSV文件。例如，将刚才写入的文件内容读取出来，相关代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;,&apos;r&apos;, encoding=&apos;utf-8&apos;) as csvfile:</span><br><span class="line">    # 调用csv模块的reader函数读文件</span><br><span class="line">    lines = csv.reader(csvfile)</span><br><span class="line">    for line in lines:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/05.png" alt=""><br>另外，如果接触过pandas的话，可以利用read_csv()方法将数据从CSV中读取出来，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas  as pd</span><br><span class="line"> </span><br><span class="line">df = pd.read_csv(&apos;data.csv&apos;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="/2018/10/14/csv/06.png" alt=""><br>在做数据分析的时候，此种方法用得比较多，也是一种比较方便地读取CSV文件的方法。<br>本文讲述了解了CSV文件的写入和读取方式。这也是一种常用的数据存储方式，需要熟练掌握</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chen-zq.top/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据存储" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy中将数据异步写入MYSQL数据库</title>
    <link href="http://chen-zq.top/2018/10/11/AsyncToSql/"/>
    <id>http://chen-zq.top/2018/10/11/AsyncToSql/</id>
    <published>2018-10-11T07:32:28.000Z</published>
    <updated>2018-12-02T01:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…"><a href="#在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…" class="headerlink" title="在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…"></a><strong>在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…</strong></h4><p><strong>在pipelines中可以自定义图片、文件下载保存路径,保存json、excel、sqlite、异步写入mysql数据库等</strong></p><ul><li>首先在settings中配置连接MYSQL的参数,如下图<br><img src="/2018/10/11/AsyncToSql/01.png" alt="图片失踪"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># 异步写入数据库</span><br><span class="line"># adbapi 专门用于异步操作数据库的模块</span><br><span class="line">from twisted.enterprise import adbapi</span><br><span class="line"># DictCursor 游标类型</span><br><span class="line">from pymysql.cursors import DictCursor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TwistedMysqlPipeline(object):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    1.链接数据，获取游标</span><br><span class="line">    2.准备sql语句，执行sql</span><br><span class="line">    3.提交操作，关闭游标，关闭数据库</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    # 在调用TwistedMysqlPipeline时，第一个调用该函数</span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line"></span><br><span class="line">        pramars = dict(</span><br><span class="line">            host=settings[&apos;MYSQL_HOST&apos;],</span><br><span class="line">            port=settings[&apos;MYSQL_PORT&apos;],</span><br><span class="line">            user=settings[&apos;MYSQL_USER&apos;],</span><br><span class="line">            password=settings[&apos;MYSQL_PASSWORD&apos;],</span><br><span class="line">            db=settings[&apos;MYSQL_DB&apos;],</span><br><span class="line">            charset=settings[&apos;MYSQL_CHARSET&apos;],</span><br><span class="line">            use_unicode=True,</span><br><span class="line">            cursorclass=DictCursor</span><br><span class="line">        )</span><br><span class="line">        # 连接池</span><br><span class="line">        # 1.使用的第三方操作mysql的包</span><br><span class="line">        # 2.链接mysql需要的参数</span><br><span class="line">        db_pool = adbapi.ConnectionPool(&apos;pymysql&apos;, **pramars)</span><br><span class="line">        # 返回当前类的对象，并且把db_pool作为参数传递到初始化函数中</span><br><span class="line">        return cls(db_pool)</span><br><span class="line"></span><br><span class="line">    def __init__(self, db_pool):</span><br><span class="line">        # 将db_pool赋值给self.db_pool属性，在process_item函数中就可以使用db_pool</span><br><span class="line">        self.db_pool = db_pool</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line"></span><br><span class="line">        # 将写入数据库的操作放入链接池中</span><br><span class="line">        # 参数1.要异步执行的操作</span><br><span class="line">        # 参数2.异步执行操作需要的参数</span><br><span class="line">        result = self.db_pool.runInteraction(self.insert_item, item)</span><br><span class="line"></span><br><span class="line">        # 给执行结果添加错误回调函数</span><br><span class="line">        result.addErrback(self.sql_faild, item)</span><br><span class="line"></span><br><span class="line">        # 交给下一个pipeline继续进行处理</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def sql_faild(self, fail, item):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param fail: 错误原因</span><br><span class="line">        :param item: 执行sql错误的数据</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(fail)</span><br><span class="line">        print(&apos;出现问题的数据&#123;&#125;&apos;.format(item))</span><br><span class="line"></span><br><span class="line">    def insert_item(self, cursor, item):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        操作数据写入的函数</span><br><span class="line">        :param cursor: 游标,自动传入</span><br><span class="line">        :param item: 要写入的数据</span><br><span class="line">        :return:</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        sql = &apos;INSERT INTO ivsky(alt,src)VALUES(%s,%s)&apos;</span><br><span class="line">        cursor.execute(sql,(item[&apos;alt&apos;], item[&apos;src&apos;]))</span><br></pre></td></tr></table></figure></li></ul><p><strong>大概步骤如下</strong></p><ol><li>在settings中配置Mysql链接需要的参数</li><li>自定义Pipeline，实现from_settings函数</li><li>from twisted.enterprise import adbapi 引入连接池模块</li><li>from pymysql import cursors 引入游标模块</li><li>在from_settings中，准备链接数据库参数，创建db_pool连接池，创建返回当前类的对象，传入db_pool</li><li>实现初始化函数,在初始化函数中,将db_pool赋值self的属性</li><li>实现process_item函数<br> 7.1 query = self.db_pool.runInteraction(执行插入数据操作的函数对象，函数需要参数)，并接受执行返回结果<br> 7.2 query.addErrback(错误回调函数，函数需要参数)，添加执行sql失败回调的函数，在回调函数中对错误数据进一步处理 </li><li>实现插入数据操作的函数，准备sql，执行sql</li><li>实现错误回调函数，在回调函数中对错误数据进一步处理 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chen-zq.top/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
      <category term="数据库" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="爬虫" scheme="http://chen-zq.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之(Terminal)创建数据库,通过代码对数据表、数据的基本操作</title>
    <link href="http://chen-zq.top/2018/09/30/PyMysql/"/>
    <id>http://chen-zq.top/2018/09/30/PyMysql/</id>
    <published>2018-09-30T07:28:34.000Z</published>
    <updated>2018-12-02T02:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"><a href="#MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本" class="headerlink" title="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"></a><em>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL<a href="https://dev.mysql.com/downloads/shell/" target="_blank" rel="noopener">官方文档</a>下载对应版本</em></h4><h2 id="一-使用终端命令创建数据库"><a href="#一-使用终端命令创建数据库" class="headerlink" title="一.使用终端命令创建数据库"></a>一.使用终端命令创建数据库</h2><ul><li>在python代码连接数据库前，先要确认是否已经创建了数据库<br>Terminal输入命令<strong>mysql -u用户 -p密码</strong>进入mysql<br><img src="/2018/09/30/PyMysql/01.png" alt="图片旅游中..."></li><li>使用<strong>create database dbname</strong>命令(create)创建数据库<br><img src="/2018/09/30/PyMysql/02.png" alt="图片旅游中..."></li><li>使用<strong>show databases</strong>命令(show)查看所有数据库<br><img src="/2018/09/30/PyMysql/03.png" alt="图片旅游中..."><br>数据库创建完成,接着通过python代码操作</li></ul><h2 id="二-数据库CRUD-增删改查-操作"><a href="#二-数据库CRUD-增删改查-操作" class="headerlink" title="二.数据库CRUD(增删改查)操作"></a>二.数据库CRUD(增删改查)操作</h2><ul><li><p>先cmd输入<strong>pip install pymysql</strong>安装pymysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pymysql  #导入pymysql</span><br><span class="line"> </span><br><span class="line">#打开数据库连接</span><br><span class="line">connect= pymysql.connect(</span><br><span class="line">host=&quot;127.0.0.1&quot;, #主机IP</span><br><span class="line">user=&quot;root&quot;, #用户</span><br><span class="line"> password=&quot;123456&quot;,#密码</span><br><span class="line"> db=&quot;test&quot;,#数据库</span><br><span class="line"> port=3307#数据库默认端口</span><br><span class="line"> )</span><br><span class="line"> #这些只是连接数据库少不了的一些参数,参数还有很多</span><br><span class="line">#使用cursor()方法获取操作游标,接下来的操作操作需要游标执行 </span><br><span class="line">cursor = connect.cursor()</span><br></pre></td></tr></table></figure></li><li><p>创建一个不存在的表/结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = &apos;CREATE TABLE if not exists dbname(id integer primary key unique, name CHAR(20) NOT NULL,age INT)&apos;</span><br><span class="line">#游标执行sql</span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert_sql = &apos;INSERT INTO dbname(name,age)VALUES (&apos;李易峰&apos;, 20)&apos;</span><br><span class="line">#游标执行insert_sql</span><br><span class="line">cursor.execute(insert_sql)</span><br></pre></td></tr></table></figure></li><li><p>查询匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有</span><br><span class="line">select_table = &quot;SELECT * from dbname&quot;</span><br><span class="line">cursor.execute(select_table)</span><br><span class="line"></span><br><span class="line"># 设置匹配条件</span><br><span class="line"># where: 指定条件</span><br><span class="line"># like：主要用于匹配数据库中的多条记录</span><br><span class="line"># a_：以a开头的记录，并且仅匹配a后一个字符的数据</span><br><span class="line"># %a%：数据中包含a的数据</span><br><span class="line"># %a：以a结尾的数据</span><br><span class="line"># a%：匹配以a开头的数据</span><br><span class="line"># 比如查询学生数据库所有以李开头的学生信息</span><br><span class="line">select_sql = &apos;SELECT * from dbname where like &quot;李%&quot;&apos;</span><br><span class="line">cursor.execute(select_sql)</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update_sql = &quot;UPDATE dbname SET age=&apos;%s&apos;&quot;%(&apos;18&apos;)</span><br><span class="line">cursor.execute(update_sql)</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete_sql = &quot;DELETE from dbname where name=&apos;李四&apos;&quot;</span><br><span class="line">cursor.execute(delete_sql)</span><br></pre></td></tr></table></figure></li><li><p>关闭数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交操作</span><br><span class="line">connect.commit()</span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"># 关闭数据库</span><br><span class="line">connect.close()</span><br></pre></td></tr></table></figure></li></ul><blockquote><blockquote><p><strong>每次操作数据库后需要提交/关闭数据库;对于我们来说对数据库最多的操作是添加与查询</strong></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMyS
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chen-zq.top/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy基于scrapy_redis部署分布式爬虫</title>
    <link href="http://chen-zq.top/2018/09/28/scrapy-redis/"/>
    <id>http://chen-zq.top/2018/09/28/scrapy-redis/</id>
    <published>2018-09-28T12:51:03.000Z</published>
    <updated>2018-12-02T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-scrapy-redis简介"><a href="#一-scrapy-redis简介" class="headerlink" title="一. scrapy-redis简介"></a>一. scrapy-redis简介</h4><p><strong>scrapy-redis是scrapy框架基于redis数据库的组件，用于scrapy项目的分布式开发和部署</strong></p><ul><li>分布式爬取<br>可以启动多个spider工程，相互之间共享单个redis的requests队列。最适合广泛的多个域名网站的内容爬取</li><li>分布式数据处理<br>爬取到的scrapy的item数据可以推入到redis队列中，这意味着你可以根据需求启动尽可能多的处理程序来共享item的队列，进行item数据持久化处理</li><li>Scrapy即插即用组件<br>Scheduler调度器 + Duplication复制 过滤器，Item Pipeline，基本spider</li></ul><h4 id="二-安装配置"><a href="#二-安装配置" class="headerlink" title="二. 安装配置"></a>二. 安装配置</h4><ol><li><strong>使用命令行工具输入pip3 install scrapy_redis下载工具包 scrapy_redis</strong><br><img src="/2018/09/28/scrapy-redis/01.png" alt=""></li><li><strong>打开爬虫项目,找到settings全局配置文件,配置scrapy项目使用的调度器及过滤器信息</strong><br><img src="/2018/09/28/scrapy-redis/02.png" alt=""></li><li><strong>上面是将配置信息配写在settings全局配置文件中，如果一个项目中有多个爬虫，想要将每个爬取数据存入不同的数据库或者其他不需要全局配置的信息，可以将配置信息写入当前爬虫文件中，如下：</strong><br><img src="/2018/09/28/scrapy-redis/09.png" alt=""></li><li><strong>修改spider爬虫文件,首先要引入一个scrapy_redis.spider文件中的一个RedisSpider类,然后把spider爬虫文件原来继承的scrapy.Spider类改为引入的RedisSpider这个类</strong><br><img src="/2018/09/28/scrapy-redis/03.png" alt=""></li><li><strong>在redis安装目录下修改redis配置文件，后缀为conf的文件，将bing 127.0.0.1 改为 bing 0.0.0.0，允许其他电脑ip连接，如下：</strong><br><img src="/2018/09/28/scrapy-redis/10.png" alt=""></li><li><strong>如果连接的有远程服务,例如MySQL,Redis等,需要将远程服务连接开启,保证在其他主机上能够成功连接,才能将数据写入主机数据库</strong><br><img src="/2018/09/28/scrapy-redis/04.png" alt=""><br><img src="/2018/09/28/scrapy-redis/06.png" alt=""></li><li><strong>启动redis服务</strong><br><img src="/2018/09/28/scrapy-redis/11.png" alt=""></li><li><strong>将主机爬虫启动起来,然后启动其他服务器爬虫，所有爬虫会处于等待状态</strong><br>输入以下命令<br><img src="/2018/09/28/scrapy-redis/08.png" alt=""></li></ol><h4 id="三-分布式逻辑分析"><a href="#三-分布式逻辑分析" class="headerlink" title="三. 分布式逻辑分析"></a>三. 分布式逻辑分析</h4><p><strong>分布式用到的代码基本就是同一套代码</strong></p><ol><li>先把项目配置为分布式</li><li>把项目拷贝到多台服务器中</li><li>把所有爬虫项目都跑起来</li><li>在主redis-cli中lpush你的网址即可</li><li>效果：所有爬虫都开始运行，并且数据不重复</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-scrapy-redis简介&quot;&gt;&lt;a href=&quot;#一-scrapy-redis简介&quot; class=&quot;headerlink&quot; title=&quot;一. scrapy-redis简介&quot;&gt;&lt;/a&gt;一. scrapy-redis简介&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;scra
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chen-zq.top/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
      <category term="爬虫" scheme="http://chen-zq.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="部署" scheme="http://chen-zq.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>scrapyd部署爬虫项目</title>
    <link href="http://chen-zq.top/2018/09/27/scrapyd-bushu/"/>
    <id>http://chen-zq.top/2018/09/27/scrapyd-bushu/</id>
    <published>2018-09-27T13:19:07.000Z</published>
    <updated>2018-12-02T01:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…"><a href="#scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…" class="headerlink" title="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…"></a><em>scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…</em></h4><hr><h2 id="一-安装-配置scrapyd"><a href="#一-安装-配置scrapyd" class="headerlink" title="一. 安装/配置scrapyd"></a>一. 安装/配置scrapyd</h2><ul><li>打开命令行工具执行<strong>pip install scrapyd</strong><br><img src="/2018/09/27/scrapyd-bushu/01.png" alt=""></li><li>输入scrapyd启动scrapyd服务<br><img src="/2018/09/27/scrapyd-bushu/02.png" alt=""></li><li>浏览器输入127.0.0.1:6800,如下图启动成功<br><img src="/2018/09/27/scrapyd-bushu/03.png" alt=""></li><li>在非C盘下创建一个scrapydTest(自定义)文件夹,此文件夹是用来部署爬虫项目;命令行工具cd进入scrapydTest文件夹;输入scrapyd执行，执行完成后会自动新建一个dbs空文件夹，用来存放爬虫项目的数据文件;这个命令行工具一直处于运行状态,以下操作打开新命令行工具<br><img src="/2018/09/27/scrapyd-bushu/04.png" alt=""></li><li>安装scrapyd-client模块。scrapyd-client模块是专门打包scrapy爬虫项目到scrapyd服务中的，进入py环境，执行命令 <strong>pip install scrapy-client</strong>，安装完成后，在python安装目录的scripts文件夹中会出现scrapyd-deploy无后缀文件，这个scrapyd-deploy无后缀文件是启动文件，在Linux系统下可以远行，在windows下是不能运行的，所以我们需要编辑一下使其在windows可以运行<br><img src="/2018/09/27/scrapyd-bushu/06.png" alt=""></li><li>新建一个scrapyd-deploy.bat文件,如上图;右键选择编辑，输入以下配置<br>@echo off<br>“C:\Users\qianzhen\Envs\scrapySpider\Scripts\python.exe” “C:\Users\qianzhen\Envs\scrapySpider\Scripts\scrapyd-deploy” %1 %2 %3 %4 %5 %6 %7 %8 %9<br><img src="/2018/09/27/scrapyd-bushu/05.png" alt=""><br><strong>注意：两个路径之间是空格，一定要使用双引号。单引号的话会错误。两个路经是自己的python路经</strong></li></ul><h2 id="二-部署-启动项目"><a href="#二-部署-启动项目" class="headerlink" title="二.部署/启动项目"></a>二.部署/启动项目</h2><ul><li>编辑器打开爬虫项目中的scrapy.cfg文件，这个文件就是给scrapyd-deploy使用的<br>将url这行代码解掉注释，并且给设置你的部署名称<br><img src="/2018/09/27/scrapyd-bushu/08.png" alt=""></li><li>再次执行scrapyd-deploy -l 启动服务，可以看到设置的名称,接下来可以开始打包了<br><img src="/2018/09/27/scrapyd-bushu/09.png" alt=""></li><li>开始打包前，执行一个命令：scrapy list ,这个命令执行成功说明可以打包了,如果没执行成功,说明还有工作没完成;以上步骤没有出错,一般不会出现问题<br><img src="/2018/09/27/scrapyd-bushu/10.png" alt=""></li><li>如果错误提示，什么远程计算机拒绝，说明你的scrapy项目有链接远程计算机，如链接数据库或者elasticsearch(搜索引擎)之类的，需要先将链接服务器启动<br>执行 scrapy list  命令返回了爬虫名称说明一切ok了，如上图,继续go…</li><li>执行打包命令： scrapyd-deploy 部署名称 -p 项目名称<br>如：scrapyd-deploy tt -p mytest<br>如下显示表示scrapy项目打包成功,scrapydTest下egg文件夹中有项目即可<br><img src="/2018/09/27/scrapyd-bushu/11.png" alt=""></li><li>网页中127.0.0.1:6800查看是否部署到服务器<br><img src="/2018/09/27/scrapyd-bushu/12.png" alt=""></li><li>最后就是通过scrapyd命令(API)接口发送请求,比如通过请求启动刚部署服务器上的爬虫项目<br>命令输入:<strong>curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=项目名称 -d spider=爬虫名称</strong><br>如: curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=mytest -d spider=tt<br><img src="/2018/09/27/scrapyd-bushu/15.png" alt=""></li><li>jobs中查看爬虫状态<br><img src="/2018/09/27/scrapyd-bushu/14.png" alt=""></li></ul><ul><li><strong>其他请求接口可通过<a href="https://scrapyd.readthedocs.io/en/stable/api.html#" target="_blank" rel="noopener">官方文档</a>查看,如下图,全英文看不懂,没关系,有谷歌..;</strong><br><img src="/2018/09/27/scrapyd-bushu/13.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…&quot;&gt;&lt;a href=&quot;#scra
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chen-zq.top/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
      <category term="部署" scheme="http://chen-zq.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>知乎点赞最高的30句金句</title>
    <link href="http://chen-zq.top/2018/07/02/zhihu/"/>
    <id>http://chen-zq.top/2018/07/02/zhihu/</id>
    <published>2018-07-02T10:56:30.000Z</published>
    <updated>2018-12-02T03:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、夜半忽梦少年事，唯梦闲人不梦君。</strong></p><p>　　——原句出自白居易《琵琶行》（夜深忽梦少年事，梦啼妆泪红阑干。）</p><p><strong>2、你这么擅长安慰他人，一定度过了很多自己安慰自己的日子吧。</strong></p><p>　　——陈亚豪</p><p><strong>3、他走时，只有星光送他。</strong></p><p>　　——《那人走时只有星光送他》</p><p><strong>4、我们回不去了。</strong></p><p>　　——《半生缘》</p><p><strong>5、梦里不知身是客，一晌贪欢。</strong></p><p>　　——李煜</p><p><strong>6、母亲老了，扶墙走路，已踏不出脚步声。</strong></p><p>　　——毛小军</p><p><strong>7、树欲静而风不止，子欲养而亲不待。</strong></p><p>　　——《孔子家语·卷二，致思第八》</p><p><strong>8、所谓父子母女一场，只不过意味着你和他的缘分，就是今生今世不断地在目送他的背影渐行渐远。你站在小路的这一端，看着他消失在小路转弯的地方。他用背影默默地告诉你，不必追。</strong></p><p>　　——龙应台</p><p><strong>9、我很孤独用英语怎么说，”I Love You”</strong></p><p>　　————周星驰</p><p><strong>10、它们生命中的绝大多数时间，都要在冰冷的海洋上独自漂流而度过。</strong></p><p>　　——BBC的纪录片里对北极熊的描述</p><p><strong>11、那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行。如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。</strong></p><p>　　——北岛《波兰来客》</p><p><strong>12、老乡，我们中国人都投降了，还有中国吗？</strong></p><p>　　——抗日英雄杨靖宇</p><p><strong>13、我经常要对别人说“很高兴见到你”，尽管我见到他们根本不高兴。</strong></p><p>　　——《麦田守望者》</p><p><strong>14、雨声潺潺，像住在溪边，宁愿天天下雨，以为你是因为下雨不来。</strong></p><p>　　——《小团圆》</p><p><strong>15、从来如此，便对吗？</strong></p><p>　　——《狂人日记》</p><p><strong>16、越过山丘，才发现无人等候。</strong></p><p>　　——《山丘》</p><p><strong>17、你不知羞耻地索取，毫无感激地接受。</strong></p><p>　　——《王尔德狱中记》</p><p><strong>18、周芷若冷笑道：“咱们从前曾有婚姻之约，我丈夫此刻却是命在垂危，加之今日我没伤你性命，旁人定然说我对你旧情犹存。若再邀你相助，天下英雄人人要骂我不知廉耻、水性杨花。”张无忌急道：“咱们只须问心无愧，旁人言语，理他作甚？”周芷若道：“倘若我问心有愧呢？”</strong></p><p>　　——《倚天屠龙记》</p><p><strong>19、秋天短到没有，你我短到不能回头。</strong></p><p>　　——《冯唐诗百首》</p><p><strong>20、你最喜欢一个人的时候，常常都是你最不了解他的时候。</strong></p><p>　　——《龙族》</p><p><strong>21、是渴望教会了我什么叫卑躬屈膝。</strong></p><p>　　——《南音》</p><p><strong>22、某天，你无端想起一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里。</strong></p><p>　　——《再见金华站》</p><p><strong>23、老来多忘事，唯不忘相思。</strong></p><p>　　——《偶作寄朗之》</p><p><strong>24、不如意事常八九，可与人言无二三。</strong></p><p>　　——《别子才司令》</p><p><strong>25、一别两宽，各生欢喜。</strong></p><p>　　——《唐朝放妻协议》</p><p><strong>26、欲买桂花同载酒，终不似，少年游。</strong></p><p>　　——《唐多令·芦叶满汀洲》</p><p><strong>27、我是一个经常笑的人，可我不是一个经常开心的人。</strong></p><p><strong>28、高考差了一分，却隔了166个人。这166个人是1900KM的距离，是1000块的机票，三小时的飞行时间，四年的思念和一生的遗憾。</strong></p><p><strong>29、保持身体健康的唯一办法，就是吃点你不想吃的，喝点你不想喝的，以及做点你不愿做的事情。</strong></p><p>　　——马克·吐温</p><p><strong>30、五岁时，妈妈告诉我，人生的关键在于快乐。上学后，人们问我长大了要做什么，我写下“快乐”。他们告诉我，我理解错了题目，我告诉他们，他们理解错了人生。</strong></p><p>　　——约翰·列侬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、夜半忽梦少年事，唯梦闲人不梦君。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　——原句出自白居易《琵琶行》（夜深忽梦少年事，梦啼妆泪红阑干。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、你这么擅长安慰他人，一定度过了很多自己安慰自己的日子吧。&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="语录&amp;生活" scheme="http://chen-zq.top/categories/%E8%AF%AD%E5%BD%95-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Scrapy框架设置随机请求头</title>
    <link href="http://chen-zq.top/2018/06/11/RandomUA/"/>
    <id>http://chen-zq.top/2018/06/11/RandomUA/</id>
    <published>2018-06-11T12:00:21.000Z</published>
    <updated>2018-12-02T02:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在settings中设置通用请求头(一般不用)<br><img src="/2018/06/11/RandomUA/02.png" alt="图片丢失..."></li><li>设置随机请求头先终端命令<strong>pip install fake_useragent</strong>下载第三方包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 导入第三方随机请求头模块包</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line"># 自定义随机请求头类</span><br><span class="line">class RandomUAMiddleware(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 创建随机请求头对象</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理请求</span><br><span class="line">        :param request: 请求对象</span><br><span class="line">        :param spider: 爬虫对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        request.headers.setdefault(b&apos;User-Agent&apos;, self.ua.random)</span><br><span class="line">        print(request)</span><br><span class="line">        # 设置代理ip</span><br><span class="line">        # request.meta[&apos;proxy&apos;] = &apos;http://xxx.xxx.xx.xx:端口&apos;</span><br></pre></td></tr></table></figure></li></ul><p><strong>最后需要在settings中更改以下配置</strong><br><img src="/2018/06/11/RandomUA/01.png" alt="图片丢失..."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在settings中设置通用请求头(一般不用)&lt;br&gt;&lt;img src=&quot;/2018/06/11/RandomUA/02.png&quot; alt=&quot;图片丢失...&quot;&gt;&lt;/li&gt;
&lt;li&gt;设置随机请求头先终端命令&lt;strong&gt;pip install fake_user
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chen-zq.top/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>时光如水 流水无言</title>
    <link href="http://chen-zq.top/2017/12/02/%E8%AF%AD%E5%BD%95/"/>
    <id>http://chen-zq.top/2017/12/02/语录/</id>
    <published>2017-12-02T09:03:58.000Z</published>
    <updated>2018-12-02T17:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>年轻的时候，我们都有一个梦想，长大以后要带着父母环游世界。</strong></p><p><strong>但是等我们真正成年或者娶妻生子了，却总是忘了和父母联系。</strong></p><p><strong>不记得他们的生日，也不关心他们的身体，即使有时候回家和他们坐在一起，也总是感觉和他们聊不到一块。</strong></p><p><strong>我们开始嫌弃他们唠叨、不爱卫生、爱贪小便宜、管得太多……想和他们保持距离。</strong></p><p><strong>成年或者是独立以后，不要说带父母去环游世界了，就连他们生病或者离开人世的时候，也许我们都没有陪他们去医院或者是留在他们的身边。</strong></p><p><strong>曾经在网上看到过一个视频，一个老母亲因为三个儿子从未回家探望过她，便把自己的三个儿子告上了法院，要求他们支付九个月的“房费”。</strong></p><p><strong>这个老母亲其实并不差钱，她之所以这么做，无非就是想提醒自己的孩子们记得常回家看看，不要忘了她。</strong></p><p><strong>生儿育女，父母要的其实并不多，他们只是希望在垂暮之年有儿女们的惦念或者是陪伴，足矣。</strong></p><p><strong>“父母在，人生尚有来处；父母去，人生只剩归途。”</strong></p><p><img src="/2017/12/02/语录/01.jpg" alt=""><br><strong>有着未来想带父母远游的心，不如先试着多给父母打几次电话。听听他们唠唠家常，讲讲自己最近的生活过得怎么样。</strong></p><p><strong>与其给未来许下陪伴的梦想，不如珍惜当下的幸福时光。</strong></p><p><strong>一味地观望与等待，只会是虚无中的精彩。朋友不等你，爱人不等你，父母不等你，孩子不等你，即使有些东西在等你，可是光阴不等你。</strong></p><p><strong>当你失去了，后悔了，还能做什么？还能去哪里呢？</strong></p><p><strong>生活中，有太多的事情是我们不能控制的。明明约定好了的事情，本来信心满满地期待着它的发生，结果路走到一半就遭遇厄运，曾经约定好的事情却难以维持下去。</strong></p><p><img src="/2017/12/02/语录/02.jpg" alt=""><br><strong>我们的岁月不长，不长，容不下慢慢地去细想。</strong></p><p><strong>时光很急，很急，不要等到一切来不及。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;年轻的时候，我们都有一个梦想，长大以后要带着父母环游世界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是等我们真正成年或者娶妻生子了，却总是忘了和父母联系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不记得他们的生日，也不关心他们的身体，即使有
      
    
    </summary>
    
      <category term="语录&amp;生活" scheme="http://chen-zq.top/categories/%E8%AF%AD%E5%BD%95-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>scrapy框架安装</title>
    <link href="http://chen-zq.top/2017/11/10/scrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://chen-zq.top/2017/11/10/scrapy框架安装/</id>
    <published>2017-11-10T11:44:11.000Z</published>
    <updated>2018-12-02T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 </strong></p><h4 id="Windows平台安装"><a href="#Windows平台安装" class="headerlink" title="Windows平台安装"></a>Windows平台安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、安装wheel</span><br><span class="line">      pip install wheel</span><br><span class="line">2、安装lxml</span><br><span class="line">是一种使用Python编写的库，可以迅速，灵活地处理XML</span><br><span class="line">      pip install lxml  备用网址：https://pypi.python.org/pypi/lxml/4.1.0</span><br><span class="line">3、安装pyopenssl</span><br><span class="line">      在视窗下，是没有预装pyOPENSSL的，而在Linux的下是已经安装好的</span><br><span class="line">      https://pypi.python.org/pypi/pyOpenSSL/17.5.0 </span><br><span class="line">4、安装Twisted</span><br><span class="line">      https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载对应版本,本地 pip install 本地文件 安装</span><br><span class="line">5、安装pywin32</span><br><span class="line">      https://github.com/mhammond/pywin32/releases 在windows下,必须安装pywin32,下载后直接双击安装</span><br><span class="line">6、安装scrapy</span><br><span class="line">      pip install scrapy</span><br></pre></td></tr></table></figure><h5 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h5><p>输入Scrapy<br>如果提示如下命令，就证明安装成功，如果失败了，请检查上述步骤有何疏漏<br><img src="/2017/11/10/scrapy框架安装/01.png" alt="图片"></p><h4 id="Linux-Ubuntu平台安装"><a href="#Linux-Ubuntu平台安装" class="headerlink" title="Linux Ubuntu平台安装"></a>Linux Ubuntu平台安装</h4><p>Linux下安装非常简单，只需要执行几条命令几个</p><h5 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python2.7 python2.7-dev</span><br></pre></td></tr></table></figure><p>下载好之后，选中该文件所在路径，执行下面的命令<br>sudo python get-pip.py</p><h5 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h5><p>由于Linux下已经预装了lxml和OPENSSL<br>如果想验证lxml，可以分别输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lxml</span><br></pre></td></tr></table></figure></p><p>出现下面的提示这证明已经安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Requirement already satisfied (use --upgrade to upgrade): lxml in /usr/lib/python2.7/dist-packages</span><br></pre></td></tr></table></figure></p><p>如果想验验openssl，则直接输入openssl即可，如果跳转到OPENSSL命令行，则安装成功<br>接下来直接安装Scrapy即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install Scrapy</span><br></pre></td></tr></table></figure></p><p>安装完毕之后，输入scrapy 验证是否安装成功<br>注意，这里的linux下不要输入Scrapy，linux下依然严格区分大小写<br>出现跟Windows结果一样则成功</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 &lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Windows平台安装&quot;&gt;&lt;a href=&quot;#Windows平台安装&quot; class=&quot;headerlink&quot; title=&quot;Windo
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chen-zq.top/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
      <category term="框架" scheme="http://chen-zq.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="安装" scheme="http://chen-zq.top/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫框架概述</title>
    <link href="http://chen-zq.top/2017/11/05/Scrapy%E6%A1%86%E6%9E%B6/"/>
    <id>http://chen-zq.top/2017/11/05/Scrapy框架/</id>
    <published>2017-11-05T09:14:31.000Z</published>
    <updated>2018-12-02T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试</strong></p><h4 id="Scrapy框架组件"><a href="#Scrapy框架组件" class="headerlink" title="Scrapy框架组件"></a>Scrapy框架组件</h4><p><img src="/2017/11/05/Scrapy框架/01.png" alt="图片"></p><ul><li><h5 id="引擎-Engine"><a href="#引擎-Engine" class="headerlink" title="引擎(Engine)"></a>引擎(Engine)</h5>用来处理整个系统的数据流, 触发事务(框架核心)</li><li><h5 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h5>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</li><li><h5 id="下载器-Downloader"><a href="#下载器-Downloader" class="headerlink" title="下载器(Downloader)"></a>下载器(Downloader)</h5>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</li><li><h5 id="爬虫-Spiders"><a href="#爬虫-Spiders" class="headerlink" title="爬虫(Spiders)"></a>爬虫(Spiders)</h5>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</li><li><h5 id="项目管道-Pipeline"><a href="#项目管道-Pipeline" class="headerlink" title="项目管道(Pipeline)"></a>项目管道(Pipeline)</h5>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li><li><h5 id="下载器中间件-Downloader-Middlewares"><a href="#下载器中间件-Downloader-Middlewares" class="headerlink" title="下载器中间件(Downloader Middlewares)"></a>下载器中间件(Downloader Middlewares)</h5>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li><li><h5 id="爬虫中间件-Spider-Middlewares"><a href="#爬虫中间件-Spider-Middlewares" class="headerlink" title="爬虫中间件(Spider Middlewares)"></a>爬虫中间件(Spider Middlewares)</h5>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</li><li><h5 id="调度中间件-Scheduler-Middewares"><a href="#调度中间件-Scheduler-Middewares" class="headerlink" title="调度中间件(Scheduler Middewares)"></a>调度中间件(Scheduler Middewares)</h5>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应</li></ul><h4 id="Scrapy运行流程"><a href="#Scrapy运行流程" class="headerlink" title="Scrapy运行流程"></a>Scrapy运行流程</h4><ul><li>引擎从调度器中取出一个链接(URL)用于接下来的抓取</li><li>引擎把URL封装成一个请求(Request)传给下载器</li><li>下载器把资源下载下来，并封装成应答包(Response)</li><li>爬虫解析Response</li><li>解析出实体（Item）,则交给实体管道进行进一步的处理</li><li>解析出的是链接（URL）,则把URL交给调度器等待抓取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;br&gt;其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chen-zq.top/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chen-zq.top/tags/scrapy/"/>
    
      <category term="框架" scheme="http://chen-zq.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>TXT文本存储</title>
    <link href="http://chen-zq.top/2017/10/14/txt/"/>
    <id>http://chen-zq.top/2017/10/14/txt/</id>
    <published>2017-10-14T06:22:14.000Z</published>
    <updated>2018-12-02T02:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件</strong></p><h3 id="1-基本实例"><a href="#1-基本实例" class="headerlink" title="1.基本实例"></a>1.基本实例</h3><p>首先，本次保存知乎上“发现”页面的“热门话题”部分,将其问题和答案统一保存成文本形式;可以用requests将网页源代码获取下来,这里使用pyquery解析库解析，接下来将提取的标题、回答者、回答保存到文本，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">url = &apos;https://www.zhihu.com/explore&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;</span><br><span class="line">&#125;</span><br><span class="line">html = requests.get(url, headers=headers).text</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(&apos;.explore-tab .feed-item&apos;).items()</span><br><span class="line">for item in items:</span><br><span class="line">    question = item.find(&apos;h2&apos;).text()</span><br><span class="line">    author = item.find(&apos;.author-link-line&apos;).text()</span><br><span class="line">    answer = pq(item.find(&apos;.content&apos;).html()).text()</span><br><span class="line">    print(question, author, answer)</span><br><span class="line">    file = open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure></p><p>主要是为了演示文件保存的方式，因此requests异常处理部分在此省去。首先，用requests提取知乎的“发现”页面，然后将热门话题的问题、回答者、答案全文提取出来，然后利用Python提供的open()方法打开一个文本文件，获取一个文件操作对象，这里赋值为file，接着利用file对象的write()方法将提取的内容写入文件，最后调用close()方法将其关闭，这样抓取的内容即可成功写入文本中了。<br>运行程序，可以发现在本地生成了一个explore.txt文件，其内容如图下所示<br><img src="/2017/10/14/txt/01.png" alt=""><br>这里open()方法的第一个参数即要保存的目标文件名称，第二个参数为a，代表以追加方式写入到文本。另外，我们还指定了文件的编码为utf-8。最后，写入完成后，还需要调用close()方法来关闭文件对象。</p><h3 id="2-打开方式"><a href="#2-打开方式" class="headerlink" title="2.打开方式"></a>2.打开方式</h3><p>在刚才的实例中，open()方法的第二个参数设置成了a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。</p><ul><li>r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</li><li>rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头。</li><li>r+：以读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。</li><li>ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写</li></ul><h3 id="3-简化写法"><a href="#3-简化写法" class="headerlink" title="3.简化写法"></a>3.简化写法</h3><ul><li>另外，文件写入还有一种简写方法，那就是使用with as语法。在with控制块结束时，文件会自动关闭，所以就不需要再调用close()方法了。这种保存方式可以简写如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>如果想保存时将原文清空，那么可以将第二个参数改写为w，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>上面便是利用Python将结果保存为TXT文件的方法，这种方法简单易用，操作高效，是一种最基本的保存数据的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chen-zq.top/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据存储" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>xpath语法与LXML库的基本使用</title>
    <link href="http://chen-zq.top/2017/09/29/xpath/"/>
    <id>http://chen-zq.top/2017/09/29/xpath/</id>
    <published>2017-09-29T12:03:43.000Z</published>
    <updated>2018-12-02T02:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XPath 是一门在 XML 文档中查找信息的语言,但其实它也可以用来查找HTML信息.它可以借助XPth强大的语法很方便的定位元素,而且现在很多浏览器都有插件让你很容易的就得到元素的XPath路径,如firefox的firebug插件…</strong></p><h3 id="一-常见数据类型"><a href="#一-常见数据类型" class="headerlink" title="一.常见数据类型"></a>一.常见数据类型</h3><ul><li>用Python发送 http/https 请求获取网上数据,从web上采集回来的数据的数据类型有很多种,主要有:</li></ul><ol><li>放在HTML里.</li><li>直接放在javascript里.</li><li>放在JSON里.</li><li>放在XML里.</li></ol><ul><li>常用来解析这些数据的方式有re/正则表达式,XPath定位,BeautifulSoup定位,json等,本文记录xpath语法的基本使用</li></ul><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二.安装"></a>二.安装</h3><ul><li><strong>使用xpath语法前需要安装第三方库LXML</strong><br>lxml第三方的HTML解析库,Xpath全称是XML Path Language，也就是XML路径语言,它是一门在XML文档中查找信息的语言,它最初是用来搜寻XML文档的。但是它同样也适用于HTML文档的搜索,xpath是通过路径表达式在HTML中选择节点</li><li>使用命令行工具<strong>pip3 install lxml</strong>安装lxml第三方库<br><img src="/2017/09/29/xpath/01.png" alt="图片吃饭去了"><br><img src="/2017/09/29/xpath/02.png" alt="图片吃饭去了"></li></ul><h3 id="三-语法使用"><a href="#三-语法使用" class="headerlink" title="三.语法使用"></a>三.语法使用</h3><ul><li>解析html源码字符串。使用“lxml.etree.HTML( )”进行解析<br><img src="/2017/09/29/xpath/03.png" alt="图片吃饭去了"></li><li><strong>选取节点,下面是最常用的路径表达式</strong><br><img src="/2017/09/29/xpath/06.png" alt="图片吃饭去了"><br><img src="/2017/09/29/xpath/07.png" alt="图片吃饭去了"></li><li>tostring()函数是将一个element tree对象转化为html字符串</li><li>fromstring()函数是将一个字符串转化为一个element tree对象</li><li>text()只能获取当前标签的文本内容，无法获取子标签的文本内容</li><li>//text()可以将标签及子标签的文本内容全部输出，包含标签之间的换行符</li><li>contains(@class, “hao123”)：查找class属性值中包含hao123的标签，一般用于class有多个值的情况</li><li><p><strong>以下面xml文档为例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">html_code=</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://www.baidu.com&quot; class=&quot;first_a&quot;&gt;百度一下&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://mail.qq.com&quot; id=&quot;second_a&quot;&gt;QQ邮箱&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;https://www.taobao.com&quot;&gt;淘宝网&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;a href=&quot;https://pypi.python.org&quot; class=&quot;first_a&quot;&gt;Python官网&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;https://pypi.python.org&quot; class=&quot;second_a&quot;&gt;Python&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;p class=&quot;one&quot;&gt;first_p_tag&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;second&quot;&gt;second_p_tag&lt;/p&gt;</span><br><span class="line">        &lt;div class=&quot;one&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;first second third&quot;&gt;11111111&lt;/p&gt;</span><br><span class="line">            &lt;p class=&quot;hao123&quot;&gt;hao123.com&lt;/p&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;我是神&lt;span&gt;zhiyou&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>查找</strong></li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> html_obj = etree.HTML(html_code)</span><br><span class="line">print(type(html_obj))</span><br><span class="line">print(html_obj)</span><br><span class="line">#查找div中的a标签</span><br><span class="line">div_a = html_obj.xpath(&apos;//div/a/text()&apos;)[0]</span><br><span class="line">print(div_a)</span><br><span class="line">second_a = html_obj.xpath(&apos;//ul/li[last()]/a[@class=&quot;second_a&quot;]/text()&apos;)[0]</span><br><span class="line">print(second_a)</span><br><span class="line">img = html_obj.xpath(&apos;//body/ul/li/a/@href&apos;)</span><br><span class="line">print(img)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;lxml.etree._Element&apos;&gt;</span><br><span class="line">&lt;Element html at 0x23f4dfeef08&gt;</span><br><span class="line">我是神</span><br><span class="line">Python</span><br><span class="line">[&apos;https://www.baidu.com&apos;, &apos;https://mail.qq.com&apos;, &apos;https://www.taobao.com&apos;, &apos;https://pypi.python.org&apos;, &apos;https://pypi.python.org&apos;]</span><br></pre></td></tr></table></figure></li><li><p>xpath拿到得都是一个个的ElementTree对象，所以如果需要查找内容的话，还需要遍历拿到数据的列表<br><strong>更多详情可以参考<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">W3school</a></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;XPath 是一门在 XML 文档中查找信息的语言,但其实它也可以用来查找HTML信息.它可以借助XPth强大的语法很方便的定位元素,而且现在很多浏览器都有插件让你很容易的就得到元素的XPath路径,如firefox的firebug插件…&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chen-zq.top/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="数据解析" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://chen-zq.top/2017/09/18/python/"/>
    <id>http://chen-zq.top/2017/09/18/python/</id>
    <published>2017-09-18T13:21:36.000Z</published>
    <updated>2018-12-02T02:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>正则表达式：是对字符串的内容进行匹配查询的一种操作方式，通过预先定义的一些特殊字符的组合，形成一种字符串的匹配规则。再根据这些规则来对字符串中的某一些内容进行提取或者查找</strong></p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的</p><ol><li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”)</li><li>可以通过正则表达式，从字符串中获取我们想要的特定部分</li></ol><h4 id="速记理解技巧"><a href="#速记理解技巧" class="headerlink" title="速记理解技巧"></a>速记理解技巧</h4><p><strong>. [ ] ^ $</strong><br>四个字符是所有语言都支持的正则表达式，所以这四个是基础的正则表达式。正则难理解因为里面有一个等价的概念，这个概念大大增加了理解难度，让很多初学者看起来会懵，如果把等价都恢复成原始写法，自己书写正则就超级简单了，就像说话一样去写你的正则了：</p><h5 id="等价："><a href="#等价：" class="headerlink" title="等价："></a>等价：</h5><p>等价是等同于的意思，表示同样的功能，用不同符号来书写</p><p><strong>?, *, +, \d, \w</strong> 都是等价字符</p><p>?  等价于匹配长度{0,1}<br>\d 等价于[0-9]<br>\D 等价于[^0-9]<br>\w 等价于[A-Za-z_0-9]<br>\W 等价于[^A-Za-z_0-9]</p><h5 id="匹配url地址示例"><a href="#匹配url地址示例" class="headerlink" title="匹配url地址示例"></a>匹配url地址示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-z]+://[^\s]*</span><br></pre></td></tr></table></figure><p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似URL的文本，那就会被提取出来。<br>正则表达式里面都是有特定的语法规则;比如以上示例：a-z代表匹配任意的小写字母，\s表示匹配任意的空白字符,*就代表匹配前面的字符任意多个。<br>对于网页来说，如果想找出网页源代码里有多少URL，用匹配URL的正则表达式去匹配即可</p><h5 id="常用运算符与表达式："><a href="#常用运算符与表达式：" class="headerlink" title="常用运算符与表达式："></a>常用运算符与表达式：</h5><p><strong> 模式 - - - - 描述 </strong></p><p>| - - - - - 或</p><p>a|b - - - - - 匹配a或b</p><p>\ - - - - - 转义(. 字符点)</p><p>[A-Z] - - - - - 26个大写字母</p><p>[a-z] - - - - - 26个小写字母</p><p>[0-9] - - - - - 0至9数字</p><p>[A-Za-z0-9] - - - - - 26个大写字母、26个小写字母和0至9数字</p><p>\w - - - - - 匹配字母、数字及下划线</p><p>\W - - - - - 匹配不是字母、数字及下划线的字符</p><p>\s - - - - - 匹配任意空白字符，等价于[\t\n\r\f]</p><p>\S - - - - - 匹配任意非空字符</p><p>\d - - - - - 匹配任意数字，等价于[0-9]</p><p>\D - - - - - 匹配任意非数字的字符</p><p>\A - - - - - 匹配字符串开头</p><p>\Z - - - - - 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</p><p>\z - - - - - 匹配字符串结尾，如果存在换行，同时还会匹配换行符</p><p>\G - - - - - 匹配最后匹配完成的位置</p><p>\n - - - - - 匹配一个换行符</p><p>\t - - - - - 匹配一个制表符</p><p>^ - - - - - 匹配一行字符串的开头</p><p>$ - - - - - 匹配一行字符串的结尾</p><p>. - - - - - 匹配任意字符,除了换行符,当re.DOTALL标记被指定时,则可以匹配包括换行符的任意字符</p><p>[…] - - - - - 用来表示一组字符，单独列出，比如[amk]匹配a、m或k，</p><p>[^…] - - - - - 不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符,不包含,默认是一个字符长度</p><p>*- - - - - 匹配0个或多个表达式</p><p>+- - - - - 匹配1个或多个表达式</p><p>? - - - - - 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</p><p>{n} - - - - - 精确匹配n个前面的表达式</p><p>{n, m} - - - - - 匹配n到m次由前面正则表达式定义的片段，匹配长度，贪婪方式</p><p>( ) - - - - - 匹配括号内的表达式，也表示一个组</p><h5 id="分割语法："><a href="#分割语法：" class="headerlink" title="分割语法："></a>分割语法：</h5><blockquote><p>[A,H,T,W] 包含A或H或T或W字母<br>[a,h,t,w] 包含a或h或t或w字母<br>[0,3,6,8] 包含0或3或6或8数字</p></blockquote><h5 id="语法与释义："><a href="#语法与释义：" class="headerlink" title="语法与释义："></a>语法与释义：</h5><blockquote><p>基础语法 “^([]{})([]{})([]{})$”</p></blockquote><p>正则字符串 = “开始([包含内容]{长度})([包含内容]{长度})([包含内容]{长度})结束”;</p><p><strong>?, *, +, \d, \w</strong> 这些都是简写的,完全可以用[]和{}代替,在(?:)(?=)(?!)(?&lt;=)(?&lt;!)(?i)(*?)(+?)这种特殊组合情况下除外</p><p>初学者可以忽略<strong>?, *, +, \d, \w</strong>一些简写标示符，学会了基础使用再按表自己去等价替换</p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><blockquote><p>字符串;tel:086-0666-88810009999<br>原始正则：”^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$”<br>速记理解：开始 “tel:普通文本”[0-9数字]{1至3位}”-普通文本”[0数字][0-9数字]{2至3位}”-普通文本”[0-9数字]{8至11位} 结束”<br>等价简写后正则写法：”^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$” ，简写语法不是所有语言都支持。</p></blockquote><h4 id="正则表达式应用——实例应用"><a href="#正则表达式应用——实例应用" class="headerlink" title="正则表达式应用——实例应用"></a>正则表达式应用——实例应用</h4><ol><li><p>验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_ [0-9]”组成,并且第一个字必须为字母6~16位；</p></li><li><p>验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；</p></li><li><p>验证手机号码：”^1[3|4|5|7|8][0-9]{9}$”；</p></li><li><p>验证身份证号（15位）：”\d{14}[[0-9],0-9xX]”，（18位）：”\d{17}(\d|X|x)”；</p></li><li><p>验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$”)；</p></li><li><p>只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”)；</p></li><li><p>整数或者小数：^[0-9]+([.][0-9]+){0,1}$</p></li><li><p>只能输入数字：”^[0-9]*$”。</p></li><li><p>只能输入n位的数字：”^\d{n}$”。</p></li><li><p>只能输入至少n位的数字：”^\d{n,}$”。</p></li><li><p>只能输入m~n位的数字：”^\d{m,n}$”。</p></li><li><p>只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</p></li><li><p>只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</p></li><li><p>只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</p></li><li><p>只能输入非零的正整数：”^+?[1-9][0-9]*$”。</p></li><li><p>只能输入非零的负整数：”^-[1-9][0-9]*$”。</p></li><li><p>只能输入长度为3的字符：”^.{3}$”。</p></li><li><p>只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</p></li><li><p>只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</p></li><li><p>只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</p></li><li><p>验证是否含有^%&amp;’,;=?$\”等字符：”[%&amp;’,;=?$\^]+”。</p></li><li><p>只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。</p></li><li><p>验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</p></li><li><p>验证一年的12个月:”^(0?[1-9]|1[0-2])$”正确格式为:”01”~”09”和”10”~”12”。</p></li><li><p>验证一个月的31天:”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”~”09”、”10”~”29”和“30”~“31”。</p></li><li><p>获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?<br>评注：可用来匹配大多数年月日信息。</p></li><li><p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p></li><li><p>匹配空白行的正则表达式：\n\s*\r<br>评注：可以用来删除空白行</p></li><li><p>匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/&gt;|&lt;.</em>? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p></li><li><p>匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p></li><li><p>匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p></li><li><p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用</p></li><li><p>匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10 000 开始</p></li><li><p>匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国邮政编码为6位数字</p></li><li><p>匹配ip地址：([1-9]{1,3}.){3}[1-9]。<br>评注：提取ip地址时有用</p></li></ol><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h5 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h5><p>第一个常用的匹配方法——match()，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。<br>match()方法是从目标字符串的开头位置开始匹配，仅限于开头位置，匹配成功则返回match对象，否则返回None。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">content = &apos;Hello 123 4567 World_This is a Regex Demo&apos;</span><br><span class="line">print(len(content))</span><br><span class="line">result = re.match(&apos;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">41</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 25), match=&apos;Hello 123 4567 World_This&apos;&gt;</span><br><span class="line">Hello 123 4567 World_This</span><br><span class="line">(0, 25)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;</span><br></pre></td></tr></table></figure><p>开头的^是匹配字符串的开头，也就是以Hello开头；然后\s匹配空白字符，用来匹配目标字符串的空格；\d匹配数字，3个\d匹配123；然后再写1个\s匹配空格；后面还有4567，我们其实可以依然用4个\d来匹配，但是这么写比较烦琐，所以后面可以跟{4}以代表匹配前面的规则4次，也就是匹配4个数字；然后后面再紧接1个空白字符，最后\w{10}匹配10个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。</p><p>而在match()方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。</p><p>打印输出结果，可以看到结果是SRE_Match对象，这证明成功匹配。该对象有两个方法：group()方法可以输出匹配到的内容，结果是Hello 123 4567 World_This，这恰好是正则表达式规则所匹配的内容；span()方法可以输出匹配的范围，结果是(0, 25)，这就是匹配到的结果字符串在原字符串中的位置范围</p><h6 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h6><p>刚才我们用match()方法可以得到匹配到的字符串内容，如果想从字符串中提取一部分内容，像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。</p><p>这里可以使用()括号将想提取的子字符串括起来。()实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用group()方法传入分组的索引即可获取提取的结果。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^Hello\s(\d+)\sWorld&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(1))</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 19), match=&apos;Hello 1234567 World&apos;&gt;</span><br><span class="line">Hello 1234567 World</span><br><span class="line">1234567</span><br><span class="line">(0, 19)</span><br></pre></td></tr></table></figure></p><p>成功得到了1234567。这里用的是group(1)，它与group()有所不同，后者会输出完整的匹配结果，而前者会输出第一个被()包围的匹配结果。假如正则表达式后面还有()包括的内容，那么可以依次用group(2)、group(3)等来获取</p><h6 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h6><p>刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写\s匹配，出现数字我们就用\d匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是<strong>.*</strong>（点星）。其中<strong>.</strong>（点）可以匹配任意字符（除换行符），<strong>*</strong>（星）代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符地匹配了。</p><p>接着上面的例子，改写一下正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 123 4567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^Hello.*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure></p><p>将中间部分直接省略，全部用<strong>.*</strong>来代替，最后加一个结尾字符串。运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 41), match=&apos;Hello 123 4567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">Hello 123 4567 World_This is a Regex Demo</span><br><span class="line">(0, 41)</span><br></pre></td></tr></table></figure></p><p>因此，可以使用<strong>.*</strong>简化正则表达式的书写。</p><h6 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h6><p>使用上面的通用匹配<strong>.*</strong>时，可能有时候匹配到的并不是我们想要的结果。看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^He.*(\d+).*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>这里依然获取中间的数字，所以中间依然写的是(\d+)。而数字两侧由于内容比较杂乱，所以想省略来写，都写成 <strong>.*</strong>。最后，组成^He.<em>(\d+).</em>Demo$。看下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>结果是 7<br>这里就涉及一个贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，.<em>会匹配尽可能多的字符。正则表达式中.</em>后面是\d+，也就是至少一个数字，并没有指定具体多少个数字，因此，.*就尽可能匹配多的字符，这里就把123456匹配了，给\d+留下一个可满足条件的数字7，最后得到的内容就只有数字7了。</p><p>但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是<strong>.*?</strong>，多了一个?，那么它可以达到怎样的效果？实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;Hello 1234567 World_This is a Regex Demo&apos;</span><br><span class="line">result = re.match(&apos;^He.*?(\d+).*Demo$&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>将第一个<strong>.*</strong>改成了<strong>.*?</strong>，转变为非贪婪匹配。运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 40), match=&apos;Hello 1234567 World_This is a Regex Demo&apos;&gt;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></p><p>贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当<strong>.*?</strong>匹配到Hello后面的空白字符时，再往后的字符就是数字了，而\d+恰好可以匹配，那么这里<strong>.*?</strong>就不再进行匹配，交给\d+去匹配后面的数字。所以这样<strong>.*?</strong>匹配了尽可能少的字符，\d+的结果就是1234567了。<br>所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用<strong>.*?</strong>来代替<strong>.*</strong>，以免出现匹配结果缺失的情况。<br>但这里需要注意，如果匹配的结果在字符串结尾,<strong>.*?</strong>就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;http://weibo.com/comment/kEraCN&apos;</span><br><span class="line">result1 = re.match(&apos;http.*?comment/(.*?)&apos;, content)</span><br><span class="line">result2 = re.match(&apos;http.*?comment/(.*)&apos;, content)</span><br><span class="line">print(&apos;result1&apos;, result1.group(1))</span><br><span class="line">print(&apos;result2&apos;, result2.group(1))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 </span><br><span class="line">result2 kEraCN</span><br></pre></td></tr></table></figure></p><p><strong>.*?</strong>没有匹配到任何结果，而<strong>.*</strong>则尽量匹配多的内容，成功得到了匹配结果。</p><h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。我们用实例来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;&apos;&apos;Hello 1234567 World_This</span><br><span class="line">is a Regex Demo</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">result = re.match(&apos;^He.*?(\d+).*?Demo$&apos;, content)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2017/09/18/python/03.png" alt="图片"><br>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为None，而我们又调用了group()方法导致AttributeError。<br>是因为.匹配的是除换行符之外的任意字符，当遇到换行符时，<strong>.*?</strong>就不能匹配了，所以导致匹配失败<br>这里只需加一个修饰符re.S，即可修正这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(&apos;^He.*?(\d+).*?Demo$&apos;, content, re.S)</span><br></pre></td></tr></table></figure></p><p>这个修饰符的作用是使<strong>.</strong>匹配包括换行符在内的所有字符,运行结果：<br><img src="/2017/09/18/python/04.png" alt="图片"><br><strong>re.S</strong>在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。<br>还有一些修饰符，在必要的情况下也可以使用:如下：<br><strong>修饰符 - - - - - 描述</strong><br>re.I - - - - - - 使匹配对大小写不敏感</p><p>re.L - - - - - - 做本地化识别（locale-aware）匹配</p><p>re.M - - - - - - 多行匹配，影响^和$</p><p>re.S - - - - - - 使.匹配包括换行在内的所有字符</p><p>re.U - - - - - - 根据Unicode字符集解析字符。这个标志影响\w、\W、 \b和\B</p><p>re.X - - - - - - 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解<br>在网页匹配中，较为常用的有re.S和re.I</p><h6 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h6><p>我们知道正则表达式定义了许多匹配模式，如<strong>.</strong>匹配除换行符以外的任意字符，但是如果目标字符串里面就包含<strong>.</strong><br>这里就需要用到转义匹配了，示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;(百度)www.baidu.com&apos;</span><br><span class="line">result = re.match(&apos;\(百度\)www\.baidu\.com&apos;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(0))</span><br></pre></td></tr></table></figure></p><p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如<strong>.</strong>就可以用<strong>.</strong>来匹配,运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;_sre.SRE_Match object; span=(0, 17), match=&apos;(百度)www.baidu.com&apos;&gt;</span><br><span class="line">(百度)www.baidu.com</span><br></pre></td></tr></table></figure></p><p>可以看到，这里成功匹配到了原字符串</p><h5 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h5><p>使用一个新的字符来替换目标字符串中符合匹配要求的字符<br>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的replace()方法，那就太烦琐了，这时可以借助sub()方法。示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content = &apos;54aK54yr5oiR54ix5L2g&apos;</span><br><span class="line">content = re.sub(&apos;\d+&apos;, &apos;&apos;, content)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aKyroiRixLg</span><br></pre></td></tr></table></figure></p><p>只需要给第一个参数传入\d+来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串</p><h5 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h5><p>个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">content1 = &apos;2016-12-15 12:00&apos;</span><br><span class="line">content2 = &apos;2016-12-17 12:55&apos;</span><br><span class="line">content3 = &apos;2016-12-22 13:21&apos;</span><br><span class="line">pattern = re.compile(&apos;\d&#123;2&#125;:\d&#123;2&#125;&apos;)</span><br><span class="line">result1 = re.sub(pattern, &apos;&apos;, content1)</span><br><span class="line">result2 = re.sub(pattern, &apos;&apos;, content2)</span><br><span class="line">result3 = re.sub(pattern, &apos;&apos;, content3)</span><br><span class="line">print(result1, result2, result3)</span><br></pre></td></tr></table></figure></p><p>例如，这里有3个日期，我们想分别将3个日期中的时间去掉，这时可以借助sub()方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助compile()方法将正则表达式编译成一个正则表达式对象，以便复用,运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-12-15  2016-12-17  2016-12-22</span><br></pre></td></tr></table></figure></p><h5 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h5><p>从目标字符串的任意位置开始匹配数据，仅匹配成功一次，如果目标字符串有多个符合要求的结果，也只能找到一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.search(pattern_obj,&apos;hahamyheiheimy&apos;)</span><br><span class="line">print(res.group(0))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my</span><br></pre></td></tr></table></figure></p><h5 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h5><p>如果想要获取匹配正则表达式的所有内容，就要借助findall()方法。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.findall(pattern_obj,&apos;hahamyheiheimy&apos;)</span><br><span class="line">print(&apos;===&apos;,res[0])</span><br><span class="line">print(&apos;===&apos;,res[1])</span><br><span class="line">for x in res:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=== my</span><br><span class="line">=== my</span><br><span class="line">my</span><br><span class="line">my</span><br></pre></td></tr></table></figure></p><h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><p>以匹配到的符合要求的字符串为分隔符，将目标字符串分隔成一个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern_obj=re.compile(&apos;my&apos;)</span><br><span class="line">res=re.split(pattern_obj,&apos;hahamyheiheimyhehe&apos;)</span><br><span class="line">print(&apos;++++&apos;,res)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++ [&apos;haha&apos;, &apos;heihei&apos;, &apos;hehe&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="菜鸟教程传送-。本文参照-https-cuiqingcai-com-5530-html-。点击进入在线正则测试工具"><a href="#菜鸟教程传送-。本文参照-https-cuiqingcai-com-5530-html-。点击进入在线正则测试工具" class="headerlink" title="菜鸟教程传送 。本文参照(https://cuiqingcai.com/5530.html) 。点击进入在线正则测试工具"></a><strong><a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程传送</a> 。本文参照(<a href="https://cuiqingcai.com/5530.html" target="_blank" rel="noopener">https://cuiqingcai.com/5530.html</a>) 。<a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">点击</a>进入在线正则测试工具</strong></h4><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;正则表达式：是对字符串的内容进行匹配查询的一种操作方式，通过预先定义的一些特殊字符的组合，形成一种字符串的匹配规则。再根据这些规则来对字符串中的某一些内容进行提取或者查找&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; clas
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chen-zq.top/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="数据解析" scheme="http://chen-zq.top/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>常见网页状态码</title>
    <link href="http://chen-zq.top/2017/08/14/status/"/>
    <id>http://chen-zq.top/2017/08/14/status/</id>
    <published>2017-08-14T06:12:24.000Z</published>
    <updated>2018-12-02T02:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></p><p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</p><p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></p><p>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2开头 （请求成功）表示成功处理了请求的状态代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。&lt;br&gt;201   （已创建）  请求成功并且服务器创建了新的资源。&lt;br&gt;202   
      
    
    </summary>
    
      <category term="网络&amp;前端" scheme="http://chen-zq.top/categories/%E7%BD%91%E7%BB%9C-%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
</feed>
