<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>展展的博客</title>
  
  <subtitle>以梦为马，明日天涯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenzqi.cn/"/>
  <updated>2019-01-05T08:13:52.000Z</updated>
  <id>http://chenzqi.cn/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BloomFilter</title>
    <link href="http://chenzqi.cn/2019/01/04/bloomfilter/"/>
    <id>http://chenzqi.cn/2019/01/04/bloomfilter/</id>
    <published>2019-01-04T12:45:48.000Z</published>
    <updated>2019-01-05T08:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-ensp-前言"><a href="#一-ensp-前言" class="headerlink" title="一&ensp;前言"></a><p style="color: #000000">一&ensp;前言</p></h4><p>&emsp;&emsp;”去重”是日常工作中会经常用到的一项技能，在爬虫领域更是常用，并且规模一般都比较大。去重需要考虑两个点：去重的数据量、去重速度。为了保持较快的去重速度，一般选择在内存中进行去重。<br><strong>对于爬取的数据去重方案</strong></p><ol><li>&emsp;使用scrapy自带的set集合去重，当程序结束set集合会被清空，再次运行会导致数据重复</li><li>&emsp;使用mysql做去重，对url地址进行MD5，Base64加密，加密之后会得到一串字符，判断字符串是否在mysql表中，如果在表示已经爬取过，如果不在，表示没有爬取,执行请求，将加密后的url地址存入表中。<span style="color:red;">缺点</span>： 但是这个方法对mysql压力过大，导致崩溃，不推荐</li><li>&emsp;使用scrapy_redis的去重策略，会将已经爬取的url地址经过编码后存入redis，并且会做数据持久化，当爬虫再次启动时，会重新加载本地的数据，对爬虫的url做去重。<span style="color:red;">缺点</span>：如果数据量较大的时候，会占用较多的内存空间</li><li>&emsp;使用布隆去重，采用多重哈希，将url地址映射到位阵列中的某个点上，空间和时间利用率更高(推荐)。布隆去重的优点和缺点:<br><strong>优点</strong><br>&emsp;&emsp;相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外，Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势<br><strong>缺点</strong><br>&emsp;&emsp;但是布隆过滤器的缺点和优点一样明显。误算率（False Positive）是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-ensp-前言&quot;&gt;&lt;a href=&quot;#一-ensp-前言&quot; class=&quot;headerlink&quot; title=&quot;一&amp;ensp;前言&quot;&gt;&lt;/a&gt;&lt;p style=&quot;color: #000000&quot;&gt;一&amp;ensp;前言&lt;/p&gt;&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;
      
    
    </summary>
    
      <category term="数据&amp;清洗" scheme="http://chenzqi.cn/categories/%E6%95%B0%E6%8D%AE-%E6%B8%85%E6%B4%97/"/>
    
    
      <category term="去重" scheme="http://chenzqi.cn/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>行业潜•规则集锦</title>
    <link href="http://chenzqi.cn/2019/01/02/qgz/"/>
    <id>http://chenzqi.cn/2019/01/02/qgz/</id>
    <published>2019-01-02T04:08:00.000Z</published>
    <updated>2019-01-02T10:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; <strong>消防员要灭火要抓牛，进药店得先蹲下在出手；土豆泥里没有土豆，一刷就散的是合成牛肉。</strong><br>&emsp;&emsp; <strong>生活是一种修行，收集各种不为人知的小秘密。隔行如隔山。就像歌德说的，经验是永久的生活老师。</strong></p><h4 id="医药系列"><a href="#医药系列" class="headerlink" title="医药系列"></a><p style="color: red; text-align: center">医药系列</p></h4><ul><li><strong>去药店买药可以蹲下买，因为没提成有效果的药基本在下面</strong><br><br></li><li><strong>住院的时候，如果医生告诉你绝对卧床。那个绝对两个字不是医生随便说的，多少个悲剧的发生就是因为患者要面子偏要坚持自己去厕所排便导致一个用力心脏停搏的</strong><br><br></li><li><strong>牙齿排列不齐首选方案是正畸，需要1~3年的时间。号称迅速美观，只需要几天就能歪牙矫正的美容冠，贻害无穷，一两年之后就会发现做了美容冠的牙都基本得拔了，这时候再想治疗花费的时间精力，遭受的痛苦比最开始做正畸的时间精力要大得多</strong><br><br></li><li><strong>一般的病，挂专家号和普通号其实没什么区别。很多专家之所以成为专家，可能是写文章比较厉害</strong><br><br></li><li><strong>不得不承认，如果你住院了，周围一群人，唯一真心希望你能活下来的只有医生，做手术不必给任何人送红包，医生100%会尽心尽力。而且即使是最贪心的医生，他也会尽力让病人活下来</strong><br><br></li><li><strong>医者仁心。医院的走廊里，除了茫然无措的患者，还总有一路小跑的医生护士们</strong><br><br><br><img src="/2019/01/02/qgz/01.jpg" alt=""></li></ul><h4 id="百科系列"><a href="#百科系列" class="headerlink" title="百科系列"></a><p style="color: red; text-align: center">百科系列</p></h4><ul><li><strong>大多数标着某著名大学教授翻译的书，大多数都是学生翻译的</strong><br><br></li><li><strong>翻译中笔译价格很低，但商务合作会高一点，而外语培训可以说是一条发财致富的捷径，盈利能力堪比金融互联网</strong><br><br></li><li><strong>IT业，系统还是不要随意升级，刚开始会有很多兼容性问题</strong><br><br></li><li><strong>“地球一小时”，根本不能省电</strong><br><br></li><li><strong>网上很多东西都可半价买，只是很多人不知道，办法就是在手机上装一个“喜购”app，每天用它去淘宝天猫买买买可以自动反现金，多的能返50%</strong><br><br></li><li><strong>警察很多都是累死的</strong><br><br></li><li><strong>对程序员的误解：很多真的不丑；有些真的没钱；有钱的都有女朋友的，还一个比一漂亮</strong><br><br><br><img src="/2019/01/02/qgz/02.jpg" alt=""></li></ul><h4 id="生活系列"><a href="#生活系列" class="headerlink" title="生活系列"></a><p style="color: red; text-align: center">生活系列</p></h4><ul><li><strong>电气工程师。行业秘密没有，不过安全常识要提醒大家。千万不要单手拔充电器，千万不要单手拔充电器，千万不要单手拔充电器！！！虽然电很常见，单它比任何东西都危险！！！</strong><br><br></li><li><strong>遇到体力更强的男性时，女生的防身术基本无用</strong><br><br></li><li><strong>导游。我想告诉你，不管你报多贵的团，都是要进购物店的</strong><br><br></li><li><strong>汽车修理店，年轻的师傅往往比老师傅更认真，且效率高</strong><br><br></li><li><strong>法官庭审上对你特别客气，你滔滔不绝他也不打断，不要窃喜，多数是你要输了，和你拍胸脯保证案子能赢的律师都是垃圾</strong><br><br></li><li><strong>消防员不只救火，还帮着追牛和抓猪</strong><br><br></li><li><strong>女生宿舍绝大部分都是有矛盾</strong><br><br></li><li><strong>某快递客服。如果快递员的派送时效慢，态度问题，或者是件损坏丢失问题。快递公司无赖或者怎样，都可以打电话到邮政管理局。半小时内快递公司绝对打电话赔礼道歉</strong><br><br><br><img src="/2019/01/02/qgz/03.jpg" alt=""></li></ul><h4 id="人情系列"><a href="#人情系列" class="headerlink" title="人情系列"></a><p style="color: red; text-align: center">人情系列</p></h4><ul><li><strong>借钱之前做一个评估，如果你都能把钱借给他，你就借，要是不行，就别借</strong><br><br></li><li><strong>朋友交往要看对方需要什么，而不是扮演弱者。靠博取同情交到的朋友，不一定真的喜欢你</strong><br><br></li><li><strong>突然换头像,换昵称可能是恋情有波动。频繁发自拍，发状态是有了喜欢的人，莫名其妙删状态是因为喜欢的人没有点赞。深夜还在发朋友圈，是喜欢的人没有</strong><br><br><br><img src="/2019/01/02/qgz/05.jpg" alt=""></li></ul><h4 id="饮食系列"><a href="#饮食系列" class="headerlink" title="饮食系列"></a><p style="color: red; text-align: center">饮食系列</p></h4><ul><li><strong>在超市买东西拿排在货架后面的，因为货物是按照生产日期排序的，保质期久的一般都在后面</strong><br><br></li><li><strong>催菜的时候时候说快点效果不好，可以试试说不要了</strong><br><br></li><li><strong>厨师。自助餐那些东西，都是上一餐剩的。还好不是吃剩的</strong><br><br><br><img src="/2019/01/02/qgz/04.jpg" alt=""></li></ul><h4 id="影视系列"><a href="#影视系列" class="headerlink" title="影视系列"></a><p style="color: red; text-align: center">影视系列</p></h4><ul><li><strong>电影行业中，除去投资方，真正的老大其实是制片人，而不是导演，制片人其实是可以炒老板的，指成熟的电影体系</strong><br><br></li><li><strong>做行业设计的，用心设计好的东西被吃zhu资料的甲方领导改来改去，最后就完成了就是被大家吐槽的“喜洋洋”风格</strong><br><br></li><li><strong>没事别总骂小编sb了……稿子又不是小编写的，是作者写的，而且小编也无权决定发哪篇稿子。(网易新闻小编含泪说道)</strong><br><br><br><img src="/2019/01/02/qgz/06.jpg" alt=""></li></ul><h4 id="销售系列"><a href="#销售系列" class="headerlink" title="销售系列"></a><p style="color: red; text-align: center">销售系列</p></h4><ul><li><strong>进了理发店，高中低三个价位的药水决定不了你发质的好坏，只能决定你被服务的态度，和Kevin老师的收入</strong><br><br></li><li><strong>某些苹果代工厂要对应聘流水线的工人测智商，选择的是智商偏低的人，而且符合条件的人不难招</strong><br><br></li><li><strong>情人节卖的玫瑰大多数是杂交月季，扑鼻香味是香水喷的……</strong><br><br></li><li><strong>家具行业，一年365天，有12场活动，一场一个月，每次都是最低价</strong><br><br><br><img src="/2019/01/02/qgz/07.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp; &lt;strong&gt;消防员要灭火要抓牛，进药店得先蹲下在出手；土豆泥里没有土豆，一刷就散的是合成牛肉。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp; &lt;strong&gt;生活是一种修行，收集各种不为人知的小秘密。隔行如隔山。就像歌德说的，经验是永久的生
      
    
    </summary>
    
      <category term="语录&amp;生活" scheme="http://chenzqi.cn/categories/%E8%AF%AD%E5%BD%95-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>生产者与消费者模式</title>
    <link href="http://chenzqi.cn/2018/12/18/%C2%96ProducerandConsumer/"/>
    <id>http://chenzqi.cn/2018/12/18/ProducerandConsumer/</id>
    <published>2018-12-18T14:31:09.000Z</published>
    <updated>2019-01-01T09:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-ensp-什么是生产者消费者模式"><a href="#一-ensp-什么是生产者消费者模式" class="headerlink" title="一&ensp;什么是生产者消费者模式"></a>一&ensp;什么是生产者消费者模式</h4><p>&emsp;&emsp;在软件开发的过程中，经常碰到这样的场景：<br>&emsp;&emsp;某些模块负责生产数据，这些数据由其他模块来负责处理（此处的模块可能是：函数、线程、进程等）。产生数据的模块称为生产者，而处理数据的模块称为消费者。在生产者与消费者之间的缓冲区称之为仓库。生产者负责往仓库运输商品，而消费者负责从仓库里取出商品，这就构成了生产者消费者模式。<br><strong>结构图如下：</strong><br><img src="/2018/12/18/ProducerandConsumer/01.png" alt=""><br>为了大家容易理解，我们举一个寄信的例子。假设你要寄一封信，大致过程如下：</p><ol><li>你把信写好——相当于生产者生产数据</li><li>你把信放入邮箱——相当于生产者把数据放入缓冲区</li><li>邮递员把信从邮箱取出，做相应处理——相当于消费者把数据取出缓冲区，处理数据</li></ol><h4 id="二-ensp-生产者消费者模式的优点"><a href="#二-ensp-生产者消费者模式的优点" class="headerlink" title="二 &ensp;生产者消费者模式的优点"></a>二 &ensp;生产者消费者模式的优点</h4><h5 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h5><p>&emsp;&emsp;假设生产者和消费者分别是两个线程。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。如果未来消费者的代码发生变化，可能会影响到生产者的代码。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。</p><blockquote><p>&emsp;&emsp;举个例子，我们去邮局投递信件，如果不使用邮箱（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须 得认识谁是邮递员，才能把信给他。这就产生了你和邮递员之间的依赖（相当于生产者和消费者的强耦合）。万一哪天邮递员 换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮箱相对来说比较固定，你依赖它的成本就比较低（相当于和缓冲区之间的弱耦合）。</p></blockquote><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p>&emsp;&emsp;由于生产者与消费者是两个独立的并发体，他们之间是用缓冲区通信的，生产者只需要往缓冲区里丢数据，就可以继续生产下一个数据，而消费者只需要从缓冲区拿数据即可，这样就不会因为彼此的处理速度而发生阻塞。</p><blockquote><p>&emsp;&emsp;继续上面的例子，如果我们不使用邮箱，就得在邮局等邮递员，直到他回来，把信件交给他，这期间我们啥事儿都不能干（也就是生产者阻塞）。或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。</p></blockquote><h5 id="支持忙闲不均"><a href="#支持忙闲不均" class="headerlink" title="支持忙闲不均"></a>支持忙闲不均</h5><p>&emsp;&emsp;当生产者制造数据快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中，慢慢处理掉。而不至于因为消费者的性能造成数据丢失或影响生产者生产。</p><blockquote><p>&emsp;&emsp;我们再拿寄信的例子，假设邮递员一次只能带走1000封信，万一碰上情人节（或是圣诞节）送贺卡，需要寄出去的信超过了1000封，这时候邮箱这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮箱中，等下次过来时再拿走。</p></blockquote><h4 id="Python中的多线程编程"><a href="#Python中的多线程编程" class="headerlink" title="Python中的多线程编程"></a>Python中的多线程编程</h4><p>&emsp;&emsp;下面我们实现一个生产者消费者模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">import random,threading,time</span><br><span class="line"></span><br><span class="line">#生产者类</span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line">    def __init__(self, name,queue):</span><br><span class="line">        threading.Thread.__init__(self, name=name)</span><br><span class="line">        self.data=queue</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(5):</span><br><span class="line">            print(&quot;%s is producing %d to the queue!&quot; % (self.getName(), i))</span><br><span class="line">            self.data.put(i)</span><br><span class="line">            time.sleep(random.randrange(10)/5)</span><br><span class="line">        print(&quot;%s finished!&quot; % self.getName())</span><br><span class="line"></span><br><span class="line">#消费者类</span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line">    def __init__(self,name,queue):</span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line">        self.data=queue</span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(5):</span><br><span class="line">            val = self.data.get()</span><br><span class="line">            print(&quot;%s is consuming. %d in the queue is consumed!&quot; % (self.getName(),val))</span><br><span class="line">            time.sleep(random.randrange(10))</span><br><span class="line">        print(&quot;%s finished!&quot; % self.getName())</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    queue = Queue()</span><br><span class="line">    producer = Producer(&apos;Producer&apos;,queue)</span><br><span class="line">    consumer = Consumer(&apos;Consumer&apos;,queue)</span><br><span class="line"></span><br><span class="line">    producer.start()</span><br><span class="line">    consumer.start()</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">    print &apos;All threads finished!&apos;</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Producer is producing 0 to the queue!</span><br><span class="line">Consumer is consuming. 0 in the queue is consumed!</span><br><span class="line">Producer is producing 1 to the queue!</span><br><span class="line">Producer is producing 2 to the queue!</span><br><span class="line">Consumer is consuming. 1 in the queue is consumed!</span><br><span class="line">Consumer is consuming. 2 in the queue is consumed!</span><br><span class="line">Producer is producing 3 to the queue!</span><br><span class="line">Producer is producing 4 to the queue!</span><br><span class="line">Producer finished!</span><br><span class="line">Consumer is consuming. 3 in the queue is consumed!</span><br><span class="line">Consumer is consuming. 4 in the queue is consumed!</span><br><span class="line">Consumer finished!</span><br><span class="line">All threads finished!</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;本例通过Python实现了一个简单的生产者消费者模型。Python中的Queue模块已经提供了对线程同步的支持，所以本文并没有涉及锁、同步、死锁等多线程问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-ensp-什么是生产者消费者模式&quot;&gt;&lt;a href=&quot;#一-ensp-什么是生产者消费者模式&quot; class=&quot;headerlink&quot; title=&quot;一&amp;ensp;什么是生产者消费者模式&quot;&gt;&lt;/a&gt;一&amp;ensp;什么是生产者消费者模式&lt;/h4&gt;&lt;p&gt;&amp;emsp;
      
    
    </summary>
    
      <category term="队列&amp;架构" scheme="http://chenzqi.cn/categories/%E9%98%9F%E5%88%97-%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="队列" scheme="http://chenzqi.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux&amp;ensp;常用命令</title>
    <link href="http://chenzqi.cn/2018/12/09/linuxcmd/"/>
    <id>http://chenzqi.cn/2018/12/09/linuxcmd/</id>
    <published>2018-12-09T04:59:39.000Z</published>
    <updated>2018-12-09T10:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-ensp-磁盘管理"><a href="#一-ensp-磁盘管理" class="headerlink" title="一&ensp;磁盘管理"></a><p style="color: #f8412c">一&ensp;磁盘管理</p></h4><h5 id="list命令"><a href="#list命令" class="headerlink" title="list命令"></a><p style="color: green">list命令</p></h5><p>&emsp;&emsp;就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等<br> <strong>常用参数搭配</strong><br> ls -a 列出目录所有文件，包含以.开始的隐藏文件<br> ls -A 列出除.及..的其它文件<br> ls -r 反序排列<br> ls -t 以文件修改时间排序<br> ls -S 以文件大小排序<br> ls -h 以易读大小显示<br> ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来<br><strong>实例</strong></p><ul><li>按易读方式按时间反序排序，并显示文件详细信息<br>ls -lhrt</li><li>按大小反序显示文件详细信息<br>ls -lrS<br><em>列出当前目录中所有以“t”开头的目录的详细内容<br>ls -l t</em>  </li><li>列出文件绝对路径（不包含隐藏文件）<br>ls | sed “s:^:`pwd`/:”</li><li>列出文件绝对路径（包含隐藏文件）<br>find $pwd -maxdepth 1 | xargs ls -ld</li></ul><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><p style="color: green">cd命令</p></h5><p>&emsp;&emsp;Linux cd命令用于切换当前工作目录至 dirName(目录参数)<br>&emsp;&emsp;其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)<br>&emsp;&emsp;另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。<br><strong>实例</strong></p><ul><li>跳到 /usr/bin/<br>cd /usr/bin</li><li>跳到自己的 home 目录<br>cd ~</li><li>进入上一次工作路径<br>cd -</li><li>跳到目前目录的上上两层<br>cd ../..</li></ul><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a><p style="color: green">pwd命令</p></h5><p>&emsp;&emsp;pwd命令用于显示工作目录。<br>&emsp;&emsp;执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><hr><ul><li>查看当前路径<br>pwd</li><li>查看软链接的实际路径<br>pwd -P</li></ul><h5 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a><p style="color: green">df命令</p></h5><p>&emsp;&emsp;df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。<br> <strong>常用参数搭配</strong><br> -a, –all&emsp;包含所有的具有 0 Blocks 的文件系统<br>–block-size={SIZE}&emsp;使用 {SIZE} 大小的 Blocks<br>-h, –human-readable&emsp;使用人类可读的格式(预设值是不加这个选项的…)<br>-i, –inodes&emsp;列出 inode 资讯，不列出已使用 block<br>-l, –local&emsp;限制列出的文件结构<br>-m, –megabytes&emsp;就像 –block-size=1048576<br>–no-sync &emsp;取得资讯前不 sync (预设值)<br>-P, –portability &emsp;使用 POSIX 输出格式<br>-t, –type=TYPE &emsp;限制列出文件系统的 TYPE<br>-T, –print-type &emsp;显示文件系统的形式<br>-x, –exclude-type=TYPE &emsp;限制列出文件系统不要显示 TYPE<br>-v (忽略)<br>–help 显示这个帮手并且离开<br>–version 输出版本资讯并且离开</p><h5 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a><p style="color: green">du命令</p></h5><p>&emsp;&emsp;du命令用于显示目录或文件的大小。<br>&emsp;&emsp;du会显示指定的目录或文件所占用的磁盘空间。<br><strong>常用参数搭配</strong><br>-a或-all &emsp;显示目录中个别文件的大小。<br>-b或-bytes &emsp;显示目录或文件大小时，以byte为单位。<br>-c或–total &emsp;除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args &emsp;显示指定符号连接的源文件大小。<br>-h或–human-readable &emsp;以K，M，G为单位，提高信息的可读性。<br>-H或–si &emsp;与-h参数相同，但是K，M，G是以1000为换算单位。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; &emsp;显示选项中所指定符号连接的源文件大小。<br>-s或–summarize &emsp;仅显示总计。<br>-S或–separate-dirs &emsp;显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem &emsp;以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; &emsp;在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; &emsp;略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; &emsp;超过指定层数的目录后，予以忽略。<br>–help &emsp;显示帮助。<br>–version &emsp;显示版本信息。<br><strong>实例</strong></p><ul><li>显示目录或者文件所占空间<br>du</li><li>显示指定文件所占空间<br>du filename</li><li>方便阅读的格式显示test目录所占空间情况<br>du -h test<br><img src="/2018/12/09/linuxcmd/01.png" alt=""></li></ul><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a><p style="color: green">mkdir命令</p></h5><p>&emsp;&emsp;mkdir命令用于建立名称为 dirName 之子目录<br><strong>参数说明</strong><br>-p &emsp;确保目录名称存在，不存在的就建一个。<br><strong>实例</strong></p><ul><li>在工作目录下，建立一个名为 AAA 的子目录 :<br>mkdir AAA</li><li>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）<br>mkdir &ensp;-p &ensp;BBB/Test</li></ul><h5 id="rmkdir命令"><a href="#rmkdir命令" class="headerlink" title="rmkdir命令"></a><p style="color: green">rmkdir命令</p></h5><p>&emsp;&emsp;rmdir命令删除空的目录。<br><strong>参数说明</strong><br>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。<br><strong>实例</strong></p><ul><li>将工作目录下，名为 AAA 的子目录删除 :<br>rmdir AAA</li><li>在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除。<br>rmdir &ensp;-p &ensp;BBB/Test</li></ul><h5 id="quotar命令"><a href="#quotar命令" class="headerlink" title="quotar命令"></a><p style="color: green">quotar命令</p></h5><p>&emsp;&emsp;quota命令用于显示磁盘已使用的空间与限制<br><strong>参数说明</strong><br>-g &emsp;列出群组的磁盘空间限制。<br>-q &emsp;简明列表，只列出超过限制的部分。<br>-u &emsp;列出用户的磁盘空间限制。<br>-v &emsp;显示该用户或群组，在所有挂入系统的存储设备的空间限制。<br>-V &emsp;显示版本信息。</p><h5 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a><p style="color: green">mount命令</p></h5><p>mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件<br><strong>实例</strong></p><ul><li>将 /dev/hda1 挂在 /mnt 之下<br>#&ensp;mount &ensp;/dev/hda1 &ensp;/mnt</li></ul><h5 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a><p style="color: green">tree命令</p></h5><p>&emsp;&emsp;tree命令用于以树状图列出目录的内容。<br>&emsp;&emsp;执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件</p><h4 id="二-ensp-文件管理"><a href="#二-ensp-文件管理" class="headerlink" title="二&ensp;文件管理"></a><p style="color: #f8412c">二&ensp;文件管理</p></h4><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a><p style="color: green">rm命令</p></h5><p>&emsp;&emsp;rm命令用于删除一个文件或者目录。<br><strong>参数说明</strong><br>-i &emsp;删除前逐一询问确认。<br>-f &emsp;即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r &emsp;将目录及以下之档案亦逐一删除。<br><strong>实例</strong></p><ul><li>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如<br><img src="/2018/12/09/linuxcmd/02.png" alt=""></li><li>删除当前目录下的所有文件及目录，命令行为<br>rm  -r  *</li></ul><h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a><p style="color: green">mv命令</p></h5><p>&emsp;&emsp;移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。<br>&emsp;&emsp;当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中<br><strong>实例</strong></p><ul><li>将文件test.log重命名为test1.txt<br>mv &ensp;test.log &ensp;test1.txt</li><li>将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中<br>mv &ensp;llog1.txt &ensp;log2.txt &ensp;log3.txt &ensp;/test3</li><li>将文件file1改名为file2，如果file2已经存在，则询问是否覆盖<br>mv &ensp;-i &ensp;log1.txt &ensp;log2.txt</li><li>移动当前文件夹下的所有文件到上一级目录<br>mv &ensp;* &ensp;../</li></ul><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a><p style="color: green">cp命令</p></h5><p>&emsp;&emsp;cp命令主要用于复制文件或目录(或将多个源文件复制至目标目录)<br><span style="color: red">注意</span>：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！<br><strong>参数说明</strong><br>-i &ensp;在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖<br>-f &ensp;与-i相反,覆盖已经存在的目标文件而不给出提示。<br>-r &ensp;复制目录及目录内所有项目<br>-a &ensp;复制的文件与原文件时间一样<br><strong>实例</strong></p><ul><li>复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖<br>cp &ensp;-ai &ensp;a.txt &ensp;test</li><li>将当前目录”test/“下的所有文件复制到新目录”newtest”下<br>cp &ensp;–r &ensp;test/ &ensp;newtest </li><li>为a.txt建议一个链接（快捷方式）<br>cp &ensp;-s &ensp;a.txt &ensp;link_a.txt</li></ul><h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a><p style="color: green">head命令</p></h5><p>&emsp;&emsp;head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行<br><strong>常用参数</strong><br>-n &ensp;&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）<br><strong>实例</strong></p><ul><li>显示1.log文件中前20行<br>head &ensp;1.log &ensp;-n &ensp;20</li><li>显示t.log最后10行<br>head &ensp;-n &ensp;-10 &ensp;t.log</li></ul><h5 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a><p style="color: green">查找命令</p></h5><p>&emsp;&emsp;在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p><ul><li>which &ensp;查看可执行文件的位置。</li><li>whereis &ensp;查看文件的位置。</li><li>locate  &ensp;配合数据库查看文件位置。</li><li>find   &ensp;实际搜寻硬盘查询文件名称。<br>which是在PATH就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li></ul><p><strong>常用参数</strong><br>-n &ensp;指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br><strong>实例</strong></p><ul><li><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令<br>which &emsp;bash<br>上面的指令执行后，输出信息如下所示:<br><img src="/2018/12/09/linuxcmd/03.png" alt=""></p></li><li><p>查看ls命令是否存在，执行哪个<br>which ls</p></li><li>查看which<br>which which</li><li>查看cd<br>which cd &ensp;（显示不存在，因为cd是内建命令，而which查找显示是PATH中的命令）</li><li>查看当前PATH配置<br>echo $PATH;&ensp;或使用env查看所有环境变量及对应值</li></ul><h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a><p style="color: green">chmod命令</p></h5><p>&emsp;&emsp;Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用<br><strong>参数说明</strong></p><ul><li>u &ensp;表示该文件的拥有者，&ensp;g &ensp;表示与该文件的拥有者属于同一个群体(group)者，&ensp;o &ensp;表示其他以外的人，&ensp;a &ensp;表示这三者皆是。</li><li>+ &ensp;表示增加权限、&ensp;- &ensp;表示取消权限、&ensp;= &ensp;表示唯一设定权限。</li><li>r &ensp;表示可读取，w &ensp;表示可写入，x &ensp;表示可执行，X &ensp;表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>-c &ensp;若该文件权限确实已经更改，才显示其更改动作<br>-f &ensp;若该文件权限无法被更改也不要显示错误讯息<br>-v &ensp;显示权限变更的详细资料<br>-R &ensp;对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help &ensp;显示辅助说明<br>–version &ensp;显示版本</li></ul><p><strong>实例</strong></p><ul><li>将文件 file1.txt 设为所有人皆可读取<br>chmod a+r file1.txt</li><li>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入<br>chmod ug+w,o-w file1.txt file2.txt</li><li>将 ex1.py 设定为只有该文件拥有者可以执行<br>chmod u+x ex1.py</li><li>将目前目录下的所有文件与子目录皆设为任何人可读取<br>chmod -R a+r *</li></ul><p><strong>此外chmod也可以用数字来表示权限如 :</strong><br>语法为：<br>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。<br>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br>chmod a=rwx file &ensp;等于 &ensp;chmod 777 file<br>chmod ug=rwx,o=x file&ensp;等于&ensp;chmod 771 file</p><h4 id="二-ensp-系统管理"><a href="#二-ensp-系统管理" class="headerlink" title="二&ensp;系统管理"></a><p style="color: #f8412c">二&ensp;系统管理</p></h4><h5 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a><p style="color: green">reboot命令</p></h5><p>&ensp;&emsp;reboot命令用于用来重新启动计算机</p><h5 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a><p style="color: green">shutdown命令</p></h5><p>&ensp;&emsp;shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机<br><strong>参数说明</strong><br>-r &ensp;关机后重新开机<br>-h &ensp;关机后停机<br>-n &ensp;不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机<br>-c &ensp;取消目前已经进行中的关机动作<br>-f &ensp;关机时，不做 fcsk 动作(检查 Linux 档系统)<br>-F &ensp;关机时，强迫进行 fsck 动作<br>time &ensp;设定关机的时间<br>message &ensp;传送给所有使用者的警告讯息<br><strong>实例</strong></p><ul><li>立即关机<br>shutdown -h now</li><li>指定5分钟后关机<br>shutdown +5 “System will shutdown after 5 minutes” //5分钟够关机并显示警告信息</li></ul><h5 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a><p style="color: green">ps命令</p></h5><p>&ensp;&emsp;ps命令用于查看系统中的进程状态，格式为“ps [参数]”<br><strong>参数说明</strong><br>-a &ensp;显示所有进程<br>-u &ensp; 用户以及其他详细信息<br>-x &ensp; 显示没有控制终端的进程<br>在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。<br>R（运行）&ensp;进程正在运行或在运行队列中等待。<br>S（中断）&ensp;进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该   状态。<br>D（不可中断）&ensp;进程不响应系统异步信号，即便用kill命令也不能将其中断。<br>Z（僵死）&ensp;进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。<br>T（停止）&ensp;进程收到停止信号后停止运行。</p><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a><p style="color: green">kill命令</p></h5><p>kill命令用于删除执行中的程序或工作。<br>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。<br><strong>实例</strong></p><ul><li>杀死进程<br>kill 12345</li><li>强制杀死进程<br>kill -KILL 123456</li><li>彻底杀死进程<br>kill -9 123456</li></ul><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a><p style="color: green">ifconfig命令</p></h5><p>&ensp;&emsp;ifconfig命令用于获取网卡配置与网络状态等信息，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-ensp-磁盘管理&quot;&gt;&lt;a href=&quot;#一-ensp-磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;一&amp;ensp;磁盘管理&quot;&gt;&lt;/a&gt;&lt;p style=&quot;color: #f8412c&quot;&gt;一&amp;ensp;磁盘管理&lt;/p&gt;&lt;/h4&gt;&lt;h5 id=
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chenzqi.cn/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="http://chenzqi.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="linux" scheme="http://chenzqi.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分析&amp;ensp;爬取必胜客全球餐厅信息</title>
    <link href="http://chenzqi.cn/2018/12/05/Pizzahut/"/>
    <id>http://chenzqi.cn/2018/12/05/Pizzahut/</id>
    <published>2018-12-05T12:36:43.000Z</published>
    <updated>2018-12-09T05:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; <strong>爬过很多网站,最让猿头疼的是通过js动态加载网页数据,如果不熟悉前端js代码,对新手来说是道难题,当然,有些网站也可以通过抓包来实现。今天,浅谈分析通过js代码找到数据请求接口</strong></p><h4 id="一-ensp-爬取目标"><a href="#一-ensp-爬取目标" class="headerlink" title="一&ensp;爬取目标"></a>一&ensp;爬取目标</h4><p>&emsp;&emsp;要爬取的目标是<a href="http://www.pizzahut.com.cn/StoreList" target="_blank" rel="noopener">必胜客中国</a>。打开必胜客中国首页，进入“餐厅查询”页面。<br><br><br><img src="/2018/12/05/Pizzahut/01.png" alt="img"><br>&emsp;&emsp;要爬取的数据内容有城市、餐厅名字、餐厅地址以及餐厅联系电话。因为我看到页面中有地图，所以页面一定有餐厅地址的经纬度。因此，餐厅的经纬度也是需要爬取的数据。<br>&emsp;&emsp;至于全国有必胜客餐厅的城市列表，可以通过页面的“切换城市”获取。</p><h4 id="二-ensp-分析页面"><a href="#二-ensp-分析页面" class="headerlink" title="二&ensp;分析页面"></a>二&ensp;分析页面</h4><p>&emsp;&emsp;在编写爬虫程序之前，建议都是先对页面进行简单分析，然后指定爬取思路。而且对页面结构进行分析往往会有一些意想不到的收获。<br>&emsp;&emsp;首先，使用浏览器的开发者工具对页面结构进行简单分析。这里强烈推荐使用Chrome浏览器。亲测。<br><br><br><img src="/2018/12/05/Pizzahut/02.png" alt=""><br>&emsp;&emsp;我们在 StoreList 页面中能找到我们所需的数据。这个能确定数据提取的 Xpath 语法。<br>&emsp;&emsp;StoreList 页面的 Response 内容比较长。先不着急关闭页面，往下看看，找找看是否有其他可利用的内容。最后，找到调用获取餐厅列表信息的 JavaScript 函数代码。<br><br><br><img src="/2018/12/05/Pizzahut/03.png" alt=""><br>&emsp;&emsp;接着搜索下GetStoreList函数，看看浏览器如何获取餐厅列表信息的。<br><br><br><img src="/2018/12/05/Pizzahut/04.png" alt=""><br>&emsp;&emsp;从代码中，我们可以了解到页面使用 Ajax 方式来获取数据。页面以 POST 方式请求地址&ensp;<a href="http://www.pizzahut.com.cn/StoreList/Index。同时，请求还携带参数" target="_blank" rel="noopener">http://www.pizzahut.com.cn/StoreList/Index。同时，请求还携带参数</a> pageIndex 和 pageSize。</p><h4 id="三-ensp-爬取思路"><a href="#三-ensp-爬取思路" class="headerlink" title="三&ensp;爬取思路"></a>三&ensp;爬取思路</h4><p>&emsp;&emsp;经过一番页面结构分析之后，来指定爬取思路。首先，先获取城市信息。然后将其作为参数，构建 HTTP 请求访问必胜客服务器来获取当前城市中所有餐厅数据。<br>&emsp;&emsp;为了方便数据爬取，我将所有城市全部写入到 cities.txt 中。等要爬取数据时，我们再从文件中读取城市信息。<br>&emsp;&emsp;爬取思路看起来没有错，但是还是有个难题没有搞定。每次打开必胜客的官网，页面每次都会自动定位到当前所在的城市。如果无法破解城市定位问题，那么只能抓取一个城市数据。<br>&emsp;&emsp;于是，再次浏览首页，看看能不能找到一些可用的信息。最终，发现页面的 cookies 中有个 iplocation 字段。我将其进行 Url 解码，得到 深圳|0|0 这样的信息。<br><br><br><img src="/2018/12/05/Pizzahut/05.png" alt=""><br><img src="/2018/12/05/Pizzahut/06.png" alt=""><br>&emsp;&emsp;看到这信息，一定会有点思路。原来必胜客网站根据我们的 IP 地址来设置初始城市信息。如果能伪造出 iplocation 字段信息，那就可以随便修改城市了</p><h4 id="四-ensp-代码实现"><a href="#四-ensp-代码实现" class="headerlink" title="四&ensp;代码实现"></a>四&ensp;代码实现</h4><p>&emsp;&emsp;第一步是从文件中读取城市信息,放进一个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 全国有必胜客餐厅的城市, 我将城市放到文件中, 一共 380 个城市</span><br><span class="line">cities = []</span><br><span class="line"></span><br><span class="line">def get_cities():</span><br><span class="line">    &quot;&quot;&quot; 从文件中获取城市 &quot;&quot;&quot;</span><br><span class="line">    file_name = &apos;cities.txt&apos;</span><br><span class="line">    with open(file_name, &apos;r&apos;, encoding=&apos;UTF-8-sig&apos;) as file:</span><br><span class="line">        for line in file:</span><br><span class="line">            city = line.replace(&apos;\n&apos;, &apos;&apos;)</span><br><span class="line">            cities.append(city)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;第二步是依次遍历 cities 列表，将每个城市作为参数，构造 Cookies 的 iplocation 字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count = 1</span><br><span class="line">results = &#123;&#125;</span><br><span class="line"># 依次遍历所有城市的餐厅,调用爬虫函数,并传递城市参数</span><br><span class="line">for city in cities:</span><br><span class="line">    restaurants = get_stores(city, count)</span><br><span class="line">    results[city] = restaurants</span><br><span class="line">    count += 1</span><br><span class="line">    time.sleep(2)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后，对参数进行处理，以 POST 方式携带 Cookie 去请求必胜客服务器。最后再对返回页面数据进行提取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">def get_stores(city, count):</span><br><span class="line">    &quot;&quot;&quot; 根据城市获取餐厅信息 &quot;&quot;&quot;</span><br><span class="line">    session = requests.Session()</span><br><span class="line">    # 对【城市|0|0】进行 Url 编码</span><br><span class="line">    city_urlencode = quote(city + &apos;|0|0&apos;)</span><br><span class="line">    # 用来存储首页的 cookies</span><br><span class="line">    cookies = requests.cookies.RequestsCookieJar()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;User-agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.3964.2 Safari/537.36&apos;,</span><br><span class="line">        &apos;accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</span><br><span class="line">        &apos;Host&apos;: &apos;www.pizzahut.com.cn&apos;,</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;max-age=0&apos;,</span><br><span class="line">        &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(&apos;============第&apos;, count, &apos;个城市:&apos;, city, &apos;============&apos;)</span><br><span class="line">    resp_from_index = session.get(&apos;http://www.pizzahut.com.cn/&apos;, headers=headers)</span><br><span class="line">    # print(resp_from_index.cookies)</span><br><span class="line">    # 然后将原来 cookies 的 iplocation 字段，设置自己想要抓取城市。</span><br><span class="line">    cookies.set(&apos;AlteonP&apos;, resp_from_index.cookies[&apos;AlteonP&apos;], domain=&apos;www.pizzahut.com.cn&apos;)</span><br><span class="line">    cookies.set(&apos;iplocation&apos;, city_urlencode, domain=&apos;www.pizzahut.com.cn&apos;)</span><br><span class="line">    # print(cookies)</span><br><span class="line"></span><br><span class="line">    page = 1</span><br><span class="line">    restaurants = []</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        data = &#123;</span><br><span class="line">            &apos;pageIndex&apos;: page,</span><br><span class="line">            &apos;pageSize&apos;: &quot;50&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response = session.post(&apos;http://www.pizzahut.com.cn/StoreList/Index&apos;, headers=headers, data=data, cookies=cookies)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        # 获取餐厅列表所在的 div 标签</span><br><span class="line">        divs = html.xpath(&quot;//div[@class=&apos;re_RNew&apos;]&quot;)</span><br><span class="line">        temp_items = []</span><br><span class="line">        for div in divs:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            content = div.xpath(&apos;./@onclick&apos;)[0]</span><br><span class="line">            # ClickStore(&apos;22.538912,114.09803|城市广场|深南中路中信城市广场二楼|0755-25942012&apos;,&apos;GZH519&apos;)</span><br><span class="line">            # 过滤掉括号和后面的内容</span><br><span class="line">            content = content.split(&apos;(\&apos;&apos;)[1].split(&apos;)&apos;)[0].split(&apos;\&apos;,\&apos;&apos;)[0]</span><br><span class="line"></span><br><span class="line">            if len(content.split(&apos;|&apos;)) == 4:</span><br><span class="line">                item[&apos;coordinate&apos;] = content.split(&apos;|&apos;)[0]</span><br><span class="line">                item[&apos;restaurant_name&apos;] = content.split(&apos;|&apos;)[1] + &apos;餐厅&apos;</span><br><span class="line">                item[&apos;address&apos;] = content.split(&apos;|&apos;)[2]</span><br><span class="line">                item[&apos;phone&apos;] = content.split(&apos;|&apos;)[3]</span><br><span class="line">            else:</span><br><span class="line">                item[&apos;restaurant_name&apos;] = content.split(&apos;|&apos;)[0] + &apos;餐厅&apos;</span><br><span class="line">                item[&apos;address&apos;] = content.split(&apos;|&apos;)[1]</span><br><span class="line">                item[&apos;phone&apos;] = content.split(&apos;|&apos;)[2]</span><br><span class="line">            print(item)</span><br><span class="line">            temp_items.append(item)</span><br><span class="line"></span><br><span class="line">        if not temp_items:</span><br><span class="line">            break</span><br><span class="line">        restaurants += temp_items</span><br><span class="line">        page += 1</span><br><span class="line">        time.sleep(5)</span><br><span class="line">    return restaurants</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    get_cities()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;第三步是将城市以及城市所有餐厅信息等数据写到 Json 文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;results.json&apos;, &apos;w&apos;, encoding=&apos;UTF-8&apos;) as file:</span><br><span class="line">        file.write(json.dumps(results, indent=4, ensure_ascii=False))</span><br></pre></td></tr></table></figure></p><h4 id="五-ensp-爬虫结果"><a href="#五-ensp-爬虫结果" class="headerlink" title="五&ensp;爬虫结果"></a>五&ensp;爬虫结果</h4><p>&emsp;&emsp;程序运行完之后, 就会在当前目录下生成一个名为「results.json」文件<br><br><br><img src="/2018/12/05/Pizzahut/07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp; &lt;strong&gt;爬过很多网站,最让猿头疼的是通过js动态加载网页数据,如果不熟悉前端js代码,对新手来说是道难题,当然,有些网站也可以通过抓包来实现。今天,浅谈分析通过js代码找到数据请求接口&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-ensp
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chenzqi.cn/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="爬虫" scheme="http://chenzqi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据分析" scheme="http://chenzqi.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Docker简介与命令</title>
    <link href="http://chenzqi.cn/2018/11/23/docker/"/>
    <id>http://chenzqi.cn/2018/11/23/docker/</id>
    <published>2018-11-23T08:28:12.000Z</published>
    <updated>2018-12-05T12:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-docker简介"><a href="#一-docker简介" class="headerlink" title="一 docker简介"></a>一 docker简介</h3><p>&emsp;&emsp;<strong>Docker 属于 Linux 容器的一种封装，采用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。它是目前最流行的 Linux 容器解决方案。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行</strong></p><ul><li>更快速的交付和部署</li><li>更高效的虚拟化</li><li>更轻松的迁移和扩展</li><li>更简单的管理</li></ul><ol><li><h4 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h4></li></ol><ul><li><strong>简化程序</strong><br>&emsp;&emsp;Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成</li><li><strong>避免选择恐惧症</strong><br>&emsp;&emsp;如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署</li><li><strong>节省开支</strong><br>&emsp;&emsp;一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li></ul><ol start="2"><li><h4 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h4></li></ol><ul><li>Web 应用的自动化打包和发布，实现合作团队开发环境一致</li><li>自动化测试和持续集成、发布</li><li>在服务型环境中部署和调整数据库或其他的后台应用</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境</li></ul><ol start="3"><li><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4></li></ol><ul><li><p><strong>Docker是CS架构，主要有两个概念</strong><br>&emsp;&emsp;<strong>Docker daemon</strong>: 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互<br>&emsp;&emsp;<strong>Docker client</strong>: Docker 命令行工具，是用户使用Docker的主要方式，Docker client与Docker daemon通信并将结果返回给用户，Docker client也可以通过socket或者RESTful api访问远程的Docker daemon</p></li><li><p><strong>Docker的三个主要概念</strong><br>&emsp;&emsp;<strong>Docker image</strong>：镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载<br>&emsp;&emsp;<strong>Docker container</strong>：容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中<br>&emsp;&emsp;<strong>Docker hub/registry</strong>: 共享和管理Docker镜像，用户可以上传或者下载上面的镜像，官方地址为<a href="https://registry.hub.docker.com/，也可以搭建自己私有的Docker" target="_blank" rel="noopener">https://registry.hub.docker.com/，也可以搭建自己私有的Docker</a> registry<br>镜像就相当于打包好的版本，镜像启动之后运行在容器中，仓库就是装存储镜像的地方</p></li></ul><h3 id="二-常用命令"><a href="#二-常用命令" class="headerlink" title="二 常用命令"></a>二 常用命令</h3><ol><li><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4></li></ol><ul><li><p><strong>login / logout</strong><br>登陆到Docker Hub<br>docker login -u 用户名 -p 密码<br>登出Docker Hub<br>docker logout</p></li><li><p><strong>pull / push</strong><br><strong>从Docker Hub下载java最新版镜像</strong><br>docker pull java<br><strong>从Docker Hub下载REPOSITORY为java的所有镜像</strong><br>docker pull -a java<br><strong>上传本地镜像myapache:v1到镜像仓库中</strong><br>docker push myapache:v1</p></li></ul><ul><li><strong>search</strong><br>从Docker Hub查找镜像</li></ul><ol start="2"><li><h4 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h4></li></ol><ul><li><p><strong>run</strong><br><strong>创建一个新的容器并运行一个命令</strong><br>docker run [参数] Image [命令]</p><pre><code>-i: 以交互模式运行容器，通常与 -t 同时使用-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用-p: 端口映射，格式为：主机(宿主)端口:容器端口--name=&quot;nginx-lb&quot;: 为容器指定一个名称；-d: 后台运行容器，不加会进入容器，一般不加-m :设置容器使用内存最大值；</code></pre><p><strong>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</strong><br>docker run -it nginx:latest /bin/bash<br><strong>目录挂载到主机（宿主机）www中</strong><br>docker run -i -t -d (不加自动进入容器) –name=’lisi’ -p 80:80 -p 81:81 -v /www:/www ubuntu /bin/bash</p></li><li><p><strong>start/stop/restart</strong> 命令<br><strong>启动一个或多个已经被停止的容器</strong><br>docker start<br><strong>停止一个运行中的容器</strong><br>docker stop<br><strong>重启容器</strong><br>docker restart</p></li><li><p>kill命令<br><strong>杀掉一个运行中的容器</strong><br>docker kill</p></li><li><p><strong>pause/unpause</strong> 命令<br><strong>暂停容器中所有的进程</strong><br>docker pause<br><strong>恢复容器中所有的进程</strong><br>docker unpause</p></li><li><p><strong>create</strong> 命令<br><strong>创建一个新的容器但不启动它</strong><br>docker create</p></li><li><p><strong>exec</strong> 命令<br><strong>在运行的容器中执行命令</strong><br>docker exec<br>docker exec -i -t 容器 /bin/bash<br><strong>在一个容器内开多个终端的意思</strong></p></li></ul><ol start="3"><li><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4></li></ol><ul><li><p><strong>ps</strong><br><strong>列出容器</strong><br>docker ps [参数] 容器</p><pre><code>-a :显示所有的容器，包括未运行的-l :显示最近创建的容器-n :列出最近创建的n个容器-q :静默模式，只显示容器编号-s :显示总的文件大小</code></pre></li><li><p><strong>top</strong><br>查看容器中运行的进程信息，支持 ps 命令参数</p></li><li><p><strong>attach</strong><br>连接到正在运行中的容器</p></li><li><p><strong>events</strong><br>从服务器获取实时事件</p></li><li><p><strong>logs</strong><br>获取容器的日志</p><pre><code>-f :跟踪日志输出--since :显示某个开始时间的所有日志-t :显示时间戳--tail :仅列出最新N条容器日志</code></pre></li><li><p><strong>port</strong><br>列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</p></li><li><p><strong>commit</strong><br>从容器创建一个新的镜像<br>docker commit -a ‘zhangsan’ -m ‘installed nginx and python3.6’  容器名 docker账号/镜像名</p><pre><code>-a :提交的镜像作者；-m :提交时的说明文字-p :在commit时，将容器暂停。</code></pre></li></ul><ol start="4"><li><h4 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h4></li></ol><ul><li><p><strong>images</strong><br>列出本地镜像</p><pre><code>-a：列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）--digests：显示镜像的摘要信息--no-trunc：显示完整的镜像信息-q：只显示镜像ID</code></pre></li><li><p><strong>info</strong><br>显示 Docker 系统信息，包括镜像和容器数</p></li><li><strong>version</strong><br>显示 Docker 版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-docker简介&quot;&gt;&lt;a href=&quot;#一-docker简介&quot; class=&quot;headerlink&quot; title=&quot;一 docker简介&quot;&gt;&lt;/a&gt;一 docker简介&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Docker 属于 Linux 容器
      
    
    </summary>
    
      <category term="解析&amp;命令" scheme="http://chenzqi.cn/categories/%E8%A7%A3%E6%9E%90-%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="docker" scheme="http://chenzqi.cn/tags/docker/"/>
    
      <category term="命令" scheme="http://chenzqi.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>使用Nginx+Gunicorn+virtualenv+supervisor部署django项目</title>
    <link href="http://chenzqi.cn/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/"/>
    <id>http://chenzqi.cn/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/</id>
    <published>2018-11-22T11:54:18.000Z</published>
    <updated>2018-12-05T12:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前景简介"><a href="#一-前景简介" class="headerlink" title="一 前景简介"></a>一 前景简介</h3><ul><li><strong>Nginx</strong><br>&emsp;&emsp;Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现</li><li><strong>Gunicorn</strong><br>&emsp;&emsp;Gunicorn“绿色独角兽”是一个被广泛使用的高性能的Python WSGI UNIX HTTP服务器，移植自Ruby的独角兽（Unicorn ）项目,使用pre-fork worker模式，具有使用非常简单，轻量级的资源消耗，以及高性能等特点<br>&emsp;&emsp;Gunicorn 服务器作为wsgi app的容器，能够与各种Web框架兼容（flask，django等）,得益于gevent等技术，使用Gunicorn能够在基本不改变wsgi app代码的前提下，大幅度提高wsgi app的性能</li><li><strong>supervisor</strong><br>&emsp;&emsp;supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具。可以很方便的监听、启动、停止、重启一个或多个进程。用supervisor管理的进程，当一个进程意外被杀死，supervisor监听到进程死后，会自动将它重启，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。</li></ul><h3 id="二-安装gunicorn和其它模块"><a href="#二-安装gunicorn和其它模块" class="headerlink" title="二 安装gunicorn和其它模块"></a>二 安装gunicorn和其它模块</h3><ol><li><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><strong>完成宿主机与容器挂载，映射配置后，在项目容器内执行相关部署操作</strong><br>#python的高性能的WSGI HTTP服务器<br>$ <strong>pip3 install gunicorn</strong><br>#Required for both<br>$ <strong>pip3 install greenlet</strong><br>#For eventlet workers<br>$ <strong>pip3 install eventlet</strong><br>#For gevent workers<br>$ <strong>pip3 install gevent</strong><br>#安装nginx服务器<br>$ <strong>apt-get install -y nginx</strong><br>#安装apache测试命令 不需要的话不用下载<br>$ <strong>apt-get install -y apache2-utils</strong></p></li><li><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p><strong>在项目settings.py同级目录下创建gunicorn.conf.py文件</strong><br><strong>加入以下配置代码,注意项目名称与路径的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">from multiprocessing import cpu_count</span><br><span class="line"></span><br><span class="line">bind = &quot;0.0.0.0:8000&quot;</span><br><span class="line">#设置守护进程,将进程交给supervisor管理</span><br><span class="line">daemon = True </span><br><span class="line"></span><br><span class="line"># 并行工作进程数,workers是工作线程数，一般设置成：2*服务器CPU个数 + 1，这样的话，在任何时候都有一半的worker在做IO</span><br><span class="line">workers = 2*cpu_count() + 1</span><br><span class="line"></span><br><span class="line"># 指定每个工作者的线程数</span><br><span class="line">threads = 2</span><br><span class="line"></span><br><span class="line">worker_class = &quot;gevent&quot;</span><br><span class="line"></span><br><span class="line">forworded_allow_ips = &apos;*&apos;</span><br><span class="line"></span><br><span class="line">keepalive = 6</span><br><span class="line"></span><br><span class="line">timeout = 65</span><br><span class="line"></span><br><span class="line">graceful_timeout = 10</span><br><span class="line"></span><br><span class="line"># 设置最大并发量</span><br><span class="line">worker_connections = 65535</span><br><span class="line"></span><br><span class="line"># 设置进程文件目录</span><br><span class="line">pidfile = &apos;/www/DjangoPro/gunicorn.pid&apos;</span><br><span class="line"></span><br><span class="line"># 设置访问日志和错误信息日志路径</span><br><span class="line">errorlog = &apos;/www/DjangoPro/gunicorn.error.log&apos;</span><br><span class="line">accesslog = &apos;/www/DjangoPro/gunicorn.access.log&apos;</span><br><span class="line"></span><br><span class="line"># 设置日志等级 info errer</span><br><span class="line">loglevel = &apos;info&apos;</span><br><span class="line"></span><br><span class="line"># debug : 打印全部的日志(notset等同于debug)</span><br><span class="line"># info : 打印info,warning,error,critical级别的日志</span><br><span class="line"># warning : 打印warning,error,critical级别的日志</span><br><span class="line"># error : 打印error,critical级别的日志</span><br><span class="line"># critical : 打印critical级别</span><br><span class="line"></span><br><span class="line">proc_name = &apos;DjangoPro&apos;</span><br></pre></td></tr></table></figure></li><li><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><strong>输入命令根据配置文件启动项目，注意项目名</strong><br>gunicorn -c DjangoPro/gunicorn.conf.py DjangoPro.wsgi:application</p></li><li><h4 id="查看gunicorn状态"><a href="#查看gunicorn状态" class="headerlink" title="查看gunicorn状态"></a>查看gunicorn状态</h4><p>ps aux | grep gunicorn</p></li><li><h4 id="查看后台所有进程"><a href="#查看后台所有进程" class="headerlink" title="查看后台所有进程"></a>查看后台所有进程</h4><p>ps -ax</p></li><li><h4 id="强制杀死某个进程"><a href="#强制杀死某个进程" class="headerlink" title="强制杀死某个进程"></a>强制杀死某个进程</h4><p>kill -9 id号</p></li><li><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>ab -n 1000 -c 10 <a href="http://127.0.0.1:8000/json/" target="_blank" rel="noopener">http://127.0.0.1:8000/json/</a><br>#1000表示访问量，10表示并发量，http:…表示进行测试的地址</p></li></ol><h3 id="三-配置nginx"><a href="#三-配置nginx" class="headerlink" title="三 配置nginx"></a>三 配置nginx</h3><p><strong>nginx上面已经下载过，直接通过vi编辑器配置文件</strong></p><ol><li><h4 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h4># <strong>vi /etc/nginx/nginx.conf</strong>  修改为65535<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/01.png" alt=""></li><li><h4 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h4><p># <strong>vi /etc/nginx/conf.d/djangopro.conf</strong><br><strong>添加以下配置信息,注意项目路径；中文注释在终端中正好去掉</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream app_server &#123;</span><br><span class="line">        server 127.0.0.1:8002;  #与gunicorn配置中bind的地址一致</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;listen       8000;  # 该端口要开放</span><br><span class="line">        server_name  0.0.0.0;  #域名或主机地址</span><br><span class="line">        access_log  /www/MyServer/logs/host.access.log;</span><br><span class="line">        location = /favicon.ico  &#123;</span><br><span class="line">            empty_gif;</span><br><span class="line">            access_log off;</span><br><span class="line">        &#125;</span><br><span class="line">        location /static/ &#123;</span><br><span class="line">            root   /www/MyServer/;</span><br><span class="line">            expires 30d;</span><br><span class="line">            access_log off;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_pass http://app_server;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="测试配置文件"><a href="#测试配置文件" class="headerlink" title="测试配置文件"></a>测试配置文件</h4><p>通过命令 <strong>nginx -t</strong> 检测nginx配置文件是否存在语法错误，以下说明ok<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/02.png" alt=""></p></li><li><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><p># <strong>service nginx start</strong> 右侧有ok说明启动成功，下图没截到<br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/03.png" alt=""><br><strong>如果nginx启动失败，可能是独角兽在后台运行，先关闭，上面有关闭命令</strong><br><em>注意：如果想通过nginx访问django项目，需要将gunicorn端口改为8002然后重新启动独角兽</em></p></li><li><h4 id="修改nginx默认端口"><a href="#修改nginx默认端口" class="headerlink" title="修改nginx默认端口"></a>修改nginx默认端口</h4><p>#<strong>vi /etc/nginx/sites-enabled/default</strong><br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/04.png" alt="图片04"></p></li><li><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><p><strong>service nginx restart</strong><br>访问<a href="http://192.168.99.100:81/" target="_blank" rel="noopener">http://192.168.99.100:81/</a><br><img src="/2018/11/22/django-deploy-Nginx-Gunicorn-supervisor/05.png" alt="图片05"></p></li></ol><h3 id="四-安装supervisor"><a href="#四-安装supervisor" class="headerlink" title="四 安装supervisor"></a>四 安装supervisor</h3><p># <strong>apt-get install -y supervisor</strong></p><ol><li><h4 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h4><p># <strong>rm /etc/supervisor/supervisord.conf</strong><br># <strong>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</strong></p></li><li><h4 id="修改默认配置文件"><a href="#修改默认配置文件" class="headerlink" title="修改默认配置文件"></a>修改默认配置文件</h4><p><strong>/tmp/supervisor.sock -&gt; /var/run/supervisor.sock</strong>  #12行<br><strong>/tmp/supervisord.log -&gt; /var/log/supervisord.log</strong>   #24行<br><strong>/tmp/supervisord.pid -&gt; /var/run/supervisord.pid</strong>   #28行<br><strong>unix:///tmp/supervisor.sock -&gt; unix:///var/run/supervisor.sock</strong>  #48行<br><strong>[include]</strong> 去掉前面的分号  #140行<br><strong>files = relative/directory/*.ini 去掉前面的分号并修改为files = /etc/supervisor/conf.d/*.conf</strong>   #141行0</p></li><li><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><p># <strong>chmod -R 777 /var/run<br># chmod -R 777 /var/log</strong></p></li><li><h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><p>&emsp;&emsp;Superviosr通过配置文件来设置被监管的程序，一般配置文件都放置在/etc/supervisor/conf.d路径下面，此处我们创建一个名为djangopro.conf的配置文件<br># <strong>vi /etc/supervisor/conf.d/djangopro.conf</strong>进入添加以下信息,注意项目路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:MyServer]</span><br><span class="line">command = gunicorn -c /www/MyServer/MyServer/gunicorn.conf.py MyServer.wsgi:application</span><br><span class="line">user = root</span><br><span class="line">autostart=true ;</span><br><span class="line">autorestart=true ;</span><br><span class="line">startretries=10 ;</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile = /www/MyServer/logs/robot.log</span><br><span class="line">stderr_logfile=/www/MyServer/logs/err.log</span><br></pre></td></tr></table></figure></li><li><h4 id="启动Supervisor"><a href="#启动Supervisor" class="headerlink" title="启动Supervisor"></a>启动Supervisor</h4><p>&emsp;&emsp;<strong>关闭supervisor服务，没有启动不用执行</strong><br># <strong>supervisorctl shutdown</strong><br><strong>下面命令需要在项目根目录下执行</strong><br><strong>cd /www/DjangoPro</strong> 进入django项目<br><strong>supervisord -c /etc/supervisor/supervisord.conf</strong> #启动</p></li><li><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>ps aux | grep gunicorn</strong> 查看独角兽运行信息<br><strong>ps aux | grep supervisor</strong> 查看supervisor运行信息<br><strong>kill -9 某一个gunicorn进程id</strong> 杀死某个进程<br><strong>ps -ax</strong> 查看所有进程<br><strong>结果；即便强制杀死gunicorn，supervisor依然会自动重启</strong></p></li><li><h4 id="Supervisor其它命令"><a href="#Supervisor其它命令" class="headerlink" title="Supervisor其它命令"></a>Supervisor其它命令</h4><p><strong>supervisorctl start programxxx</strong> 启动某个进程<br><strong>supervisorctl restart programxxx</strong> 重启某个进程<br><strong>supervisorctl stop groupworker</strong>: 重启所有属于名为groupworker这个分组的进程(start,restart同理)<br><strong>supervisorctl stop all</strong> 停止全部进程，注：start、restart、stop都不会载入最新的配置文件。<br><strong>supervisorctl reload</strong> 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。<br><strong>supervisorctl update</strong> 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-前景简介&quot;&gt;&lt;a href=&quot;#一-前景简介&quot; class=&quot;headerlink&quot; title=&quot;一 前景简介&quot;&gt;&lt;/a&gt;一 前景简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Nginx是一款自由
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chenzqi.cn/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="docker" scheme="http://chenzqi.cn/tags/docker/"/>
    
      <category term="项目" scheme="http://chenzqi.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Django发送携带随机验证码邮件 邮箱找回密码</title>
    <link href="http://chenzqi.cn/2018/11/06/send-email/"/>
    <id>http://chenzqi.cn/2018/11/06/send-email/</id>
    <published>2018-11-06T13:08:09.000Z</published>
    <updated>2018-12-02T01:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：</strong></p><ul><li>通过邮件来确认用户注册</li><li>后台管理人员针对用户的反馈发送邮件</li><li>通过邮箱来重置用户密码</li></ul><h3 id="电子邮件系统"><a href="#电子邮件系统" class="headerlink" title="电子邮件系统"></a>电子邮件系统</h3><h5 id="在一个因特网电子邮件系统中，通常有三个组成部分："><a href="#在一个因特网电子邮件系统中，通常有三个组成部分：" class="headerlink" title="在一个因特网电子邮件系统中，通常有三个组成部分："></a>在一个因特网电子邮件系统中，通常有三个组成部分：</h5><ul><li>用户代理（User Agent）<br>比如一些第三方客户端，如foxmail，以及常用的浏览器</li><li>邮件服务器（Mail Server）<br>比如QQ邮箱的邮箱服务器，域名为stmp.qq.com</li><li>简单邮件传输协议（SMTP）<br>在邮件服务器中互相通讯所采取的协议</li></ul><h5 id="那么，这三个组成部分是如何运行的呢？"><a href="#那么，这三个组成部分是如何运行的呢？" class="headerlink" title="那么，这三个组成部分是如何运行的呢？"></a>那么，这三个组成部分是如何运行的呢？</h5><p>假设用户A通过用户代理（QQ邮箱）向用户B（163邮箱）发出了一封电子邮件，这个过程可以描述为：</p><ul><li>用户A的用户代理通过SMTP协议登陆QQ邮箱的邮件服务器，并将要发送的内容放在了QQ邮箱的邮件服务器的属于用户A的邮箱中。</li><li>QQ邮箱的邮件服务器通过SMTP协议向163邮箱的邮件服务器发送这封电子邮件。</li><li>163邮箱的邮件服务器在收到电子邮件之后根据邮件的头部得知接收者是用户B，将邮件放到了邮件服务器中属于用户B的邮箱中。</li><li>用户B在用户代理中登录了163的邮件服务器，并通过POP3或者IMAP等“拉”协议拉取邮件服务器中自己的邮件到用户代理中查看。（若是浏览器，可以通过HTTP协议向邮件服务器传送邮件或者拉取邮件）</li></ul><h5 id="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"><a href="#为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？" class="headerlink" title="为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？"></a>为什么不是用户A的用户代理直接向用户B的用户代理直接发送邮件，而要通过邮件服务器进行发送？</h5><p><strong>邮件服务器在邮件的传送与拉取中有两个重要作用：</strong></p><ol><li>尽可能的保证在任何时刻维持开机状态，接受来自其他邮件服务器的邮件传输。</li><li>当邮件发送失败后，继续尝试向对方邮件服务器发送，若邮件发送失败，通知用户代理。</li></ol><h3 id="Django配置"><a href="#Django配置" class="headerlink" title="Django配置"></a>Django配置</h3><h5 id="settings配置邮件信息"><a href="#settings配置邮件信息" class="headerlink" title="settings配置邮件信息"></a>settings配置邮件信息</h5><p><img src="/2018/11/06/send-email/01.png" alt=""></p><h5 id="models定义数据库字段信息"><a href="#models定义数据库字段信息" class="headerlink" title="models定义数据库字段信息"></a>models定义数据库字段信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class EmailRecard(models.Model):</span><br><span class="line"></span><br><span class="line">    code = models.CharField(max_length=50, null=False, verbose_name=&apos;验证码&apos;)</span><br><span class="line">    email = models.EmailField(max_length=100, null=False, verbose_name=&apos;收件人邮箱&apos;)</span><br><span class="line">    # 邮件发送的时间</span><br><span class="line">    # auto_now_add 当创建对象时，自动获取当前之间进行赋值</span><br><span class="line">    send_time = models.DateTimeField(auto_now_add=True, verbose_name=&apos;发送时间&apos;)</span><br><span class="line">    # 邮件类型 register 注册    forget 找回密码</span><br><span class="line">    # choices 选项， 规定好选项，该属性值只能是选项中的某一个</span><br><span class="line">    # default 默认值</span><br><span class="line">    email_type = models.CharField(max_length=10, choices=((&apos;register&apos;, &apos;注册账号&apos;), (&apos;forget&apos;, &apos;找回密码&apos;)), default=&apos;register&apos;, verbose_name=&apos;邮件类型&apos;)</span><br><span class="line">    # 过期时间</span><br><span class="line">    expire_time = models.DateTimeField(verbose_name=&apos;过期时间&apos;)</span><br><span class="line">    # 邮件状态，邮件是否已使用</span><br><span class="line">    email_status = models.IntegerField(choices=((1, &apos;已使用&apos;), (0, &apos;未使用&apos;)), default=0, verbose_name=&apos;邮件状态&apos;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &apos;email_recard&apos;</span><br><span class="line">        # 在后台管理界面中显示名称</span><br><span class="line">        verbose_name = &apos;邮件&apos;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><h5 id="定义email-send发送邮件文件"><a href="#定义email-send发送邮件文件" class="headerlink" title="定义email_send发送邮件文件"></a>定义email_send发送邮件文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import datetime</span><br><span class="line"># 导入发送邮件模块</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from UserProject import settings</span><br><span class="line">from .models import EmailRecard</span><br><span class="line"></span><br><span class="line">def random_code(length=16):</span><br><span class="line">    # 随机产生验证码函数</span><br><span class="line">    string = &apos;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890&apos;</span><br><span class="line">    # 随机生成验证码</span><br><span class="line">    code = &apos;&apos;.join([string[random.randint(0, len(string)-1)] for x in range(length)])</span><br><span class="line"></span><br><span class="line">    return code</span><br><span class="line"></span><br><span class="line">def mail_send(to_email, type=&apos;register&apos;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    to_email: 接收邮件的email地址</span><br><span class="line">    type: 邮件类型 register 注册邮件</span><br><span class="line">                   forget 找回密码</span><br><span class="line">    :return: True 发送成功 </span><br><span class="line">             False 发送失败</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    email_recard = EmailRecard()</span><br><span class="line">    # 验证码</span><br><span class="line">    email_recard.code = random_code()</span><br><span class="line">    email_recard.email = to_email</span><br><span class="line">    email_recard.email_type = type</span><br><span class="line">    # 过期时间  获取7天之后的时间</span><br><span class="line">    email_recard.expire_time = datetime.datetime.now() + datetime.timedelta(days=7)</span><br><span class="line"></span><br><span class="line">    if type == &apos;register&apos;:</span><br><span class="line">        message = f&apos;注册成功，点击&lt;a href=&quot;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/active/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;激活账户！&apos;</span><br><span class="line">        subject = &apos;注册测试邮件&apos;</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        # 找回密码邮件</span><br><span class="line">        message = f&apos;找回密码邮件，点击链接&lt;a href=&quot;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&quot;&gt;&lt;strong&gt;http://127.0.0.1:8000/user/modify/&#123;email_recard.code&#125;&lt;/strong&gt;&lt;/a&gt;修改您的密码!&apos;</span><br><span class="line">        subject = &apos;找回密码测试邮件&apos;</span><br><span class="line">        </span><br><span class="line">    try:</span><br><span class="line">        result = send_mail(subject, message, settings.EMAIL_HOST_USER, [to_email], html_message=message)</span><br><span class="line">        if result == 1:</span><br><span class="line">            # 保存数据到数据库</span><br><span class="line">            email_recard.save()</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">            </span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"># 测试部分</span><br><span class="line"># if __name__ == &apos;__main__&apos;:</span><br><span class="line">#</span><br><span class="line">#     # 获取7天之后的时间</span><br><span class="line">#     print(datetime.datetime.now())</span><br><span class="line">#     print(datetime.timedelta(days=7))</span><br><span class="line">#     print(datetime.datetime.now()+ datetime.timedelta(days=7))</span><br></pre></td></tr></table></figure><h5 id="在views中导入自定义的发送邮件文件"><a href="#在views中导入自定义的发送邮件文件" class="headerlink" title="在views中导入自定义的发送邮件文件"></a>在views中导入自定义的发送邮件文件</h5><p><strong>注意路径是否跟当前文件同级</strong><br><img src="/2018/11/06/send-email/03.png" alt=""><br><strong>等表单验证完成，信息确认后，调用邮件函数，并更改数据库密码和邮件状态,最后保存，如下：</strong><br><img src="/2018/11/06/send-email/02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在日常开发中，通过程序来实现对邮箱的操作是一个很常见的应用场景。比如：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过邮件来确认用户注册&lt;/li&gt;
&lt;li&gt;后台管理人员针对用户的反馈发送邮件&lt;/li&gt;
&lt;li&gt;通过邮箱来重置用户密码&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="邮件&amp;Django" scheme="http://chenzqi.cn/categories/%E9%82%AE%E4%BB%B6-Django/"/>
    
    
      <category term="发送邮件" scheme="http://chenzqi.cn/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
      <category term="Django" scheme="http://chenzqi.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>python常用函数集</title>
    <link href="http://chenzqi.cn/2018/10/23/common-function/"/>
    <id>http://chenzqi.cn/2018/10/23/common-function/</id>
    <published>2018-10-23T13:53:39.000Z</published>
    <updated>2018-11-23T22:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="参数-args和-kwargs的区别"><a href="#参数-args和-kwargs的区别" class="headerlink" title="参数*args和**kwargs的区别"></a>参数*args和**kwargs的区别</h5><p>*args 不定长参数，传入函数中是一个元组<br>**kwargs 不定长关键字参数，以key=value形式传递参数，传入函数中是一个字典</p><h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5><h6 id="Strip-去除字符串两端空格-只能删除开头或是结尾的字符"><a href="#Strip-去除字符串两端空格-只能删除开头或是结尾的字符" class="headerlink" title="Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)"></a>Strip( )  去除字符串两端空格(只能删除开头或是结尾的字符)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;00000003210Runoob01230000000&quot;; </span><br><span class="line">print(str.strip(&apos;0&apos;))  # 去除首尾字符 0</span><br><span class="line"> </span><br><span class="line">str2 = &quot;   Runoob      &quot;;   # 去除首尾空格</span><br><span class="line">print str2.strip();</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3210Runoob0123</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure></p><h6 id="Upper-转大写"><a href="#Upper-转大写" class="headerlink" title="Upper( ) 转大写"></a>Upper( ) 转大写</h6><h6 id="Lower-转小写"><a href="#Lower-转小写" class="headerlink" title="Lower( ) 转小写"></a>Lower( ) 转小写</h6><h6 id="Find-查找子串开始位置"><a href="#Find-查找子串开始位置" class="headerlink" title="Find( )  查找子串开始位置"></a>Find( )  查找子串开始位置</h6><h6 id="Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次"><a href="#Replace-替换-把字符串中的-旧字符串-替换成-新字符串-如果指定第三个参数max-则替换不超过max次" class="headerlink" title="Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次"></a>Replace( ) 替换 把字符串中的(旧字符串)替换成(新字符串),如果指定第三个参数max,则替换不超过max次</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;this is string example....wow!!! this is really string&quot;;</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;))</span><br><span class="line">print(str.replace(&quot;is&quot;, &quot;was&quot;, 3))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thwas was string example....wow!!! thwas was really string</span><br><span class="line">thwas was string example....wow!!! thwas is really string</span><br></pre></td></tr></table></figure><h6 id="Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串"><a href="#Split-切片-通过指定分隔符对字符串进行切片，如果参数-num-有指定值，则仅分隔-num-个子字符串" class="headerlink" title="Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串"></a>Split( ) 切片 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;</span><br><span class="line">print(str.split( ))</span><br><span class="line">print(str.split(&apos; &apos;, num = 1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Line1-abcdef&apos;, &apos;Line2-abc&apos;, &apos;Line4-abcd&apos;]</span><br><span class="line">[&apos;Line1-abcdef&apos;, &apos;\nLine2-abc \nLine4-abcd&apos;]</span><br></pre></td></tr></table></figure><h6 id="Join-将序列中的元素以指定的字符连接生成一个新的字符串"><a href="#Join-将序列中的元素以指定的字符连接生成一个新的字符串" class="headerlink" title="Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串"></a>Join( ) 将序列中的元素以指定的字符连接生成一个新的字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.join(元组、列表、字典、字符串) 之后生成的只能是字符串。</span><br><span class="line">所以很多地方很多时候生成了元组、列表、字典后，可以用 join() 来转化为字符串</span><br><span class="line">list=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]</span><br><span class="line">print(&apos;&apos;.join(list))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure><h6 id="map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中"><a href="#map-根据提供的函数对指定序列做映射-并将执行函数返回的结果放入新的列表中" class="headerlink" title="map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中"></a>map( ) 根据提供的函数对指定序列做映射,并将执行函数返回的结果放入新的列表中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure><h6 id="filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中"><a href="#filter-函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表-让可迭代对象中的每一个元素都执行一次某个函数-并将函数返回为真-不是None、空字符串、0、False-的数据放入新的迭代器对象中" class="headerlink" title="filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中"></a>filter( ) 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表;让可迭代对象中的每一个元素都执行一次某个函数,并将函数返回为真(不是None、空字符串、0、False)的数据放入新的迭代器对象中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><h6 id="Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数"><a href="#Reduce-让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果-这个函数必须接收两个参数" class="headerlink" title="Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数"></a>Reduce( ) 让可迭代对象中的每两个个元素都执行一次某个函数，并将执行结果和下一个元素进行再次运算，直至没有元素为止，返回的是一个结果,这个函数必须接收两个参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">print(reduce(add, [1, 3, 5, 7, 9]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h6 id="math-数字函数"><a href="#math-数字函数" class="headerlink" title="math( )数字函数"></a>math( )数字函数</h6><ul><li><p>math.pow(x, y) 返回x的y次方 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.sqrt(3)</span><br><span class="line">1.7320508075688772</span><br></pre></td></tr></table></figure></li><li><p>math.ceil(x)    返回不小于x的整数     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.ceil(5.2)</span><br><span class="line">6.0</span><br></pre></td></tr></table></figure></li><li><p>math.floor(x)    返回不大于x的整数    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.floor(5.8)</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure></li><li><p>math.trunc(x)    返回x的整数部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.trunc(5.8)</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>math.fmod(x, y) 返回x%y（取余）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; math.fmod(5,2)</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure></li></ul><h5 id="assert-断言方法"><a href="#assert-断言方法" class="headerlink" title="assert()断言方法"></a>assert()断言方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">assert(a&gt;1)</span><br><span class="line">print(&quot;断言成功，向下执行&quot;)</span><br><span class="line"></span><br><span class="line">b = 4</span><br><span class="line">assert(b&gt;7)</span><br><span class="line">print(&quot;断言失败，程序报错&quot;)</span><br></pre></td></tr></table></figure><hr><p><strong>计算1到100的和,以下两种都可以</strong></p><ul><li>sum(range(1,101)) </li><li>reduce(lambda x,y:x+y, [x for x in range(1,101)])</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;参数-args和-kwargs的区别&quot;&gt;&lt;a href=&quot;#参数-args和-kwargs的区别&quot; class=&quot;headerlink&quot; title=&quot;参数*args和**kwargs的区别&quot;&gt;&lt;/a&gt;参数*args和**kwargs的区别&lt;/h5&gt;&lt;p&gt;*arg
      
    
    </summary>
    
      <category term="随记" scheme="http://chenzqi.cn/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CSV文件存储</title>
    <link href="http://chenzqi.cn/2018/10/14/csv/"/>
    <id>http://chenzqi.cn/2018/10/14/csv/</id>
    <published>2018-10-14T06:59:04.000Z</published>
    <updated>2018-12-02T02:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号或制表符。不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。它比Excel文件更加简介，XLS文本是电子表格，它包含了文本、数值、公式和格式等内容，而CSV中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰。所以，有时候用CSV来保存数据是比较方便的。本讲解Pyhon读取和写入CSV文件的过程。</strong></p><h4 id="1-写入"><a href="#1-写入" class="headerlink" title="1.写入"></a>1.写入</h4><p>首先，打开data.csv文件，然后指定打开的模式为w（即写入），获得文件句柄，随后调用csv库的writer()方法初始化写入对象，传入该句柄，然后调用writerow()方法传入每行的数据即可完成写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow([&apos;id&apos;, &apos;name&apos;, &apos;age&apos;])</span><br><span class="line">    writer.writerow([&apos;10001&apos;, &apos;Mike&apos;, 20])</span><br><span class="line">    writer.writerow([&apos;10002&apos;, &apos;Bob&apos;, 22])</span><br><span class="line">    writer.writerow([&apos;10003&apos;, &apos;Jordan&apos;, 21])</span><br></pre></td></tr></table></figure></p><p>运行结束后，会生成一个名为data.csv的文件，此时数据就成功写入了。直接以文本形式打开的话，其内容如下<br><img src="/2018/10/14/csv/02.png" alt=""><br>可以看到，写入的文本默认以逗号分隔，调用一次writerow()方法即可写入一行数据。用Excel打开的结果如下<br><img src="/2018/10/14/csv/01.png" alt=""><br>一般情况下，爬虫爬取的都是结构化数据，我们一般会用字典来表示。在csv库中也提供了字典的写入方式，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;w&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10001&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 20&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10002&apos;, &apos;name&apos;: &apos;Bob&apos;, &apos;age&apos;: 22&#125;)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10003&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 21&#125;)</span><br></pre></td></tr></table></figure></p><p>这里先定义3个字段，用fieldnames表示，然后将其传给DictWriter来初始化一个字典写入对象，接着可以调用writeheader()方法先写入头信息，然后再调用writerow()方法传入相应字典即可。最终写入的结果是完全相同的<br>另外，如果想追加写入的话，可以修改文件的打开模式，即将open()函数的第二个参数改成a，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10004&apos;, &apos;name&apos;: &apos;Durant&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>这样在上面的基础上再执行这段代码，新行会添加成功,如下：<br><img src="/2018/10/14/csv/03.png" alt=""><br>如果要写入中文内容的话，可能会遇到字符编码的问题，此时需要给open()参数指定编码格式。比如，这里再写入一行包含中文的数据，代码需要改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"> </span><br><span class="line">with open(&apos;data.csv&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;, newline=&apos;&apos;) as csvfile:</span><br><span class="line">    fieldnames = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    writer.writerow(&#123;&apos;id&apos;: &apos;10005&apos;, &apos;name&apos;: &apos;王伟&apos;, &apos;age&apos;: 22&#125;)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/04.png" alt=""></p><h4 id="2-读取"><a href="#2-读取" class="headerlink" title="2.读取"></a>2.读取</h4><p>我们同使用csv库来读取CSV文件。例如，将刚才写入的文件内容读取出来，相关代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&apos;data.csv&apos;,&apos;r&apos;, encoding=&apos;utf-8&apos;) as csvfile:</span><br><span class="line">    # 调用csv模块的reader函数读文件</span><br><span class="line">    lines = csv.reader(csvfile)</span><br><span class="line">    for line in lines:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="/2018/10/14/csv/05.png" alt=""><br>另外，如果接触过pandas的话，可以利用read_csv()方法将数据从CSV中读取出来，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas  as pd</span><br><span class="line"> </span><br><span class="line">df = pd.read_csv(&apos;data.csv&apos;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="/2018/10/14/csv/06.png" alt=""><br>在做数据分析的时候，此种方法用得比较多，也是一种比较方便地读取CSV文件的方法。<br>本文讲述了解了CSV文件的写入和读取方式。这也是一种常用的数据存储方式，需要熟练掌握</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chenzqi.cn/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据存储" scheme="http://chenzqi.cn/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy中将数据异步写入MYSQL数据库</title>
    <link href="http://chenzqi.cn/2018/10/11/AsyncToSql/"/>
    <id>http://chenzqi.cn/2018/10/11/AsyncToSql/</id>
    <published>2018-10-11T07:32:28.000Z</published>
    <updated>2018-12-02T01:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…"><a href="#在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些代码写在pipelines中…" class="headerlink" title="在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…"></a><strong>在开始使用scrapy框架爬虫的时候,将爬取的数据是使用同步写入数据库;进一步学习,同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库,而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性;这些代码写在pipelines中…</strong></h4><p><strong>在pipelines中可以自定义图片、文件下载保存路径,保存json、excel、sqlite、异步写入mysql数据库等</strong></p><ul><li>首先在settings中配置连接MYSQL的参数,如下图<br><img src="/2018/10/11/AsyncToSql/01.png" alt="图片失踪"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># 异步写入数据库</span><br><span class="line"># adbapi 专门用于异步操作数据库的模块</span><br><span class="line">from twisted.enterprise import adbapi</span><br><span class="line"># DictCursor 游标类型</span><br><span class="line">from pymysql.cursors import DictCursor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TwistedMysqlPipeline(object):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    1.链接数据，获取游标</span><br><span class="line">    2.准备sql语句，执行sql</span><br><span class="line">    3.提交操作，关闭游标，关闭数据库</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    # 在调用TwistedMysqlPipeline时，第一个调用该函数</span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line"></span><br><span class="line">        pramars = dict(</span><br><span class="line">            host=settings[&apos;MYSQL_HOST&apos;],</span><br><span class="line">            port=settings[&apos;MYSQL_PORT&apos;],</span><br><span class="line">            user=settings[&apos;MYSQL_USER&apos;],</span><br><span class="line">            password=settings[&apos;MYSQL_PASSWORD&apos;],</span><br><span class="line">            db=settings[&apos;MYSQL_DB&apos;],</span><br><span class="line">            charset=settings[&apos;MYSQL_CHARSET&apos;],</span><br><span class="line">            use_unicode=True,</span><br><span class="line">            cursorclass=DictCursor</span><br><span class="line">        )</span><br><span class="line">        # 连接池</span><br><span class="line">        # 1.使用的第三方操作mysql的包</span><br><span class="line">        # 2.链接mysql需要的参数</span><br><span class="line">        db_pool = adbapi.ConnectionPool(&apos;pymysql&apos;, **pramars)</span><br><span class="line">        # 返回当前类的对象，并且把db_pool作为参数传递到初始化函数中</span><br><span class="line">        return cls(db_pool)</span><br><span class="line"></span><br><span class="line">    def __init__(self, db_pool):</span><br><span class="line">        # 将db_pool赋值给self.db_pool属性，在process_item函数中就可以使用db_pool</span><br><span class="line">        self.db_pool = db_pool</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line"></span><br><span class="line">        # 将写入数据库的操作放入链接池中</span><br><span class="line">        # 参数1.要异步执行的操作</span><br><span class="line">        # 参数2.异步执行操作需要的参数</span><br><span class="line">        result = self.db_pool.runInteraction(self.insert_item, item)</span><br><span class="line"></span><br><span class="line">        # 给执行结果添加错误回调函数</span><br><span class="line">        result.addErrback(self.sql_faild, item)</span><br><span class="line"></span><br><span class="line">        # 交给下一个pipeline继续进行处理</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def sql_faild(self, fail, item):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param fail: 错误原因</span><br><span class="line">        :param item: 执行sql错误的数据</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(fail)</span><br><span class="line">        print(&apos;出现问题的数据&#123;&#125;&apos;.format(item))</span><br><span class="line"></span><br><span class="line">    def insert_item(self, cursor, item):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        操作数据写入的函数</span><br><span class="line">        :param cursor: 游标,自动传入</span><br><span class="line">        :param item: 要写入的数据</span><br><span class="line">        :return:</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        sql = &apos;INSERT INTO ivsky(alt,src)VALUES(%s,%s)&apos;</span><br><span class="line">        cursor.execute(sql,(item[&apos;alt&apos;], item[&apos;src&apos;]))</span><br></pre></td></tr></table></figure></li></ul><p><strong>大概步骤如下</strong></p><ol><li>在settings中配置Mysql链接需要的参数</li><li>自定义Pipeline，实现from_settings函数</li><li>from twisted.enterprise import adbapi 引入连接池模块</li><li>from pymysql import cursors 引入游标模块</li><li>在from_settings中，准备链接数据库参数，创建db_pool连接池，创建返回当前类的对象，传入db_pool</li><li>实现初始化函数,在初始化函数中,将db_pool赋值self的属性</li><li>实现process_item函数<br> 7.1 query = self.db_pool.runInteraction(执行插入数据操作的函数对象，函数需要参数)，并接受执行返回结果<br> 7.2 query.addErrback(错误回调函数，函数需要参数)，添加执行sql失败回调的函数，在回调函数中对错误数据进一步处理 </li><li>实现插入数据操作的函数，准备sql，执行sql</li><li>实现错误回调函数，在回调函数中对错误数据进一步处理 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在开始使用scrapy框架爬虫的时候-将爬取的数据是使用同步写入数据库-进一步学习-同步写入速度比较慢，而爬虫速度比较快，有可能导致数据保存不完整，一部分数据没有入库-而异步可以将爬虫和写入数据库操作分开执行，互不影响，所以写入速度比较快，可以保证数据完整性-这些
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chenzqi.cn/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
      <category term="数据库" scheme="http://chenzqi.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="爬虫" scheme="http://chenzqi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之(Terminal)创建数据库,通过代码对数据表、数据的基本操作</title>
    <link href="http://chenzqi.cn/2018/09/30/PyMysql/"/>
    <id>http://chenzqi.cn/2018/09/30/PyMysql/</id>
    <published>2018-09-30T07:28:34.000Z</published>
    <updated>2018-12-02T02:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"><a href="#MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本" class="headerlink" title="MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL官方文档下载对应版本"></a><em>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性,PyMySQL是在python3版本中用于连接MySQL服务器的一个库,Python2中则使用mysqldb;据我了解PyMySQL是mysqldb的替代版本…操作MYSQL<a href="https://dev.mysql.com/downloads/shell/" target="_blank" rel="noopener">官方文档</a>下载对应版本</em></h4><h2 id="一-使用终端命令创建数据库"><a href="#一-使用终端命令创建数据库" class="headerlink" title="一.使用终端命令创建数据库"></a>一.使用终端命令创建数据库</h2><ul><li>在python代码连接数据库前，先要确认是否已经创建了数据库<br>Terminal输入命令<strong>mysql -u用户 -p密码</strong>进入mysql<br><img src="/2018/09/30/PyMysql/01.png" alt="图片旅游中..."></li><li>使用<strong>create database dbname</strong>命令(create)创建数据库<br><img src="/2018/09/30/PyMysql/02.png" alt="图片旅游中..."></li><li>使用<strong>show databases</strong>命令(show)查看所有数据库<br><img src="/2018/09/30/PyMysql/03.png" alt="图片旅游中..."><br>数据库创建完成,接着通过python代码操作</li></ul><h2 id="二-数据库CRUD-增删改查-操作"><a href="#二-数据库CRUD-增删改查-操作" class="headerlink" title="二.数据库CRUD(增删改查)操作"></a>二.数据库CRUD(增删改查)操作</h2><ul><li><p>先cmd输入<strong>pip install pymysql</strong>安装pymysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pymysql  #导入pymysql</span><br><span class="line"> </span><br><span class="line">#打开数据库连接</span><br><span class="line">connect= pymysql.connect(</span><br><span class="line">host=&quot;127.0.0.1&quot;, #主机IP</span><br><span class="line">user=&quot;root&quot;, #用户</span><br><span class="line"> password=&quot;123456&quot;,#密码</span><br><span class="line"> db=&quot;test&quot;,#数据库</span><br><span class="line"> port=3307#数据库默认端口</span><br><span class="line"> )</span><br><span class="line"> #这些只是连接数据库少不了的一些参数,参数还有很多</span><br><span class="line">#使用cursor()方法获取操作游标,接下来的操作操作需要游标执行 </span><br><span class="line">cursor = connect.cursor()</span><br></pre></td></tr></table></figure></li><li><p>创建一个不存在的表/结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = &apos;CREATE TABLE if not exists dbname(id integer primary key unique, name CHAR(20) NOT NULL,age INT)&apos;</span><br><span class="line">#游标执行sql</span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert_sql = &apos;INSERT INTO dbname(name,age)VALUES (&apos;李易峰&apos;, 20)&apos;</span><br><span class="line">#游标执行insert_sql</span><br><span class="line">cursor.execute(insert_sql)</span><br></pre></td></tr></table></figure></li><li><p>查询匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有</span><br><span class="line">select_table = &quot;SELECT * from dbname&quot;</span><br><span class="line">cursor.execute(select_table)</span><br><span class="line"></span><br><span class="line"># 设置匹配条件</span><br><span class="line"># where: 指定条件</span><br><span class="line"># like：主要用于匹配数据库中的多条记录</span><br><span class="line"># a_：以a开头的记录，并且仅匹配a后一个字符的数据</span><br><span class="line"># %a%：数据中包含a的数据</span><br><span class="line"># %a：以a结尾的数据</span><br><span class="line"># a%：匹配以a开头的数据</span><br><span class="line"># 比如查询学生数据库所有以李开头的学生信息</span><br><span class="line">select_sql = &apos;SELECT * from dbname where like &quot;李%&quot;&apos;</span><br><span class="line">cursor.execute(select_sql)</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update_sql = &quot;UPDATE dbname SET age=&apos;%s&apos;&quot;%(&apos;18&apos;)</span><br><span class="line">cursor.execute(update_sql)</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete_sql = &quot;DELETE from dbname where name=&apos;李四&apos;&quot;</span><br><span class="line">cursor.execute(delete_sql)</span><br></pre></td></tr></table></figure></li><li><p>关闭数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交操作</span><br><span class="line">connect.commit()</span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"># 关闭数据库</span><br><span class="line">connect.close()</span><br></pre></td></tr></table></figure></li></ul><blockquote><blockquote><p><strong>每次操作数据库后需要提交/关闭数据库;对于我们来说对数据库最多的操作是添加与查询</strong></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性-PyMySQL是在python3版本中用于连接MySQL服务器的一个库-Python2中则使用mysqldb-据我了解PyMyS
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chenzqi.cn/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://chenzqi.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy基于scrapy_redis部署分布式爬虫</title>
    <link href="http://chenzqi.cn/2018/09/28/scrapy-redis/"/>
    <id>http://chenzqi.cn/2018/09/28/scrapy-redis/</id>
    <published>2018-09-28T12:51:03.000Z</published>
    <updated>2018-12-02T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-scrapy-redis简介"><a href="#一-scrapy-redis简介" class="headerlink" title="一. scrapy-redis简介"></a>一. scrapy-redis简介</h4><p><strong>scrapy-redis是scrapy框架基于redis数据库的组件，用于scrapy项目的分布式开发和部署</strong></p><ul><li>分布式爬取<br>可以启动多个spider工程，相互之间共享单个redis的requests队列。最适合广泛的多个域名网站的内容爬取</li><li>分布式数据处理<br>爬取到的scrapy的item数据可以推入到redis队列中，这意味着你可以根据需求启动尽可能多的处理程序来共享item的队列，进行item数据持久化处理</li><li>Scrapy即插即用组件<br>Scheduler调度器 + Duplication复制 过滤器，Item Pipeline，基本spider</li></ul><h4 id="二-安装配置"><a href="#二-安装配置" class="headerlink" title="二. 安装配置"></a>二. 安装配置</h4><ol><li><strong>使用命令行工具输入pip3 install scrapy_redis下载工具包 scrapy_redis</strong><br><img src="/2018/09/28/scrapy-redis/01.png" alt=""></li><li><strong>打开爬虫项目,找到settings全局配置文件,配置scrapy项目使用的调度器及过滤器信息</strong><br><img src="/2018/09/28/scrapy-redis/02.png" alt=""></li><li><strong>上面是将配置信息配写在settings全局配置文件中，如果一个项目中有多个爬虫，想要将每个爬取数据存入不同的数据库或者其他不需要全局配置的信息，可以将配置信息写入当前爬虫文件中，如下：</strong><br><img src="/2018/09/28/scrapy-redis/09.png" alt=""></li><li><strong>修改spider爬虫文件,首先要引入一个scrapy_redis.spider文件中的一个RedisSpider类,然后把spider爬虫文件原来继承的scrapy.Spider类改为引入的RedisSpider这个类</strong><br><img src="/2018/09/28/scrapy-redis/03.png" alt=""></li><li><strong>在redis安装目录下修改redis配置文件，后缀为conf的文件，将bing 127.0.0.1 改为 bing 0.0.0.0，允许其他电脑ip连接，如下：</strong><br><img src="/2018/09/28/scrapy-redis/10.png" alt=""></li><li><strong>如果连接的有远程服务,例如MySQL,Redis等,需要将远程服务连接开启,保证在其他主机上能够成功连接,才能将数据写入主机数据库</strong><br><img src="/2018/09/28/scrapy-redis/04.png" alt=""><br><img src="/2018/09/28/scrapy-redis/06.png" alt=""></li><li><strong>启动redis服务</strong><br><img src="/2018/09/28/scrapy-redis/11.png" alt=""></li><li><strong>将主机爬虫启动起来,然后启动其他服务器爬虫，所有爬虫会处于等待状态</strong><br>输入以下命令<br><img src="/2018/09/28/scrapy-redis/08.png" alt=""></li></ol><h4 id="三-分布式逻辑分析"><a href="#三-分布式逻辑分析" class="headerlink" title="三. 分布式逻辑分析"></a>三. 分布式逻辑分析</h4><p><strong>分布式用到的代码基本就是同一套代码</strong></p><ol><li>先把项目配置为分布式</li><li>把项目拷贝到多台服务器中</li><li>把所有爬虫项目都跑起来</li><li>在主redis-cli中lpush你的网址即可</li><li>效果：所有爬虫都开始运行，并且数据不重复</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-scrapy-redis简介&quot;&gt;&lt;a href=&quot;#一-scrapy-redis简介&quot; class=&quot;headerlink&quot; title=&quot;一. scrapy-redis简介&quot;&gt;&lt;/a&gt;一. scrapy-redis简介&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;scra
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chenzqi.cn/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
      <category term="爬虫" scheme="http://chenzqi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="部署" scheme="http://chenzqi.cn/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>scrapyd部署爬虫项目</title>
    <link href="http://chenzqi.cn/2018/09/27/scrapyd-bushu/"/>
    <id>http://chenzqi.cn/2018/09/27/scrapyd-bushu/</id>
    <published>2018-09-27T13:19:07.000Z</published>
    <updated>2018-12-02T01:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…"><a href="#scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…" class="headerlink" title="scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…"></a><em>scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便.scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大,下面就是介绍scrapyd的安装与使用…</em></h4><hr><h2 id="一-安装-配置scrapyd"><a href="#一-安装-配置scrapyd" class="headerlink" title="一. 安装/配置scrapyd"></a>一. 安装/配置scrapyd</h2><ul><li>打开命令行工具执行<strong>pip install scrapyd</strong><br><img src="/2018/09/27/scrapyd-bushu/01.png" alt=""></li><li>输入scrapyd启动scrapyd服务<br><img src="/2018/09/27/scrapyd-bushu/02.png" alt=""></li><li>浏览器输入127.0.0.1:6800,如下图启动成功<br><img src="/2018/09/27/scrapyd-bushu/03.png" alt=""></li><li>在非C盘下创建一个scrapydTest(自定义)文件夹,此文件夹是用来部署爬虫项目;命令行工具cd进入scrapydTest文件夹;输入scrapyd执行，执行完成后会自动新建一个dbs空文件夹，用来存放爬虫项目的数据文件;这个命令行工具一直处于运行状态,以下操作打开新命令行工具<br><img src="/2018/09/27/scrapyd-bushu/04.png" alt=""></li><li>安装scrapyd-client模块。scrapyd-client模块是专门打包scrapy爬虫项目到scrapyd服务中的，进入py环境，执行命令 <strong>pip install scrapy-client</strong>，安装完成后，在python安装目录的scripts文件夹中会出现scrapyd-deploy无后缀文件，这个scrapyd-deploy无后缀文件是启动文件，在Linux系统下可以远行，在windows下是不能运行的，所以我们需要编辑一下使其在windows可以运行<br><img src="/2018/09/27/scrapyd-bushu/06.png" alt=""></li><li>新建一个scrapyd-deploy.bat文件,如上图;右键选择编辑，输入以下配置<br>@echo off<br>“C:\Users\qianzhen\Envs\scrapySpider\Scripts\python.exe” “C:\Users\qianzhen\Envs\scrapySpider\Scripts\scrapyd-deploy” %1 %2 %3 %4 %5 %6 %7 %8 %9<br><img src="/2018/09/27/scrapyd-bushu/05.png" alt=""><br><strong>注意：两个路径之间是空格，一定要使用双引号。单引号的话会错误。两个路经是自己的python路经</strong></li></ul><h2 id="二-部署-启动项目"><a href="#二-部署-启动项目" class="headerlink" title="二.部署/启动项目"></a>二.部署/启动项目</h2><ul><li>编辑器打开爬虫项目中的scrapy.cfg文件，这个文件就是给scrapyd-deploy使用的<br>将url这行代码解掉注释，并且给设置你的部署名称<br><img src="/2018/09/27/scrapyd-bushu/08.png" alt=""></li><li>再次执行scrapyd-deploy -l 启动服务，可以看到设置的名称,接下来可以开始打包了<br><img src="/2018/09/27/scrapyd-bushu/09.png" alt=""></li><li>开始打包前，执行一个命令：scrapy list ,这个命令执行成功说明可以打包了,如果没执行成功,说明还有工作没完成;以上步骤没有出错,一般不会出现问题<br><img src="/2018/09/27/scrapyd-bushu/10.png" alt=""></li><li>如果错误提示，什么远程计算机拒绝，说明你的scrapy项目有链接远程计算机，如链接数据库或者elasticsearch(搜索引擎)之类的，需要先将链接服务器启动<br>执行 scrapy list  命令返回了爬虫名称说明一切ok了，如上图,继续go…</li><li>执行打包命令： scrapyd-deploy 部署名称 -p 项目名称<br>如：scrapyd-deploy tt -p mytest<br>如下显示表示scrapy项目打包成功,scrapydTest下egg文件夹中有项目即可<br><img src="/2018/09/27/scrapyd-bushu/11.png" alt=""></li><li>网页中127.0.0.1:6800查看是否部署到服务器<br><img src="/2018/09/27/scrapyd-bushu/12.png" alt=""></li><li>最后就是通过scrapyd命令(API)接口发送请求,比如通过请求启动刚部署服务器上的爬虫项目<br>命令输入:<strong>curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=项目名称 -d spider=爬虫名称</strong><br>如: curl <a href="http://127.0.0.1:6800/schedule.json" target="_blank" rel="noopener">http://127.0.0.1:6800/schedule.json</a> -d project=mytest -d spider=tt<br><img src="/2018/09/27/scrapyd-bushu/15.png" alt=""></li><li>jobs中查看爬虫状态<br><img src="/2018/09/27/scrapyd-bushu/14.png" alt=""></li></ul><ul><li><strong>其他请求接口可通过<a href="https://scrapyd.readthedocs.io/en/stable/api.html#" target="_blank" rel="noopener">官方文档</a>查看,如下图,全英文看不懂,没关系,有谷歌..;</strong><br><img src="/2018/09/27/scrapyd-bushu/13.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scrapy爬虫写好后，需要用命令行运行，如果能在网页上操作就比较方便-scrapyd部署就是为了解决这个问题，能够在网页端查看正在执行的任务，也能新建爬虫任务，和终止爬虫任务，功能比较强大-下面就是介绍scrapyd的安装与使用…&quot;&gt;&lt;a href=&quot;#scra
      
    
    </summary>
    
      <category term="项目&amp;部署" scheme="http://chenzqi.cn/categories/%E9%A1%B9%E7%9B%AE-%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
      <category term="部署" scheme="http://chenzqi.cn/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>知乎点赞最高的30句金句</title>
    <link href="http://chenzqi.cn/2018/07/02/zhihu/"/>
    <id>http://chenzqi.cn/2018/07/02/zhihu/</id>
    <published>2018-07-02T10:56:30.000Z</published>
    <updated>2018-12-02T03:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、夜半忽梦少年事，唯梦闲人不梦君。</strong></p><p>　　——原句出自白居易《琵琶行》（夜深忽梦少年事，梦啼妆泪红阑干。）</p><p><strong>2、你这么擅长安慰他人，一定度过了很多自己安慰自己的日子吧。</strong></p><p>　　——陈亚豪</p><p><strong>3、他走时，只有星光送他。</strong></p><p>　　——《那人走时只有星光送他》</p><p><strong>4、我们回不去了。</strong></p><p>　　——《半生缘》</p><p><strong>5、梦里不知身是客，一晌贪欢。</strong></p><p>　　——李煜</p><p><strong>6、母亲老了，扶墙走路，已踏不出脚步声。</strong></p><p>　　——毛小军</p><p><strong>7、树欲静而风不止，子欲养而亲不待。</strong></p><p>　　——《孔子家语·卷二，致思第八》</p><p><strong>8、所谓父子母女一场，只不过意味着你和他的缘分，就是今生今世不断地在目送他的背影渐行渐远。你站在小路的这一端，看着他消失在小路转弯的地方。他用背影默默地告诉你，不必追。</strong></p><p>　　——龙应台</p><p><strong>9、我很孤独用英语怎么说，”I Love You”</strong></p><p>　　————周星驰</p><p><strong>10、它们生命中的绝大多数时间，都要在冰冷的海洋上独自漂流而度过。</strong></p><p>　　——BBC的纪录片里对北极熊的描述</p><p><strong>11、那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行。如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。</strong></p><p>　　——北岛《波兰来客》</p><p><strong>12、老乡，我们中国人都投降了，还有中国吗？</strong></p><p>　　——抗日英雄杨靖宇</p><p><strong>13、我经常要对别人说“很高兴见到你”，尽管我见到他们根本不高兴。</strong></p><p>　　——《麦田守望者》</p><p><strong>14、雨声潺潺，像住在溪边，宁愿天天下雨，以为你是因为下雨不来。</strong></p><p>　　——《小团圆》</p><p><strong>15、从来如此，便对吗？</strong></p><p>　　——《狂人日记》</p><p><strong>16、越过山丘，才发现无人等候。</strong></p><p>　　——《山丘》</p><p><strong>17、你不知羞耻地索取，毫无感激地接受。</strong></p><p>　　——《王尔德狱中记》</p><p><strong>18、周芷若冷笑道：“咱们从前曾有婚姻之约，我丈夫此刻却是命在垂危，加之今日我没伤你性命，旁人定然说我对你旧情犹存。若再邀你相助，天下英雄人人要骂我不知廉耻、水性杨花。”张无忌急道：“咱们只须问心无愧，旁人言语，理他作甚？”周芷若道：“倘若我问心有愧呢？”</strong></p><p>　　——《倚天屠龙记》</p><p><strong>19、秋天短到没有，你我短到不能回头。</strong></p><p>　　——《冯唐诗百首》</p><p><strong>20、你最喜欢一个人的时候，常常都是你最不了解他的时候。</strong></p><p>　　——《龙族》</p><p><strong>21、是渴望教会了我什么叫卑躬屈膝。</strong></p><p>　　——《南音》</p><p><strong>22、某天，你无端想起一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里。</strong></p><p>　　——《再见金华站》</p><p><strong>23、老来多忘事，唯不忘相思。</strong></p><p>　　——《偶作寄朗之》</p><p><strong>24、不如意事常八九，可与人言无二三。</strong></p><p>　　——《别子才司令》</p><p><strong>25、一别两宽，各生欢喜。</strong></p><p>　　——《唐朝放妻协议》</p><p><strong>26、欲买桂花同载酒，终不似，少年游。</strong></p><p>　　——《唐多令·芦叶满汀洲》</p><p><strong>27、我是一个经常笑的人，可我不是一个经常开心的人。</strong></p><p><strong>28、高考差了一分，却隔了166个人。这166个人是1900KM的距离，是1000块的机票，三小时的飞行时间，四年的思念和一生的遗憾。</strong></p><p><strong>29、保持身体健康的唯一办法，就是吃点你不想吃的，喝点你不想喝的，以及做点你不愿做的事情。</strong></p><p>　　——马克·吐温</p><p><strong>30、五岁时，妈妈告诉我，人生的关键在于快乐。上学后，人们问我长大了要做什么，我写下“快乐”。他们告诉我，我理解错了题目，我告诉他们，他们理解错了人生。</strong></p><p>　　——约翰·列侬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、夜半忽梦少年事，唯梦闲人不梦君。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　——原句出自白居易《琵琶行》（夜深忽梦少年事，梦啼妆泪红阑干。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、你这么擅长安慰他人，一定度过了很多自己安慰自己的日子吧。&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="语录&amp;生活" scheme="http://chenzqi.cn/categories/%E8%AF%AD%E5%BD%95-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Scrapy框架设置随机请求头</title>
    <link href="http://chenzqi.cn/2018/06/11/RandomUA/"/>
    <id>http://chenzqi.cn/2018/06/11/RandomUA/</id>
    <published>2018-06-11T12:00:21.000Z</published>
    <updated>2018-12-02T02:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在settings中设置通用请求头(一般不用)<br><img src="/2018/06/11/RandomUA/02.png" alt="图片丢失..."></li><li>设置随机请求头先终端命令<strong>pip install fake_useragent</strong>下载第三方包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 导入第三方随机请求头模块包</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line"># 自定义随机请求头类</span><br><span class="line">class RandomUAMiddleware(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 创建随机请求头对象</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理请求</span><br><span class="line">        :param request: 请求对象</span><br><span class="line">        :param spider: 爬虫对象</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        request.headers.setdefault(b&apos;User-Agent&apos;, self.ua.random)</span><br><span class="line">        print(request)</span><br><span class="line">        # 设置代理ip</span><br><span class="line">        # request.meta[&apos;proxy&apos;] = &apos;http://xxx.xxx.xx.xx:端口&apos;</span><br></pre></td></tr></table></figure></li></ul><p><strong>最后需要在settings中更改以下配置</strong><br><img src="/2018/06/11/RandomUA/01.png" alt="图片丢失..."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在settings中设置通用请求头(一般不用)&lt;br&gt;&lt;img src=&quot;/2018/06/11/RandomUA/02.png&quot; alt=&quot;图片丢失...&quot;&gt;&lt;/li&gt;
&lt;li&gt;设置随机请求头先终端命令&lt;strong&gt;pip install fake_user
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chenzqi.cn/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>时光如水 流水无言</title>
    <link href="http://chenzqi.cn/2017/12/02/%E8%AF%AD%E5%BD%95/"/>
    <id>http://chenzqi.cn/2017/12/02/语录/</id>
    <published>2017-12-02T09:03:58.000Z</published>
    <updated>2018-12-02T17:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>年轻的时候，我们都有一个梦想，长大以后要带着父母环游世界。</strong></p><p><strong>但是等我们真正成年或者娶妻生子了，却总是忘了和父母联系。</strong></p><p><strong>不记得他们的生日，也不关心他们的身体，即使有时候回家和他们坐在一起，也总是感觉和他们聊不到一块。</strong></p><p><strong>我们开始嫌弃他们唠叨、不爱卫生、爱贪小便宜、管得太多……想和他们保持距离。</strong></p><p><strong>成年或者是独立以后，不要说带父母去环游世界了，就连他们生病或者离开人世的时候，也许我们都没有陪他们去医院或者是留在他们的身边。</strong></p><p><strong>曾经在网上看到过一个视频，一个老母亲因为三个儿子从未回家探望过她，便把自己的三个儿子告上了法院，要求他们支付九个月的“房费”。</strong></p><p><strong>这个老母亲其实并不差钱，她之所以这么做，无非就是想提醒自己的孩子们记得常回家看看，不要忘了她。</strong></p><p><strong>生儿育女，父母要的其实并不多，他们只是希望在垂暮之年有儿女们的惦念或者是陪伴，足矣。</strong></p><p><strong>“父母在，人生尚有来处；父母去，人生只剩归途。”</strong></p><p><img src="/2017/12/02/语录/01.jpg" alt=""><br><strong>有着未来想带父母远游的心，不如先试着多给父母打几次电话。听听他们唠唠家常，讲讲自己最近的生活过得怎么样。</strong></p><p><strong>与其给未来许下陪伴的梦想，不如珍惜当下的幸福时光。</strong></p><p><strong>一味地观望与等待，只会是虚无中的精彩。朋友不等你，爱人不等你，父母不等你，孩子不等你，即使有些东西在等你，可是光阴不等你。</strong></p><p><strong>当你失去了，后悔了，还能做什么？还能去哪里呢？</strong></p><p><strong>生活中，有太多的事情是我们不能控制的。明明约定好了的事情，本来信心满满地期待着它的发生，结果路走到一半就遭遇厄运，曾经约定好的事情却难以维持下去。</strong></p><p><img src="/2017/12/02/语录/02.jpg" alt=""><br><strong>我们的岁月不长，不长，容不下慢慢地去细想。</strong></p><p><strong>时光很急，很急，不要等到一切来不及。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;年轻的时候，我们都有一个梦想，长大以后要带着父母环游世界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是等我们真正成年或者娶妻生子了，却总是忘了和父母联系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不记得他们的生日，也不关心他们的身体，即使有
      
    
    </summary>
    
      <category term="语录&amp;生活" scheme="http://chenzqi.cn/categories/%E8%AF%AD%E5%BD%95-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>scrapy框架安装</title>
    <link href="http://chenzqi.cn/2017/11/10/scrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://chenzqi.cn/2017/11/10/scrapy框架安装/</id>
    <published>2017-11-10T11:44:11.000Z</published>
    <updated>2018-12-02T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 </strong></p><h4 id="Windows平台安装"><a href="#Windows平台安装" class="headerlink" title="Windows平台安装"></a>Windows平台安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、安装wheel</span><br><span class="line">      pip install wheel</span><br><span class="line">2、安装lxml</span><br><span class="line">是一种使用Python编写的库，可以迅速，灵活地处理XML</span><br><span class="line">      pip install lxml  备用网址：https://pypi.python.org/pypi/lxml/4.1.0</span><br><span class="line">3、安装pyopenssl</span><br><span class="line">      在视窗下，是没有预装pyOPENSSL的，而在Linux的下是已经安装好的</span><br><span class="line">      https://pypi.python.org/pypi/pyOpenSSL/17.5.0 </span><br><span class="line">4、安装Twisted</span><br><span class="line">      https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载对应版本,本地 pip install 本地文件 安装</span><br><span class="line">5、安装pywin32</span><br><span class="line">      https://github.com/mhammond/pywin32/releases 在windows下,必须安装pywin32,下载后直接双击安装</span><br><span class="line">6、安装scrapy</span><br><span class="line">      pip install scrapy</span><br></pre></td></tr></table></figure><h5 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h5><p>输入Scrapy<br>如果提示如下命令，就证明安装成功，如果失败了，请检查上述步骤有何疏漏<br><img src="/2017/11/10/scrapy框架安装/01.png" alt="图片"></p><h4 id="Linux-Ubuntu平台安装"><a href="#Linux-Ubuntu平台安装" class="headerlink" title="Linux Ubuntu平台安装"></a>Linux Ubuntu平台安装</h4><p>Linux下安装非常简单，只需要执行几条命令几个</p><h5 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python2.7 python2.7-dev</span><br></pre></td></tr></table></figure><p>下载好之后，选中该文件所在路径，执行下面的命令<br>sudo python get-pip.py</p><h5 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h5><p>由于Linux下已经预装了lxml和OPENSSL<br>如果想验证lxml，可以分别输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lxml</span><br></pre></td></tr></table></figure></p><p>出现下面的提示这证明已经安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Requirement already satisfied (use --upgrade to upgrade): lxml in /usr/lib/python2.7/dist-packages</span><br></pre></td></tr></table></figure></p><p>如果想验验openssl，则直接输入openssl即可，如果跳转到OPENSSL命令行，则安装成功<br>接下来直接安装Scrapy即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install Scrapy</span><br></pre></td></tr></table></figure></p><p>安装完毕之后，输入scrapy 验证是否安装成功<br>注意，这里的linux下不要输入Scrapy，linux下依然严格区分大小写<br>出现跟Windows结果一样则成功</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 这里系统以Win10为例,首先,要配置好Python环境,我用的是3.5版本 &lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Windows平台安装&quot;&gt;&lt;a href=&quot;#Windows平台安装&quot; class=&quot;headerlink&quot; title=&quot;Windo
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chenzqi.cn/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
      <category term="框架" scheme="http://chenzqi.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="安装" scheme="http://chenzqi.cn/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy爬虫框架概述</title>
    <link href="http://chenzqi.cn/2017/11/05/Scrapy%E6%A1%86%E6%9E%B6/"/>
    <id>http://chenzqi.cn/2017/11/05/Scrapy框架/</id>
    <published>2017-11-05T09:14:31.000Z</published>
    <updated>2018-12-02T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试</strong></p><h4 id="Scrapy框架组件"><a href="#Scrapy框架组件" class="headerlink" title="Scrapy框架组件"></a>Scrapy框架组件</h4><p><img src="/2017/11/05/Scrapy框架/01.png" alt="图片"></p><ul><li><h5 id="引擎-Engine"><a href="#引擎-Engine" class="headerlink" title="引擎(Engine)"></a>引擎(Engine)</h5>用来处理整个系统的数据流, 触发事务(框架核心)</li><li><h5 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h5>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</li><li><h5 id="下载器-Downloader"><a href="#下载器-Downloader" class="headerlink" title="下载器(Downloader)"></a>下载器(Downloader)</h5>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</li><li><h5 id="爬虫-Spiders"><a href="#爬虫-Spiders" class="headerlink" title="爬虫(Spiders)"></a>爬虫(Spiders)</h5>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</li><li><h5 id="项目管道-Pipeline"><a href="#项目管道-Pipeline" class="headerlink" title="项目管道(Pipeline)"></a>项目管道(Pipeline)</h5>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li><li><h5 id="下载器中间件-Downloader-Middlewares"><a href="#下载器中间件-Downloader-Middlewares" class="headerlink" title="下载器中间件(Downloader Middlewares)"></a>下载器中间件(Downloader Middlewares)</h5>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li><li><h5 id="爬虫中间件-Spider-Middlewares"><a href="#爬虫中间件-Spider-Middlewares" class="headerlink" title="爬虫中间件(Spider Middlewares)"></a>爬虫中间件(Spider Middlewares)</h5>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</li><li><h5 id="调度中间件-Scheduler-Middewares"><a href="#调度中间件-Scheduler-Middewares" class="headerlink" title="调度中间件(Scheduler Middewares)"></a>调度中间件(Scheduler Middewares)</h5>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应</li></ul><h4 id="Scrapy运行流程"><a href="#Scrapy运行流程" class="headerlink" title="Scrapy运行流程"></a>Scrapy运行流程</h4><ul><li>引擎从调度器中取出一个链接(URL)用于接下来的抓取</li><li>引擎把URL封装成一个请求(Request)传给下载器</li><li>下载器把资源下载下来，并封装成应答包(Response)</li><li>爬虫解析Response</li><li>解析出实体（Item）,则交给实体管道进行进一步的处理</li><li>解析出的是链接（URL）,则把URL交给调度器等待抓取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;br&gt;其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon
      
    
    </summary>
    
      <category term="框架&amp;Spider" scheme="http://chenzqi.cn/categories/%E6%A1%86%E6%9E%B6-Spider/"/>
    
    
      <category term="scrapy" scheme="http://chenzqi.cn/tags/scrapy/"/>
    
      <category term="框架" scheme="http://chenzqi.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>TXT文本存储</title>
    <link href="http://chenzqi.cn/2017/10/14/txt/"/>
    <id>http://chenzqi.cn/2017/10/14/txt/</id>
    <published>2017-10-14T06:22:14.000Z</published>
    <updated>2018-12-02T02:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件</strong></p><h3 id="1-基本实例"><a href="#1-基本实例" class="headerlink" title="1.基本实例"></a>1.基本实例</h3><p>首先，本次保存知乎上“发现”页面的“热门话题”部分,将其问题和答案统一保存成文本形式;可以用requests将网页源代码获取下来,这里使用pyquery解析库解析，接下来将提取的标题、回答者、回答保存到文本，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line">url = &apos;https://www.zhihu.com/explore&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;</span><br><span class="line">&#125;</span><br><span class="line">html = requests.get(url, headers=headers).text</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(&apos;.explore-tab .feed-item&apos;).items()</span><br><span class="line">for item in items:</span><br><span class="line">    question = item.find(&apos;h2&apos;).text()</span><br><span class="line">    author = item.find(&apos;.author-link-line&apos;).text()</span><br><span class="line">    answer = pq(item.find(&apos;.content&apos;).html()).text()</span><br><span class="line">    print(question, author, answer)</span><br><span class="line">    file = open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure></p><p>主要是为了演示文件保存的方式，因此requests异常处理部分在此省去。首先，用requests提取知乎的“发现”页面，然后将热门话题的问题、回答者、答案全文提取出来，然后利用Python提供的open()方法打开一个文本文件，获取一个文件操作对象，这里赋值为file，接着利用file对象的write()方法将提取的内容写入文件，最后调用close()方法将其关闭，这样抓取的内容即可成功写入文本中了。<br>运行程序，可以发现在本地生成了一个explore.txt文件，其内容如图下所示<br><img src="/2017/10/14/txt/01.png" alt=""><br>这里open()方法的第一个参数即要保存的目标文件名称，第二个参数为a，代表以追加方式写入到文本。另外，我们还指定了文件的编码为utf-8。最后，写入完成后，还需要调用close()方法来关闭文件对象。</p><h3 id="2-打开方式"><a href="#2-打开方式" class="headerlink" title="2.打开方式"></a>2.打开方式</h3><p>在刚才的实例中，open()方法的第二个参数设置成了a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。</p><ul><li>r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</li><li>rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头。</li><li>r+：以读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头。</li><li>w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li><li>a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li><li>a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。</li><li>ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写</li></ul><h3 id="3-简化写法"><a href="#3-简化写法" class="headerlink" title="3.简化写法"></a>3.简化写法</h3><ul><li>另外，文件写入还有一种简写方法，那就是使用with as语法。在with控制块结束时，文件会自动关闭，所以就不需要再调用close()方法了。这种保存方式可以简写如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>如果想保存时将原文清空，那么可以将第二个参数改写为w，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;explore.txt&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as file:</span><br><span class="line">    file.write(&apos;\n&apos;.join([question, author, answer]))</span><br><span class="line">    file.write(&apos;\n&apos; + &apos;=&apos; * 50 + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>上面便是利用Python将结果保存为TXT文件的方法，这种方法简单易用，操作高效，是一种最基本的保存数据的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。本节中，我们就来看下如何利用Python保存TXT文本文件&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="储存&amp;数据库" scheme="http://chenzqi.cn/categories/%E5%82%A8%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据存储" scheme="http://chenzqi.cn/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
